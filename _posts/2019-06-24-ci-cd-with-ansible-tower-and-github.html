---
layout: single
title: CI/CD with Ansible Tower and GitHub
categories:
- code
tags:
- "ci/cd"
- Ansible
- Ansible Tower
- development
- DevOps
- Golang
- opensource
---
<h2><img class="alignnone  wp-image-13796" src="{{ site.baseurl }}/assets/2019/06/red-hat-ansible-tower-vector-logo.png" alt="red-hat-ansible-tower-vector-logo" width="250" height="139" /><img class="alignnone size-full wp-image-12472" src="{{ site.baseurl }}/assets/2019/06/plus_sign.gif" alt="plus_sign" width="161" height="161" /><img class="alignnone  wp-image-13797" src="{{ site.baseurl }}/assets/2019/06/2cb670b6ddd8922a1c1b2fee4f6f758c.jpg" alt="2cb670b6ddd8922a1c1b2fee4f6f758c" width="213" height="160" /></h2>
<h2>Overview</h2>
<p>Over the last few years CI/CD (Continuous Integration/Continuous Deployment) thanks to new technologies has become a lot easier. It should no longer be a major thorn in the side of developers. Many are moving to cloud platforms which has CI/CD built-in (Azure DevOps for example), others are using Kubernetes which clearly reduces a lot of the complexity around CI/CD. Still at many organizations I see Jenkins or other complex and often homegrown tooling. I certainly recognize this tooling was needed but in 2019 there are better, more streamlined options. Now I get it, our butler Jenkins has served us well, for many years, he has become part of our family. But just like the famous Butler, Alfred from Batman, he has gotten old and likely it is time to look into retirement.</p>
<p>In this article we will discuss and demonstrate how to use Ansible Tower and GitHub for CI/CD.</p>
<p>A video presentation and demonstration is available at following URL: <a href="https://youtu.be/lyk-CRVXs8I">https://youtu.be/lyk-CRVXs8I</a></p>
<p><!--more--></p>
<h2>Why Ansible Tower for CI/CD?</h2>
<p>Most organizations are adopting an infrastructure-as-code approach, that is to say everyone, even operations are becoming developers or at least working and thinking like developers. The automation tool of choice or even standard if you will is clearly Ansible. However Ansible is just an automation runtime, it has no API, RBAC, Credentials and does not enable collaboration between teams. This is where Ansible Tower (or AWX the opensource project) shines. Here are some advantages Ansible Tower bring to CI/CD:</p>
<ul>
<li>Reuse infrastructure and operations playbooks in CI/CD</li>
<li>Better collaboration between devops and infrastructure teams</li>
<li>Simple CI/CD, just Ansible, no DML, no Groovy, no god knows what</li>
<li>Ansible Tower is a enterprise product not a project like Jenkins</li>
<li>Streamlined CI/CD instead of every devops team on their own</li>
<li>Self organizing and governing because that is what Ansible does best</li>
</ul>
<p>Now clearly Ansible Tower cannot do everything. It does not have for example a built-in CI/CD approval process and does not specifically focus on CI/CD. Instead Ansible Tower is an automation platform. It views the world through job templates (a playbook) and workflows (group of playbooks). In this case a workflow is a CI/CD pipeline with an API in front of it of course. Once you have your workflows or pipelines and an API in front of them you are 90% done. The rest is just how the process should flow and you might not even need any extra tooling to do that, certainly not complex tooling like Jenkins.</p>
<h2>Ansible Tower CI/CD Architecture</h2>
<p>The point of this article is to demonstrate that CI/CD can work very simply and with just Ansible Tower and GitHub. The diagram below illustrates what we will be building. This focuses only really on CI but CD would just be additional workflows.</p>
<p><img class="alignnone  wp-image-13779" src="{{ site.baseurl }}/assets/2019/06/tower_ci_cd_process.png" alt="tower_ci_cd_process" width="1054" height="654" /></p>
<p>The main purpose of CI is of course to protect the master branch so it always builds. The only way you do that of course is to check code into another branch (like a feature branch), test that code, review code and only merge to master when you are sure all tests have passed. The above architecture accomplished exactly that and does so with a very simplified approach that leverages Ansible Tower as our CI engine. We won't be going into the CD details in this article, but that would just be additional workflows to deploy artifacts generated by the CI process into dev-&gt;test-&gt;production. Using this architecture one could use GitHub releases to store artifacts. GitHub has ability to then trigger a webhook when latest release is updated which in turn could trigger an Ansible Tower CD workflow.</p>
<h2>Ansible Tower Configuration</h2>
<p>First we will want to configure a workflow in Ansible Tower that will be a CI/CD pipeline. I think it is good practice to have one workflow per pipeline. In this example we have a single workflow which handles CI.</p>
<h4>Configure Credentials</h4>
<p>We need machine credentials for Fedora since we will be accessing a fedora host to execute our build. In Ansible Tower credentials allow you to access systems without needing to connect to them directly, like you would with normal Ansible. Users don't even need to know credentials.</p>
<p><img class="alignnone  wp-image-13782" src="{{ site.baseurl }}/assets/2019/06/tower_1-1.png" alt="tower_1" width="812" height="265" /></p>
<h4>Configure Inventory</h4>
<p>Inventories in Ansible Tower are generated dynamically. This is important because when we provision a VM we don't at the time know what it's IP will be. Of course after we provision we want to access the VM. The solution is to perform an inventory update after provisioning and then parameterize provisioning and execution playbooks so they create/use same hostnames.</p>
<p>Here we are using OpenStack but this could be any public or private cloud. For doing CI we created an inventory called development and this is what we will be later using in our job templates.</p>
<p><img class="alignnone  wp-image-13783" src="{{ site.baseurl }}/assets/2019/06/tower_2.png" alt="tower_2" width="1469" height="458" /></p>
<h4>Configure Projects</h4>
<p>Projects in Ansible Tower are simply SCM repositories where playbooks reside. In this case of course a GitHub repository. Here notice the developer playbooks to do the build are located with the source code where the provisioning playbooks are in a different repository. This is where we get collaboration between infrastructure operations teams and devops. Something that rarely existed in CI/CD.</p>
<p>Links to <a href="https://github.com/ktenzer/go-hello-world">go-hello-world</a> and <a href="https://github.com/ktenzer/openshift-and-openstack-use-cases">paas-and-iaas</a> repositories.</p>
<p><img class="alignnone  wp-image-13784" src="{{ site.baseurl }}/assets/2019/06/tower_3.png" alt="tower_3" width="854" height="221" /></p>
<h4>Configure Job Templates</h4>
<p>For our CI pipeline we will need to run three playbooks. Each playbook is a job template. In Ansible Tower a job template is a playbook, it's inventory, survey, credentials and various other things that go way beyond plain old Ansible. The three job templates are one to provision a fedora instance (from infrastructure / operations team), a playbook to perform the go build / tests (from devops team) and a playbook to cleanup (from infrastructure / operations team).</p>
<p><img class="alignnone  wp-image-13785" src="{{ site.baseurl }}/assets/2019/06/twer_4.png" alt="twer_4" width="1183" height="461" /></p>
<h4>Configure Ansible Tower Workflow</h4>
<p>As mentioned a workflow will bring all the playbooks/job templates together. Here we configure a workflow called GO CI/CD Workflow. Notice the below workflow. We are using our three job templates provision fedora, run go build and remove instance. In addition the second step performs an inventory update for the development inventory. A workflow allows you to perform granular inventory updates wherever needed.</p>
<p><img class="alignnone  wp-image-13786" src="{{ site.baseurl }}/assets/2019/06/tower_5.png" alt="tower_5" width="922" height="419" /></p>
<p>We aren't quite done, the last step is to add a survey to the Workflow. Each of the playbooks of course accept parameters. These need to be added in form of survey. A survey provides a user friendly interface for parameterizing workflows or job templates in Ansible Tower.</p>
<p><img class="alignnone size-full wp-image-13787" src="{{ site.baseurl }}/assets/2019/06/tower_6.png" alt="tower_6" width="1740" height="874" /></p>
<h2>Ansible Tower CI/CD Setup</h2>
<p>The first thing to do is setup tower-cli. This is a much better tool than curl to trigger Ansible Tower. From the webhook we will use tower-cli to update projects in Ansible Tower and launch workflows.</p>
<h4>Install tower-cli</h4>
<p>My fellow Colleague, Andreas Neeb created a role to install tower-cli.</p>
<p><a href="https://github.com/andyneeb/ansible-demo-infra/tree/master/roles/tower-cli-setup">https://github.com/andyneeb/ansible-demo-infra/tree/master/roles/tower-cli-setup</a></p>
<p>Simply create playbook that uses role on localhost or host in your inventory where you want to install tower-cli.</p>
<h4>Fork go-hello-world</h4>
<p>&nbsp;</p>
<h4>Configure GitHub Webhook Token</h4>
<p>In order to update commit status in GitHub we need permissions and a webhook token.</p>
<p>In GitHub under your user-&gt;settings go to developer settings.</p>
<p><img class="alignnone  wp-image-13777" src="{{ site.baseurl }}/assets/2019/06/github1.png" alt="github1" width="891" height="131" /></p>
<p>Select personal access tokens and create a new one.</p>
<p><img class="alignnone size-full wp-image-13778" src="{{ site.baseurl }}/assets/2019/06/github2.png" alt="github2" width="1175" height="498" /></p>
<p>Add a note and select repo:status. This is the minimum permission in GitHub needed to update a commit status. For CI/CD you need to be able in GitHub update commit status.</p>
<h4>Configure GitHub Webhook</h4>
<p>In GitHub go to the go-hello-world project. Under settings create a new webhook.</p>
<p><img class="alignnone size-full wp-image-13780" src="{{ site.baseurl }}/assets/2019/06/github3.png" alt="github3" width="1487" height="1002" /></p>
<p>Make sure content-type is application/json and set a secret, this is a password that will be used to authenticate to the webhook listener we will deploy next.</p>
<h4>Install Webhook Listener on Ansible Tower</h4>
<p>The folks at Arctiq created a role and playbook for setting up a webhook listener on Ansible Tower.</p>
<p><a href="https://github.com/ArctiqTeam/tower-webhook">https://github.com/ArctiqTeam/tower-webhook</a></p>
<p>Simply clone the repository, update the vars.yml  and hosts file according.</p>
<pre># vi hosts
[webhook]
webhookserver ansible_host=46.4.207.248 ansible_ssh_port=22</pre>
<pre># vi vars.yml
---
projects:
- id: 7
name: go-hello-world</pre>
<pre># export GH_SECRET=
# export TOWER_PASSWORD=
# ansible-playbook install.yml</pre>
<p>The playbook will create a systemctl service called webhook so it can easily be started and stopped. The webhook will run on port 9000.</p>
<h4> Configure Webhook Listener</h4>
<p>In order to use webhook for CI/CD some changes need to be made. Update the webhook.conf as follows.</p>
<pre># vi /etc/webhook/webhook.conf
[
  {
    "id": "go-hello-world",
    "execute-command": "/usr/local/bin/go-hello-world.sh",
    "pass-environment-to-command":
    [
      {
        "source": "payload",
        "name": "head_commit.id",
        "envname": "COMMIT_ID"
      },
      {
        "source": "payload",
        "name": "pusher.name",
        "envname": "PUSHER_NAME"
      },
      {
        "source": "payload",
        "name": "pusher.email",
        "envname": "PUSHER_EMAIL"
      },
      {
        "source": "payload",
        "name": "head_commit.id",
        "envname": "COMMIT_ID"
      },
      {
        "source": "payload",
        "name": "pusher.name",
        "envname": "PUSHER_NAME"
      },
      {
        "source": "payload",
        "name": "ref",
        "envname": "REF"
      }
    ],
    "trigger-rule":
    {
      "match":
      {
        "type": "payload-hash-sha1",
        "secret": "&lt;password&gt;",
        "parameter":
        {
          "source": "header",
          "name": "X-Hub-Signature"
        }
      }
    }
  }
]
</pre>
<h4>Restart webhook</h4>
<pre># systemctl restart webhook</pre>
<p>Next update the shell script go-hello-world.sh. This will be triggered each time a push request is sent to GitHub. It will also receive environment parameters needed for CI from GitHub.</p>
<pre># vi /usr/local/bin/go-hello-world.sh
#!/bin/sh
printenv &gt;/tmp/env.out
BRANCH=`echo $REF |sed -e 's/refs\/heads\///g'`

### Set Github commit to pending CI/CD
curl "https://api.GitHub.com/repos/ktenzer/go-hello-world/statuses/$COMMIT_ID?access_token=79dc2a78c4c009c3c08e6cbc8233559c535fc8dc" -H "Content-Type: application/json" -X POST -d "{\"state\": \"pending\",\"context\": \"continuous-integration/go-hello-world\", \"description\": \"Ansible_Tower\", \"target_url\": \"https://46.4.207.248\"}"

### Update Project in Tower
tower-cli project update 7 -v -h 46.4.207.248 --wait
if [ $? != 0 ]; then
        curl "https://api.GitHub.com/repos/ktenzer/go-hello-world/statuses/$COMMIT_ID?access_token=&lt;token&gt;" -H "Content-Type: application/json" -X POST -d "{\"state\": \"error\",\"context\": \"continuous-integration/go-hello-world\", \"description\": \"Ansible_Tower\", \"target_url\": \"https://46.4.207.248\"}"
        exit 1
fi

### Execute CI/CD Workflow in Tower
tower-cli workflow_job launch --workflow-job-template=18 -v -h 46.4.207.248 -e openstack_user=admin -e openstack_passwd=&lt;password&gt; -e openstack_auth_url=http://85.10.236.4:5000/v3 -e openstack_project=development -e instance_name=gobuilder -e instance_security_group=dev_base -e instance_image=fedora_28 -e instance_ssh_key_name=admin -e ssh_user=fedora -e instance_network=development -e instance_flavor=m1.small -e repo_url=https://github.com/ktenzer/go-hello-world.git -e repo_branch=$BRANCH -e app_path=hello/src -e app_name=hello --wait

### Update Github commit based on success or failure of CI/CD workflow
if [ $? != 0 ]; then
        curl "https://api.GitHub.com/repos/ktenzer/go-hello-world/statuses/$COMMIT_ID?access_token=&lt;token&gt;" -H "Content-Type: application/json" -X POST -d "{\"state\": \"error\",\"context\": \"continuous-integration/go-hello-world\", \"description\": \"Ansible_Tower\", \"target_url\": \"https://46.4.207.248\"}"
        exit 1

else
        curl "https://api.GitHub.com/repos/ktenzer/go-hello-world/statuses/$COMMIT_ID?access_token=&lt;token&gt;" -H "Content-Type: application/json" -X POST -d "{\"state\": \"success\",\"context\": \"continuous-integration/go-hello-world\", \"description\": \"Ansible_Tower\", \"target_url\": \"https://46.4.207.248\"}"
        exit 0
fi
</pre>
<h2>Run CI/CD Pipeline using Ansible Tower</h2>
<h4>Clone go-hello-world repository</h4>
<pre># git clone https://github.com/ktenzer/go-hello-world.git</pre>
<h4>Create feature branch</h4>
<pre># git branch patch-1
# git checkout patch-1</pre>
<h4>Add broken code</h4>
<pre># vi src/hello/main.go
...
func main() {
        &lt;broken&gt;
	router := NewRouter()
...
</pre>
<h4>Commit broken code</h4>
<pre># git commit -a -m "broken code"

# git push origin patch-1</pre>
<h4>Create pull request in GitHub</h4>
<p>Under branches you will now see the patch-1 branch.</p>
<p><img class="alignnone  wp-image-13788" src="{{ site.baseurl }}/assets/2019/06/github1-1.png" alt="github1.png" width="782" height="354" /></p>
<p>You can now create a pull request in GitHub.</p>
<p><img class="alignnone  wp-image-13789" src="{{ site.baseurl }}/assets/2019/06/github2-1.png" alt="github2.png" width="1198" height="409" /></p>
<p>Notice that CI/CD is in progress and the source is Ansible Tower. Of course the CI will fail since we broke the code. In Tower you can see looking at the go build job.</p>
<p><img class="alignnone  wp-image-13790" src="{{ site.baseurl }}/assets/2019/06/tower2.png" alt="tower2.png" width="1588" height="320" /></p>
<p>Looking at our pull request in GitHub it also now shows error.</p>
<p><img class="alignnone size-full wp-image-13791" src="{{ site.baseurl }}/assets/2019/06/github4.png?w=1026" alt="github4.png" width="1026" height="353" /></p>
<p>Notice the CI/CD process spawned a VM to perform build and run tests.</p>
<p><img class="alignnone size-full wp-image-13795" src="{{ site.baseurl }}/assets/2019/06/osp1.png?w=1062" alt="osp1.png" width="1062" height="328" /></p>
<p>In this case the instance is not removed since the test failed. The idea is likely the developer would want to fix it and since we are using Ansible, once a fix is committed we will start where we left off, saving potentially a lot of time.</p>
<h4>Fix broken code</h4>
<pre># vi src/hello/main.go
...
func main() {
	router := NewRouter()
...
</pre>
<h4>Commit broken code</h4>
<pre># git commit -a -m "fixed code"

# git push origin patch-1</pre>
<p>This will start the CI/CD process again except this time of course our code builds and CI is successful.</p>
<p>Looking at GitHub we see the pull request has gone through CI and all tests are successful.</p>
<p><img class="alignnone  wp-image-13792" src="{{ site.baseurl }}/assets/2019/06/github5.png" alt="github5.png" width="1314" height="369" /></p>
<p>In Ansible Tower we also see the jobs completed.</p>
<p><img class="alignnone  wp-image-13793" src="{{ site.baseurl }}/assets/2019/06/tower3.png" alt="tower3" width="1712" height="443" /></p>
<p>At this point a developer could review the code and merge it. In GitHub we will now merge the pull request.</p>
<p><img class="alignnone  wp-image-13794" src="{{ site.baseurl }}/assets/2019/06/github6.png" alt="github6.png" width="1032" height="481" /></p>
<p>The CI process is started again this time for the master branch. Once master builds we have a release and can start the CD process. We would as mentioned above, push the release to GitHub releases and that would in turn trigger another workflow or several workflows to deploy the release in various dev, test and production environments. We will not be doing this but I think you get the picture.</p>
<h2>Summary</h2>
<p>In this article we discussed a simpler solution for CI/CD by using just Ansible Tower and GitHub. We saw the advantages of making Ansible reusability the cornerstone of CI/CD, not only in simplicity but bringing infrastructure/operations teams together with development. We went through the configuration and saw a demonstration of how the solution works. If you are interested further or have any questions/feedback please feel free to reach out.</p>
<p>Happy CI/CD’ing!</p>
<p>(c) 2019 Keith Tenzer</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
