---
layout: post
title: Red Hat Enterprise Virtualization Management (RHEV-M) - Overview, APIs and
  Code Examples
date: 2015-01-08 15:56:04.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- RHEV
tags:
- Cloud Computing
- Java
- KVM
- Linux
- Red Hat
- Virtualization
meta:
  _edit_last: '63054820'
  geo_public: '0'
  _wpas_skip_9542380: '1'
  publicize_linkedin_url: https://www.linkedin.com/updates?discuss=&scope=329229505&stype=M&topic=5958984298353688576&type=U&a=D_Vh
  _wpas_skip_9468659: '1'
  _wpas_done_9468659: '1'
  _publicize_done_external: a:1:{s:8:"linkedin";a:1:{s:10:"pzvfqtzaYA";b:1;}}
  _wp_old_slug: red-hat-enterprise-virtualization-management-rhev-m-deep-dive-apis-and-code-examples
  _publicize_job_id: '14430362860'
author:
  login: ktenzer1
  email: keith.tenzer@gmail.com
  display_name: ktenzer
  first_name: ''
  last_name: ''
permalink: "/2015/01/08/red-hat-enterprise-virtualization-management-rhev-m-overview-apis-and-code-examples/"
---
<h3>Overview</h3>
<p>Red Hat Enterprise Virtualization has two main components: RHEV-H and RHEV-M. In this post we will be focusing on RHEV-M which provides a REST API and various SDKs. By integrating with RHEV-M we can integrate a powerful set of virtualization APIs into any applications, processes or workflows. <!--more-->If you are new to RHEV or don't have a lab environment setup, check out this post on <a href="http://keithtenzer.com/2015/01/05/red-hat-enterprise-virtualization-rhev-home-lab-configuration/">building a RHEV lab environment</a>.</p>
<h4>RHEV-H</h4>
<p>Red Hat Enterprise Virtualization Hypervisor (RHEV-H) is a compact, full-featured virtualization platform built on Red Hat Enterprise Linux (RHEL). It has a very small footprint (less than 100MB) and is built from only a subset of RHEL components plus the Kernel-Based Virtual Machine (KVM).</p>
<h4>RHEV-M</h4>
<p>Red Hat Enterprise Virtualization Management (RHEV-M) is a virtual management console built on Red Hat Enterprise Linux (RHEL). It interacts with individual RHEV-H nodes using the Virtual Desktop Server Manager (VDSM). A VDSM agent is running on each of the RHEV-H nodes. RHEV-M allows administrators to manage multiple data centers and their network, compute and storage resources. In addition RHEV-M provides a central repository for storing virtual machines, disks, images and virtual machine snapshots. RHEV-M provides a common feature set such as HA, Load Balancing, Host Fencing, Networking, Storage and more across all hosts and virtual machines.</p>
<p><a href="https://keithtenzer.files.wordpress.com/2015/01/rhevm_architecture1.png"><img class=" wp-image-396 aligncenter" src="{{ site.baseurl }}/assets/2015/01/rhevm_architecture1.png?w=300" alt="RHEVM_Architecture" width="707" height="471" /></a></p>
<h3>RHEV-M Architecture</h3>
<p>RHEV-M is built on top of libvirt and allows for the management of many KVM (Kernel-Based Virtual Machine) hosts. Libvirt just allows for the management of a single KVM host. RHEV-M is downstream from the open-source project <a href="http://www.ovirt.org/Home">oVirt</a>. Red Hat started the oVirt project and though the hypervisor backend is open (KVM, XEN, or VirtualBox) the project is currently focused on KVM. Originally oVirt was based on C# and .NET but has since ported to Java.</p>
<p>RHEV-M has several components: Engine, Interfaces, VDSM Agent and SPICE.</p>
<h4>Engine</h4>
<p>The RHEV-M engine runs on a standalone RHEL host. It inventories as well as exposes virtual resources and allows the administrator to organise those resources across many data centers. In addition it provides capabilities such as HA, authentication, load balancing, live migration, network management, storage management, virtual machine management, image management and monitoring across an entire virtual ecosystem based around the KVM hypervisor. The engine maintains a postgreSQL database for storing relational information about the environment.</p>
<h4>Interfaces</h4>
<p>RHEV-M offers a CLI and a web-based UI built around the Google Web-Framework (GWT). Since RHEV-M uses GWT it is also possible to create plugins and add UI extensions during runtime. RHEV-M offers a powerful REST API and SDKs for Java as well as Python. Later in this post we will give some Java code examples and take a closer look at the SDK.</p>
<h4>VDSM</h4>
<p>The Virtual Desktop Server Manager is an interface abstraction built around libvirt. Since libvirt was only designed to manage a single KVM hypervisor it was necessary to extend capabilities to allow management of 1000s of virtual machines across many KVM hypervisors. VDSM provides the necessary scalability around libvirt. VDSM has a few components. It has a daemon agent that runs on the KVM hypervisor (either RHEV-H or RHEL + KVM), a client component and a manager that is built into the RHEV-M engine.</p>
<h4>SPICE</h4>
<p>RHEV-M uses SPICE in order to display the console of a virtual machine through user interfaces. SPICE is responsible for handling console graphics and sending control commands.</p>
<h3>Java Coding Examples</h3>
<p>Below are several coding examples in Java using the SDK built on the RHEV-M REST API. These code examples will work with RHEV-M and oVirt. The Java SDK is available through maven or direct download from <a href="http://www.ovirt.org/Home">oVirt</a>. To use via maven simply add following to your pom.xml:</p>
<p>[code language="xml"]<br />
&lt;dependency&gt;<br />
   &lt;groupId&gt;org.ovirt.engine.sdk&lt;/groupId&gt;<br />
   &lt;artifactId&gt;ovirt-engine-sdk-java&lt;/artifactId&gt;<br />
   &lt;version&gt;3.4.4.0&lt;/version&gt;<br />
&lt;/dependency&gt;<br />
[/code]</p>
<h4>RHEV-M Connection</h4>
<p>Below is a class that we can instantiate with various parameters. It returns a connection object that is used as the basis in other examples:</p>
<p>[code language="java"]<br />
import org.ovirt.engine.sdk.Api;</p>
<p>public class RhevConnection {</p>
<p>    private String URL;<br />
    private String domain;<br />
    private String username;<br />
    private String password;</p>
<p>    public RhevConnection(String hostname, Integer port, Boolean sslEnable, String username, String password, String domain) {<br />
        if (sslEnable) {<br />
            this.URL = &quot;https://&quot; + hostname + &quot;:&quot; + port + &quot;/api&quot;;<br />
        } else {<br />
            this.URL = &quot;http://&quot; + hostname + &quot;:&quot; + port + &quot;/api&quot;;<br />
        }</p>
<p>        this.domain = domain;<br />
        this.username = username;<br />
        this.password = password;<br />
    }</p>
<p>    public Api getConnection() throws Exception {</p>
<p>        Api api = null;<br />
        try {<br />
            api = new Api(URL, username + &quot;@&quot; + domain, password, true);<br />
        } catch (Exception e) {<br />
            throw new Exception(e.getMessage(), e);<br />
        }</p>
<p>        return api;<br />
    }<br />
}<br />
[/code]</p>
<h4>Data Centers</h4>
<p>The top-level organisational entity in RHEV-M is the data center. It is meant to be a logical or physical segregation of virtual resources. Data Centers contain storage domains, networks, clusters and of course hypervisor hosts. Below is a Java example that uses a defined model to return details about data centers:</p>
<p>[code language="java"]<br />
    public List&lt;DataCenterModel&gt; inventoryDataCenters() throws Exception {<br />
        List&lt;DataCenterModel&gt; dcModelList = new ArrayList&lt;DataCenterModel&gt;();</p>
<p>        try {<br />
            for (DataCenter dc : api.getDataCenters().list()) {<br />
                DataCenterModel dcModel = new DataCenterModel();</p>
<p>                dcModel.setName(dc.getName());<br />
                dcModel.setDescription(dc.getDescription());<br />
                dcModel.setIsLocal(dc.getLocal());<br />
                dcModel.setStatus(dc.getStatus().getState());</p>
<p>                dcModelList.add(dcModel);<br />
            }<br />
        } catch (Exception e) {<br />
            throw new Exception(e.getMessage(), e);<br />
        }</p>
<p>        return dcModelList;<br />
    }<br />
[/code]</p>
<h4> Storage Domains</h4>
<p>Storage domains provide storage management within RHEV-M. Virtual machine images and disks are stored in storage domains. A storage domain can be local to hypervisor host or shared across many hosts. A storage domain can be NFS, ISCSI, FC, Gluster, Ceph or ZFS. Below is a Java example that uses a defined model to return details of storage domains:</p>
<p>[code language="java"]<br />
    public List&lt;StorageDomainModel&gt; inventoryStorageDomains() throws Exception {<br />
        List&lt;StorageDomainModel&gt; storageDomainModelList = new ArrayList&lt;StorageDomainModel&gt;();</p>
<p>        try {<br />
            List&lt;StorageDomain&gt; storageDomainList = api.getStorageDomains().list();</p>
<p>            for (StorageDomain storageDomain : storageDomainList) {<br />
                StorageDomainModel storageDomainModel = new StorageDomainModel();<br />
                storageDomainModel.setName(storageDomain.getName());<br />
                storageDomainModel.setDescription(storageDomain.getDescription());<br />
                storageDomainModel.setDomainType(storageDomain.getType());<br />
                storageDomainModel.setStorageType(storageDomain.getStorage().getType());<br />
                storageDomainModel.setPath(storageDomain.getStorage().getPath());<br />
                storageDomainModel.setAvailable(storageDomain.getAvailable());<br />
                storageDomainModel.setUsed(storageDomain.getUsed());</p>
<p>                storageDomainModelList.add(storageDomainModel);<br />
            }<br />
        } catch (Exception e) {<br />
            throw new Exception(e.getMessage(), e);<br />
        }</p>
<p>        return storageDomainModelList;<br />
    }<br />
[/code]</p>
<h4>Hosts</h4>
<p>In RHEV-M a host is a RHEL system running KVM and the VDSM agent. As mentioned you can either use RHEV-H which comes with everything you need out-of-the-box or RHEL and add KVM / VDSM packages manually. Below is a Java example that uses a defined model to return details of hosts:</p>
<p>[code language="java"]<br />
    public List&lt;HostModel&gt; inventoryHosts() throws Exception {<br />
        List&lt;HostModel&gt; hostList = new ArrayList&lt;HostModel&gt;();</p>
<p>        try {<br />
            List&lt;Host&gt; hosts = api.getHosts().list();<br />
            for (Host host : hosts) {<br />
                HostModel hostModel = new HostModel();<br />
                hostModel.setName(host.getName());<br />
                hostModel.setIp(host.getAddress());<br />
                hostModel.setCpuType(host.getCpu().getName());<br />
                hostModel.setCpuCores(host.getCpu().getTopology().getCores());<br />
                hostModel.setMemory(host.getMemory());<br />
                hostModel.setOsType(host.getOs().getType());<br />
                hostModel.setOsVersion(host.getOs().getVersion().getFullVersion());</p>
<p>                hostList.add(hostModel);<br />
            }<br />
        } catch (Exception e) {<br />
            throw new Exception(e.getMessage(), e);<br />
        }</p>
<p>        return hostList;<br />
    }<br />
[/code]</p>
<h4>Virtual Machines</h4>
<p>In RHEV-H virtual machines or as they are referred to in KVM domains provide the building blocks for the RHEV platform. Most actions and things of interest are typically performed on virtual machines. Below are several code examples of typical things administrators would perform on virtual machines.</p>
<p>Listing Virtual Machines</p>
<p>[code language="java"]<br />
    public List&lt;VirtualMachineModel&gt; inventoryVirtualMachines() throws Exception {<br />
        List&lt;VirtualMachineModel&gt; vmModelList = new ArrayList&lt;VirtualMachineModel&gt;();</p>
<p>        try {<br />
            List&lt;VM&gt; vmList = api.getVMs().list();</p>
<p>            for (VM vm : vmList) {<br />
                VirtualMachineModel vmModel = new VirtualMachineModel();<br />
                vmModel.setName(vm.getName());<br />
                vmModel.setCpuCores(vm.getCpu().getTopology().getCores());<br />
                vmModel.setMemory(vm.getMemory());<br />
                vmModel.setOsType(vm.getOs().getType());<br />
                vmModel.setState(vm.getStatus().getState());</p>
<p>                String hostId = vm.getPlacementPolicy().getHost().getId();<br />
                vmModel.setHostName(api.getHosts().getById(hostId).getName());</p>
<p>                vmModelList.add(vmModel);<br />
            }<br />
        } catch (Exception e) {<br />
            throw new Exception(e.getMessage(), e);<br />
        }</p>
<p>        return vmModelList;<br />
    }<br />
[/code]</p>
<p>Create Virtual Machine Snapshot</p>
<p>[code language="java"]<br />
    public void createSnapshot(String vmName, String description) throws Exception {<br />
        try {<br />
            Snapshot snapshot = new Snapshot();<br />
            snapshot.setDescription(&quot;XYZ snapshot [&quot; + description + &quot;]&quot;);<br />
            api.getVMs().get(vmName).getSnapshots().add(snapshot);<br />
        } catch (Exception e) {<br />
            throw new Exception(e.getMessage(), e);<br />
        }<br />
    }<br />
[/code]</p>
<p>Delete Virtual Machine Snapshot</p>
<p>[code language="java"]<br />
    public void deleteSnapshot(String vmName, String snapshotId) throws Exception {<br />
        try {<br />
            api.getVMs().get(vmName).getSnapshots().getById(snapshotId).delete();<br />
        } catch (Exception e) {<br />
            throw new Exception(e.getMessage(), e);<br />
        }<br />
    }<br />
[/code]</p>
<p>Restore Virtual Machine Snapshot</p>
<p>[code language="java"]<br />
    public void restoreSnapshot(String vmName, String snapshotId) throws Exception {<br />
        try {<br />
            Action action = new Action();<br />
            action.setId(snapshotId);<br />
            api.getVMs().get(vmName).getSnapshots().getById(snapshotId).restore(action);<br />
        } catch (Exception e) {<br />
            throw new Exception(e.getMessage(), e);<br />
        }<br />
    }<br />
[/code]</p>
<p>List Virtual Machine Snapshots</p>
<p>[code language="java"]<br />
    public List&lt;SnapshotModel&gt; listSnapshots(String vmName) throws Exception {<br />
        List&lt;SnapshotModel&gt; snapshotList = new ArrayList&lt;SnapshotModel&gt;();</p>
<p>        List&lt;VMSnapshot&gt; snapshots = api.getVMs().get(vmName).getSnapshots().list();<br />
        for (VMSnapshot snapshot : snapshots) {<br />
            SnapshotModel snapshotModel = new SnapshotModel();<br />
            snapshotModel.setId(snapshot.getId());<br />
            snapshotModel.setDescription(snapshot.getDescription());<br />
            snapshotModel.setDate(snapshot.getDate().toString());</p>
<p>            snapshotList.add(snapshotModel);<br />
        }</p>
<p>        return snapshotList;<br />
    }<br />
[/code]</p>
<p>Start Virtual Machine</p>
<p>[code language="java"]<br />
    public void startVirtualMachine(String vmName) throws Exception {<br />
        try {<br />
            Action action = new Action();<br />
            action.setName(vmName);<br />
            ;<br />
            api.getVMs().get(vmName).start(action);<br />
        } catch (Exception e) {<br />
            throw new Exception(e.getMessage(), e);<br />
        }<br />
    }<br />
[/code]</p>
<p>Stop Virtual Machine</p>
<p>[code language="java"]<br />
    public void stopVirtualMachine(String vmName) throws Exception {<br />
        try {<br />
            Action action = new Action();<br />
            action.setName(vmName);<br />
            ;<br />
            api.getVMs().get(vmName).shutdown(action);<br />
        } catch (Exception e) {<br />
            throw new Exception(e.getMessage(), e);<br />
        }<br />
    }<br />
[/code]</p>
<h3> Conclusion</h3>
<p>RHEV is a powerful virtualization platform and certainly has not only the management but also feature capabilities to be on par with other virtualization platforms from VMware and Microsoft. The big advantage of RHEV over Microsoft or VMware is that everything is of course open-source and built in a thriving community. The industry has long wanted an enterprise open-source virtualization platform and now it has one! Hopefully this post was useful and informative. I was very impressed at the easy-of-use of RHEV-M interfaces and APIs. If you have any questions or comments please feel free to ask.</p>
<p>Happy RHEVing!</p>
<p>(c) 2015 Keith Tenzer</p>
