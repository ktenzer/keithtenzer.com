I"6L<h3 class="nowrap">Overview</h3>
<p><a href="https://keithtenzer.files.wordpress.com/2015/08/ose_logo.png"><img class="alignnone size-medium wp-image-1128" src="/assets/2015/08/ose_logo.png?w=300" alt="OSE_LOGO" width="300" height="83" /></a></p>
<p>OpenShift Enterprise v3 by Red Hat is about building and running next-gen applications. If we look around, we have seen startups in virtually every market segment, turning the competitive landscape upside down. Startup companies like NetFlix, Spotify and Uber have literally pushed the incumbents to the brink of extinction and overtaken entire industries in a very short period of time. How have they been able to rival incumbents 100 times their size? The answer is simple, by bringing innovation to the market faster, much faster. Complacency and overcoming previous successes are very challenging for incumbents. It is much easier for a startup to innovate than an existing company with a degree of legacy. OpenShift v3 will level the playing field and provide organizations the appropriate tooling to rapidly reduce their time-to-market.</p>
<p>OpenShift v3 allows organizations to deliver innovation faster by:</p>
<ul>
<li>Maximizing time developers actually spend developing</li>
<li>Enabling efficient clean hand-offs between Dev &amp; Ops (DevOps)</li>
<li>Automating development pipelines and continuous integration / delivery</li>
<li>Increasing speed of innovation through more frequent experimentation</li>
<li>Providing state-of-the-art enterprise grade container infrastructure</li>
</ul>
<p>In this article we will look at how to setup an OpenShift lab environment and get started on the journey to faster innovation cycles.<br />
<!--more--></p>
<h3>Pre Configuration Steps</h3>
<p>OpenShift requires a master and one or more nodes. In this lab we will configure one master and a node. Install RHEL or CentOS 7.1 on two systems and configure hostname as well as network accordingly. On both systems run the following steps:</p>
<pre class="nowrap"># subscription-manager repos --disable="*"</pre>
<pre class="nowrap"># subscription-manager repos --enable="rhel-7-server-rpms"</pre>
<pre class="nowrap"># subscription-manager repos --enable="rhel-7-server-extras-rpms"</pre>
<pre class="nowrap"># subscription-manager repos --enable="rhel-7-server-optional-rpms"</pre>
<pre class="nowrap"># subscription-manager repos --enable="rhel-7-server-ose-3.0-rpms"</pre>
<pre class="nowrap">#yum install wget git net-tools bind-utils iptables-services bridge-utils</pre>
<pre>#yum install python-virtualenv</pre>
<pre>#yum install gcc</pre>
<pre>#yum install httpd-tools</pre>
<pre class="nowrap">#yum install docker</pre>
<pre class="nowrap">#yum update
</pre>
<p class="nowrap">Once all the packages are installed it is important to configure Docker so that is allows for insecure registry communication on local network only.</p>
<pre class="nowrap">#vi /etc/sysconfig/docker
OPTIONS=--selinux-enabled --insecure-registry 192.168.122.0/24</pre>
<p class="nowrap">Setup ssh access from master to node.</p>
<pre>#ssh-keygen</pre>
<pre>#ssh-copy-id -i .ssh/id_rsa.pub root@ose3-node.lab.com</pre>
<h3 class="nowrap">Install OpenShift Enterprise v3</h3>
<p>At this point both the master and node are prepared. We can now begin the install of OpenShift Enterprise v3. From the master run the following command:</p>
<pre>#sh &lt;(curl -s https://install.openshift.com/ose)</pre>
<p class="nowrap">Note: if internet access is not available you can download the installer and run it locally on the master host.</p>
<p class="nowrap"><a href="https://install.openshift.com/portable/oo-install-ose.tgz">https://install.openshift.com/portable/oo-install-ose.tgz</a></p>
<h3 class="nowrap">Configure OpenShift Enterprise v3</h3>
<p>Once the installer completes an OpenShift master and node will exist. Now we can begin with the main configuration. By default OpenShift will use HTTP authentication. This is of course only recommended for lab or test environments. For production environments you will want to connect to LDAP or an identity management system. On the master we can edit the /etc/openshift/master/master-config.yaml and configure authentication.</p>
<pre class="nowrap">#vi /etc/openshift/master/master-config.yaml
identityProviders:
- name: my_htpasswd_provider
challenge: true
login: true
provider:
apiVersion: v1
kind: HTPasswdPasswordIdentityProvider
file: /root/users.htpasswd
routingConfig:
 subdomain: lab.com</pre>
<p>Next we need to create a standard user. OpenShift enterprise creates the system:admin account for default administration.</p>
<pre>#htpasswd -c /root/users.htpasswd admin</pre>
<p>Optionally we can give the newly created admin user, OpenShift cluster-admin permisions.</p>
<pre>#oadm policy add-cluster-role-to-user cluster-admin admin</pre>
<h3>Configure Docker Registry</h3>
<p>OpenShift uses the Docker registry for storing Docker container images. Anytime you build or change an application configuration, a new docker container is created and pushed to the registry. Each node can access this registry. You can and should use persistent storage for the registry. In this example we will use a host mountpoint on the node. The Docker registry runs as a container in the default namespace that only OpenShift admins can access.</p>
<p>On the node create a directory for the registry</p>
<pre>#mkdir /images</pre>
<p class="nowrap">On the master login in using the system:admin account, switch to the default project and create a Docker registry.</p>
<pre class="nowrap"># oc login
Username: system:admin</pre>
<pre class="nowrap">#oc project default</pre>
<pre><span class="body">#echo '{"kind":"ServiceAccount","apiVersion":"v1","metadata":{"name":"registry"}}' | oc create -f -</span></pre>
<pre><span class="body">#oc edit scc privileged</span>
users:
- system:serviceaccount:openshift-infra:build-controller
- system:serviceaccount:default:registry</pre>
<pre>#oadm registry --service-account=registry --config=/etc/openshift/master/admin.kubeconfig  --credentials=/etc/openshift/master/openshift-registry.kubeconfig --images='registry.access.redhat.com/openshift3/ose-${component}:${version}' --mount-host=/images</pre>
<h3 class="nowrap">Create Router</h3>
<p>OpenShift v3 uses OpenVswitch as the software defined network. In order for isolation, proxy and load balancing capabilities a router is needed. The router similar to the Docker registry also runs in a container. Using the below command we can create a router in the default namespace.</p>
<pre>#echo '{"kind":"ServiceAccount","apiVersion":"v1","metadata":{"name":"router"}}' | oc create -f -</pre>
<pre>#oc edit scc privileged
users:
 - system:serviceaccount:openshift-infra:build-controller
 - system:serviceaccount:default:registry
 - system:serviceaccount:default:router</pre>
<pre>#oadm router router-1 --replicas=1 --credentials='/etc/openshift/master/openshift-router.kubeconfig' --images='registry.access.redhat.com/openshift3/ose-${component}:${version}'
</pre>
<h3>Configure DNS</h3>
<p>OpenShift v3 requires a working DNS environment in order to handle URL resolution. The requirement is to create a DNS wildcard that points to the router. This should be the public IP of the node where the router container is running. In our example we have created a local DNS server that acts as a forwarder for the 192.168.122.0 network. In addition we have implemented a DNS wildcard that points to our nodes public or physical IP, where the router container is running.</p>
<pre>#yum install bind-utils bind</pre>
<pre>#systemctl start named</pre>
<pre>#systemctl enable named</pre>
<pre>vi /etc/named.conf
options {listen-on port 53 { 192.168.122.1; };
forwarders {
10.38.5.26;
;
};
zone "lab.com" IN {
 type master;
 file "/var/named/dynamic/lab.com.zone";
 allow-update { none; };
};</pre>
<pre>vi /var/named/dynamic/lab.com.zone
$ORIGIN lab.com.
$TTL 86400
@ IN SOA dns1.lab.com. hostmaster.lab.com. (
 2001062501 ; serial
 21600 ; refresh after 6 hours
 3600 ; retry after 1 hour
 604800 ; expire after 1 week
 86400 ) ; minimum TTL of 1 day
;
;
 IN NS dns1.lab.com.
dns1 IN A 192.168.122.1 
 IN AAAA aaaa:bbbb::1
ose3-master IN A 192.168.122.60
ose3-node1 IN A 192.168.122.61
* 300 IN A 192.168.122.61
;
;
</pre>
<h3>Install and Configure GitHub Lab</h3>
<p>In most cases you will probably want to configure a local GitHub server. This is of course optional. In the example we are using the public GitHub service, however you could easily do this on an internal GitHub server. You can setup the GitHub server on the OpenShift v3 master. For demos it is recommended to use GitHub lab, since it is much easier to install and configure.</p>
<pre>#yum install curl openssh-server</pre>
<pre>#systemctl enable sshd</pre>
<pre>#systemctl start sshd</pre>
<pre>#firewall-cmd --permanent --add-service=http</pre>
<pre>#systemctl reload firewalld</pre>
<pre>#curl <span id="OBJ_PREFIX_DWT5497_com_zimbra_url" class="Object"><span id="OBJ_PREFIX_DWT5498_com_zimbra_url" class="Object"><a href="https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh" target="_blank">https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh</a></span></span> | bash</pre>
<pre>#yum install gitlab-ce</pre>
<pre>#gitlab-ctl reconfigure</pre>
<p>Once the above steps are complete you can access GitHub by connecting through browser to the host.</p>
<pre>Username: root
Password: 5iveL!fe</pre>
<h3>Using OpenShift v3</h3>
<p>At this point we should have a functioning OpenShift v3 environment. We can now build and deloy applications. Here we will see how to deploy a mysql database using scaling and build a ruby hello world application from GitHub.</p>
<h4>Deploying MySQL database</h4>
<p>Though using the OpenShift CLI or API is certainly possible, let us at this point use the UI. To login to the UI open a browser and point it at the IP of the OpenShift v3 master, for example: <a href="https://ose3-master.lab.com:8443/console/">https://ose3-master.lab.com:8443/console/</a>. Create a new project for hosting containers. In OpenShift v3 each project maps to a namespace in Kubernetes. <a href="https://keithtenzer.files.wordpress.com/2015/08/ose_project_create.png"><img class="alignnone wp-image-1115" src="/assets/2015/08/ose_project_create.png?w=300" alt="OSE_PROJECT_CREATE" width="1204" height="321" /></a> Under the demo project deploy a MySQL database by selecting "create" or "getting started". Make sure you add a label, this is explained later. <a href="https://keithtenzer.files.wordpress.com/2015/08/ose_mysql_create.png"><img class="alignnone wp-image-1116" src="/assets/2015/08/ose_mysql_create.png?w=300" alt="OSE_MYSQL_CREATE" width="1203" height="690" /></a> Once an application is created we see the status in the Overview. <a href="https://keithtenzer.files.wordpress.com/2015/08/ose_mysql_created.png"><img class="alignnone wp-image-1117" src="/assets/2015/08/ose_mysql_created.png?w=300" alt="OSE_MYSQL_CREATED" width="1202" height="493" /></a> Each time an application is deployed we have a container deployer and the running container. Once the deployment is complete the deployer container is deleted and we just have the running container. The "oc get pods" command shows us all pods within the namespace. A pod is a Kubernetes construct and means one or more Docker containers that share deployment template. Pods run on nodes, grouping containers within pods is a way to ensure certain containers are localized.</p>
<pre># oc get pods
NAME            READY  REASON     RESTARTS  AGE
mysql-1-deploy  1/1    Running    0         8s
mysql-1-rz165   0/1    Running    0         5s</pre>
<p>For every application deployed, OpenShift will also create a replication controller and service. These are also Kubernetes constructs. A replication controller is used for auto-scaling and determines how many instances of a given pod should exist.</p>
<pre># oc get rc
CONTROLLER  CONTAINER(S)  IMAGE(S)                              SELECTOR                REPLICAS
mysql-1     mysql         .../openshift3/mysql-55-rhel7:latest  deployment=mysql-1,...  1</pre>
<p>The service creates a URL for the application and handles dynamically routing to individual pods. This is handled by the kube-proxy layer and the OpenShift routing layer.</p>
<pre># oc get services
NAME   LABELS                                        SELECTOR    IP(S)          PORT(S)
mysql  demo=mysql,template=mysql-ephemeral-template  name=mysql  172.30.76.121  3306/TCP</pre>
<p>When creating applications it is very important to always define labels. Labels are applied to pods, replication controllers and services. When deleting an application it is very easy to for example reference the label instead of deleting individual components manually.</p>
<pre>#oc delete all --selector="demo=mysql"</pre>
<p>OpenShift v3 also supports auto-scaling. This capability leverages Kubernetes replication controllers. First we need to identify the replication controller using the "oc get rc" command. We can automatically scale our application by changing the number of replicas. In this example we will scale from one to three MySQL databases.</p>
<pre>#oc scale --replicas=3 rc mysql-1</pre>
<p>Upon scaling MySQL, we can quickly see the results in the UI.</p>
<p><a href="https://keithtenzer.files.wordpress.com/2015/08/ose_mysql_scaling.png"><img class="alignnone wp-image-1119" src="/assets/2015/08/ose_mysql_scaling.png?w=300" alt="OSE_MYSQL_SCALING" width="1207" height="499" /></a></p>
<h4>Building Ruby Hello World Application</h4>
<p>So far we have seen how to provision application components such as databases or middleware in seconds. We have also obeserved how we can effortlessly scale these components. In the following example, we will build our own application code in OpenShift v3. OpenShift will provide the Ruby runtime environment and automatically build, as well as launch a container with our hello world code from GitHub. OpenShift utilizes a technology called "Source to Image" (S2I) that efficiently builds the container. Instead of rebuilding the entire container each time, S2I is able to re-use previous builds and only change the application layer within the container. Docker containers are immutable so any change always requires creating a new container. This is a wasteful, time consuming process without OpenShift and S2I.</p>
<p>To build our application select "create" from the project page in the OpenShift UI. Enter the URL to the GitHub repository <a href="https://github.com/ktenzer/ruby-hello-world">https://github.com/ktenzer/ruby-hello-world</a> and select "next".</p>
<p><a href="https://keithtenzer.files.wordpress.com/2015/08/ose_ruby_create_1.png"><img class="alignnone wp-image-1120" src="/assets/2015/08/ose_ruby_create_1.png?w=300" alt="OSE_RUBY_CREATE_1" width="1204" height="277" /></a></p>
<p>OpenShift asks us for the application build runtime. In this case we will select Ruby 2.0 since this is in fact a Ruby application.</p>
<p><a href="https://keithtenzer.files.wordpress.com/2015/08/ose_ruby_create_2.png"><img class="alignnone wp-image-1121" src="/assets/2015/08/ose_ruby_create_2.png?w=300" alt="OSE_RUBY_CREATE_2" width="1204" height="281" /></a></p>
<p>In the final step we can provide any custom details about the build configuration and of course add a label.</p>
<p><a href="https://keithtenzer.files.wordpress.com/2015/08/ose_ruby_create_3.png"><img class="alignnone wp-image-1122" src="/assets/2015/08/ose_ruby_create_3.png?w=300" alt="OSE_RUBY_CREATE_3" width="1205" height="791" /></a></p>
<p>OpenShift will create a container with Ruby 2.0 and our code from GitHub. It will also complete any required build steps. The end result is a complete application build, of a running application, inside a Docker container. Our application can now be automatically tested using Jenkins or other such continuous delivery tools. If tests pass, it can be automatically rolled out to production. Think about how much faster you can make code available to your customers with OpenShift? By selecting the URL for the Ruby hello world application we can also access the application directly.</p>
<p><a href="https://keithtenzer.files.wordpress.com/2015/08/ose_ruby_running.png"><img class="alignnone wp-image-1134" src="/assets/2015/08/ose_ruby_running.png?w=300" alt="OSE_RUBY_RUNNING" width="1201" height="821" /></a></p>
<p>&nbsp;</p>
<p><a href="https://keithtenzer.files.wordpress.com/2015/08/ose_ruby_app.png"><img class="alignnone wp-image-1123" src="/assets/2015/08/ose_ruby_app.png?w=300" alt="OSE_RUBY_APP" width="1214" height="267" /></a></p>
<h3>Troubleshooting</h3>
<p>In this section we will go through some basic troubleshooting steps for OpenShift v3. In order to get logs we first need the pod name. Using the "oc get pods" command, we can get a list of pods.</p>
<pre>#oc logs ruby-hello-world-1-65lgf
You might consider adding 'puma' into your Gemfile.
[2015-08-03 08:19:03] INFO WEBrick 1.3.1
[2015-08-03 08:19:03] INFO ruby 2.0.0 (2013-11-22) [x86_64-linux]
[2015-08-03 08:19:03] INFO WEBrick::HTTPServer#start: pid=1 port=8080
10.1.0.4 - - [03/Aug/2015 08:49:15] "GET / HTTP/1.1" 200 2496 0.0117
[2015-08-03 08:49:45] ERROR Errno::ECONNRESET: Connection reset by peer
 /opt/rh/ruby200/root/usr/share/ruby/webrick/httpserver.rb:80:in `eof?'
 /opt/rh/ruby200/root/usr/share/ruby/webrick/httpserver.rb:80:in `run'
 /opt/rh/ruby200/root/usr/share/ruby/webrick/server.rb:295:in `block in start_thread'</pre>
<p>Beyond looking at a pods logs we can also access journald for docker, openshift-master and openshift-node. Using the below journalctl commands we can get a list of current log messages for the major OpenShift components.</p>
<pre>#journalctl -f -l -u docker</pre>
<pre>#journalctl -f -l -u openshift-master</pre>
<pre>#journalctl -f -l -u openshift-node</pre>
<p><strong>Issue 1: Pod shows as pending and scheduled but never gets deployed on a node.</strong></p>
<p>This problem can occur if the node docker image cache gets out of sync. In order to resolve this issue perform the following steps on the node:</p>
<pre>#systemctl stop docker</pre>
<pre>#rm -rf /var/lib/docker/*</pre>
<pre>#reboot</pre>
<h3>Summary</h3>
<p>In this article we have seen how to deploy an OpenShift Enterprise v3 lab environment. We have seen how to use OpenShift in order to deploy and build applications. This is just the tip of the iceberg of course. In a world where speed and agility becomes increasingly important, it is clear that container infrastructure will become the future platform for running applications. You simply can't argue with being able to start 60 containers in the time it takes to start a single VM. Google deploys over two billion containers a week and everything you do from Google mail to search, runs in a container. Containers are enterprise ready and it is time to start understanding how to take advantage of this technology. OpenShift Enterprise v3 provides a platform for building and running applications on container infrastructure. OpenShift Enterprise v3 enables organizations to innovate faster, bringing that innovation to the market sooner. Don't let your organization be overtaken by the next startup! If you found this article informative or helpful please share your thoughts.</p>
<p>Happy OpenShifting!</p>
<p>(c) 2015 Keith Tenzer</p>
:ET