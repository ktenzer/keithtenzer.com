I"4<h3><img class="alignnone size-full wp-image-4020" src="/assets/2016/08/release-management.jpg" alt="3d small people - Males with four puzzle together" width="757" height="634" /></h3>
<p>source:Â <a href="http://snsoftwarelabs.com/">http://snsoftwarelabs.com/</a></p>
<h3>Overview</h3>
<p>One of the hardest things companies struggle with today is release management. Of course many methodologies and even more tools or technologies exist,Â but how do we bring everything together and work across functional boundaries of an organization?Â A product release involves everyone in the company not just a single team.Â Many companies struggle with this and the result is a much slower innovation cycle. In the past this used to be something that at least wasn't a deal breaker. Unfortunately that is no longer the case. Today companies live and die by their ability to not only innovate but release innovation. I would say innovating is the easy part, the ability to provide those innovations in aÂ controlled fashion throughÂ products and services is the real challenge.<br />
<!--more--><br />
Moving to micro-services architectures and container based technologies such as Docker have simplified or streamlined many technological aspects. Certainly at least providing light at the end of the tunnel, but until OpenShift there wasn't a platform to bring it all together, allowingÂ development and operations teams to work together while still maintaining their areas of focus or control. In this article we will look at three scenarios for handling application deployments within OpenShift that involve both operations and development. Each scenario builds on the other and should give you a good idea of the new possibilities with OpenShift. Also keep in mind, these are basic scenarios and we are just scratching the surface so this should be viewed as a starting point for doing application deployments or release management in the new containerized world.</p>
<h3>Scenario 1: Development leveraging customized image from Operations</h3>
<p>Typically operations teams will want to control application runtime environment. Ensure that the application runtime environment meets all security policies, provides needed capabilities and is updated on regular basis.</p>
<p>Development teams want to focus on innovation through application functionality, stability and capabilities.</p>
<p>OpenShift allows both teams to focus on their core responsibility while also providing a means to integrate inputs/outputs of various teams into a end-to-end release.</p>
<p>There are many ways to integrate DevOps teams in OpenShift. One simple way is by separating development and operations into different projects andÂ allowing development to their application runtime environment from operations. In this scenario we will see how to do that using a basic ruby hello-world application as example.</p>
<h4>Create Projects</h4>
<p>CreateÂ operations and development projects for our ruby application.</p>
<pre># oc login -u admin
# oc new-project ruby-ops
# oc new-project ruby-dev</pre>
<h4>SetupÂ Users</h4>
<p>Create a user for development and operations.</p>
<pre># htpasswd /etc/origin/master/htpasswd dev
# htpasswd /etc/origin/master/htpasswd ops</pre>
<p>Create ops and dev users</p>
<pre># htpasswd /etc/origin/master/htpasswd dev
#Â htpasswd /etc/origin/master/htpasswd ops</pre>
<p>Enable permissions.</p>
<p>Create three groups that allow operations to edit the ruby-ops project,Â allow development to view the ruby-ops project and alsoÂ edit the ruby-dev project. In addition the ruby-dev project needs permission to pull images from the ruby-ops project.</p>
<p>Create groups and add users to correct groups.</p>
<pre># oadm groups new ops-edit &amp;&amp; oadm groups new dev-view &amp;&amp; oadm groups new dev-edit
# oadm groups add-users ops-edit ops &amp;&amp; oadm groups add-users dev-view dev &amp;&amp; \
oadm groups add-users dev-edit dev</pre>
<p>Associate groups to projects and setup pull permissions to allow ruby-dev to pull images from ruby-ops.</p>
<pre># oadm policy add-role-to-group edit ops-edit -n ruby-ops &amp;&amp; \
# oadm policy add-role-to-group view dev-view -n ruby-ops &amp;&amp; \
# oadm policy add-role-to-group edit dev-edit -n ruby-dev &amp;&amp; \
# oadm policy add-role-to-group system:image-puller system:serviceaccounts:ruby-dev -n ruby-ops</pre>
<p><strong>Operations Ruby Environment</strong></p>
<p>As ops user create a ruby runtime image using application test code.</p>
<pre># oc login -u ops
# oc project ruby-ops
#Â oc new-app centos/ruby-22-centos7~https://github.com/openshift/ruby-hello-world.git</pre>
<p>Application requires database and service name called database.</p>
<pre># oc new-app mysql-ephemeral -p DATABASE_SERVICE_NAME=database
# oc env dc database --list | oc env dc ruby-hello-world -e -</pre>
<p><strong>Development Ruby Environment</strong></p>
<p>As dev user pull the operations ruby runtime image and build using latest code from different Github branch or project.</p>
<pre># oc login -u dev
# oc project ruby-dev
# oc new-app ruby-ops/ruby-22-centos7:latest~https://github.com/ktenzer/ruby-hello-world.git</pre>
<p>Application requires database and service name called database.</p>
<pre># oc new-app mysql-ephemeral -p DATABASE_SERVICE_NAME=database
# oc env dc database --list | oc env dc ruby-hello-world -e -</pre>
<h3>Scenario 2: Development to Production Promotion</h3>
<p>Once development has an application version with required functionality and having passed all tests it can be promoted to other environments. Typically that would be qa, test, integration and eventually production. In this simple example using the ticket-monster application we will promote directly from development to production.</p>
<p>Using similar concepts as describe in scenario 1 this technique relies on production pulling appropriate images from development. In this scenario however we will create deployment configs and within setup a trigger that when an image with particular name/tag is updated in development, promotion to production will occur automatically. Scenario 1 shows how to do this manually, here we do it automatically and in scenario 3 we will see how to do promotion using jenkins that enables building complex pipelines with approval processes.</p>
<p><strong>Create projects and setup pull permissions</strong></p>
<pre># oc new-project ticket-monster-dev
# oc new-project ticket-monster-prod
# oc policy add-role-to-group system:image-puller system:serviceaccounts:ticket-monster-prod -n ticket-monster-dev</pre>
<p><strong>Create ticket monster template for development</strong></p>
<pre># vi monster.yaml
kind: Template
apiVersion: v1
metadata:
 name: monster
 annotations:
 tags: instant-app,javaee
 iconClass: icon-jboss
 description: |
 Ticket Monster is a moderately complex application that demonstrates how
 to build modern applications using JBoss web technologies
</pre>
:ET