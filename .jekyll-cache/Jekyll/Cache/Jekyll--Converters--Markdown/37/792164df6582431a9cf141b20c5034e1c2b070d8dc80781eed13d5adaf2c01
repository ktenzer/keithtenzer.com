I"!<h2><img class="alignnone  wp-image-13605" src="/assets/2019/06/golang.png" alt="golang" width="195" height="195" /><img class="alignnone  wp-image-13608" src="/assets/2019/06/verticle.png" alt="verticle" width="155" height="157" /><img class="alignnone  wp-image-13609" src="/assets/2019/06/java-1.png" alt="java" width="119" height="225" /></h2>
<h2>Overview</h2>
<p>Java has been around a really, really long time. Certainly it continues to evolve and has evolved. Java has always been a "can do anything" programming language. It has more frameworks and middleware than there are stars in the sky. It is portable anywhere and of course probably 8 out of 10 developers today know Java to some degree. Given all of this though is Java the path forward?</p>
<p>Looking forward I think the clear trend is microservices and beyond. Therefore the question is a lot simpler, is Java the best path forward for microservices?</p>
<p><!--more--></p>
<h2>How Java Became #1</h2>
<p>Java was released in 1996. At that time the biggest issue was compiling code and porting. At this time there were many Unix, Linux, Windows flavors and many other variants. Open systems was the key initiative. Java came along and essentially offered instant portability. It created the JVM and runtime environment that would guarantee execution of code, regardless of platform, as long as there was a JRE. In one swoop, Java took away the problem of portability from developers, yay!</p>
<p>Another thing Java did was create a language that was much more readable, easier to learn and way more modular than anything that existed previously. It was not an accident Java became the #1 and has been for so long.</p>
<h2>However Java Got Fat...</h2>
<p>Just like with anything, if you are #1 you might get complacent and sit on the couch. As Java grew over the years, it got bigger and bigger and bigger. More framework, framework to manage framework, tools to manage tools, don't get me started with Gradle and Maven. It grew and grew into the can do anything language for everything. Often frameworks were used as a crutch, code as a result became sloppy, technical debt grew, scalability was not by design and then came cloud. Things started breaking, surprise.</p>
<p>Java has since, been trying to lose some weight, <a href="https://spring.io/projects/spring-boot">springboot </a>and other so-called lightweight frameworks came along. By lightweight we still mean overweight and slow from microservice perspective, just maybe not fat. Microservices did indeed change the game and possibly, could be the trigger that ends Java's reign.</p>
<h2>Microservices Change the Rules</h2>
<p>With the introduction of not only microservices, but also container platforms to run microservices, the rules have changed, just like in the 90s when Java was born, under the open systems initiative.</p>
<ul>
<li>Containers means compiling code and portability is no longer an issue. The value of a JVM is much less than it once was.</li>
<li>Startup times and time to load code is critical in microservices. If your code is slow to load it really hampers your options and presents a lot of challenges.</li>
<li>Microservices are mostly REST APIs that exchange data, asynchronous operations are key.</li>
<li>Microservices require scalability and scalability generally requires concurrency.</li>
<li>Languages that are compact, script-like, easy to write and read are preferred.</li>
<li>Languages with simple dependency management are ideal.</li>
</ul>
<p>At the time when Java was created none of these rules applied, it was developed to meet a totally different set of goals and challenges. Yet many Java developers go along on their merry way, trying to port their monoliths to microservices, using the same mentality that got them there? This just isn't logical. If the rules changed then clearly something else would be a wiser choice that adapts to the new game better?</p>
<p>Thankfully there are some interesting choices. One is <a href="https://golang.org">Golang </a>and the other could be <a href="https://quarkus.io/">Quarkus</a>. Both attempt to adhere to the new rules. Quarkus is native statically compiled Java and uses an ultra-fast JVM called Graal. It also has built-in frameworks for building microservices that help scale your code such as vertx. In this aspect it is similar to Golang. It is very lightweight and fast. I haven't seen comparison to Golang but it should be similar in this regard. Where things start to look different though is when we get into concurrency.</p>
<p>Doing concurrency and scalability in Java is really hard and Java allows you to write bad code, there is a lot of it. Quarkus has a much tighter opinion and narrow set of tooling so that should help steer developers better than its predecessor. Asynchronous programming is also not that easy in Java, again depends on frameworks but it isn't baked-in by any means. In Golang concurrency is a feature, it is built-in and that alone should get your attention. In addition Golang is a super modern language, easy to write, easy to read, no fluff and dependency management is not stabbing your eyes out with an ice pick.</p>
<p>Good old Java of course can still provide value and does in microservices, I am just saying it is likely not the best choice if you are starting from scratch. If I could sum it up I would say, look into Quarkus if the goal is porting Java app to microservice or building Java microservices and otherwise Golang. Of course there are many other languages as well, but none of them in my opinion apply to the challenges of today as well as Golang or Quarkus.</p>
<h2>Getting Started with Golang</h2>
<p>All the code examples are available in the following Github repository: <a href="https://github.com/ktenzer/go-hello-world">https://github.com/ktenzer/go-hello-world</a>.</p>
<h4>Setup your environment</h4>
<pre>$ vi ~/.bashrc
</pre>
:ET