<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
<link rel="icon" href="/assets/main/me.png">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Auto Scaling Instances with OpenStack - Keith Tenzer’s Blog</title>
<meta name="description" content="Overview Intelligently and automatically scaling applications based on resource requirements is at the heart of the OpenStack value proposition. It is one of the key capabilities that differentiate cloud vs traditional infrastructure such as VMware. For those of us who have been in IT a while auto scaling was always a white unicorn, often discussed but never actually seen. In this article we will talk about how to do this in OpenStack using Heat and Ceilometer.  Heat Orchestration and automation within OpenStack is handled by Heat. It is the brains of your cloud. Heat provides a declarative structure for defining IT processes using YAML. You could say the value of OpenStack is implemented by Heat as this is where your business processes exist. Heat will let you automatically provision infrastructure (compute, network and storage)  based on YAML templates. In addition Heat also lets you create policies around running infrastructure. One such policy is around auto scaling. Ceilometer Collecting and persisting utilization measurements within OpenStack is handled by Ceilometer. OpenStack attempts to handle IT infrastructure as a utility and as such metering is a critical aspect. Furthermore, enabling billing systems to provide pay-as-you-go consumption models, requires exact metering. Beyond billing, such metering is also key for auto scaling. Decisions made by Heat on when to scale applications, are based on data collected by Ceilometer. Auto Scaling Heat Templates A lot of the configuration information in this article comes from article written by Christian Berendt. In this auto scaling example, Heat and Ceilometer will be used to scale CPU bound virtual machines. Heat has the concept of a stack which is simply the environment itself. The Heat stack template describes the process or logic around how a Heat stack will be built and managed. This is where you can create an auto scaling group and configure Ceilometer thresholds. The environment template explains how to create the stack itself, what image or volume to use, network configuration, software to install and everything an instance or instances need to properly function. You can put everything into the Heat stack template, but separating the Heat stack template from the environment is much cleaner, at least in more complex configurations such as auto scaling. Environment Template Below we will create an environment template for a cirros image. The instance template will create an instance based on Cirros image, configure a cinder volume, add IP from private network, add floating IP from public network, add security group, private ssh-key and generate 100% CPU load through user-data. Note: you will need to make changes below depending on your OpenStack configuration. The OpenStack installation and configuration used for these examples can be found in this article. #vi /etc/heat/templates/cirros.yaml [code language=&quot;java&quot;] heat_template_version: 2014-10-16 description: A base Cirros 0.3.4 server resources:   server:     type: OS::Nova::Server     properties:       block_device_mapping:         - device_name: vda           delete_on_termination: true           volume_id: { get_resource: volume }       flavor: m1.nano       key_name: admin       networks:         - port: { get_resource: port }   port:     type: OS::Neutron::Port     properties:       network: private       security_groups:         - all   floating_ip:     type: OS::Neutron::FloatingIP     properties:       floating_network: public   floating_ip_assoc:     type: OS::Neutron::FloatingIPAssociation     properties:       floatingip_id: { get_resource: floating_ip }       port_id: { get_resource: port }   volume:     type: OS::Cinder::Volume     properties:       image: &#39;Cirros 0.3.4&#39;       size: 1 [/code] Now that we have an environment template, we need to create a Heat resource type and link it to above file /etc/heat/templates/cirros.yaml. #vi /root/environment.yaml [code language=&quot;java&quot;] resource_registry:     &quot;OS::Nova::Server::Cirros&quot;: &quot;file:///etc/heat/templates/cirros.yaml&quot; [/code] Stack Template Below we will define our Heat stack template. We will create the following resources: scaleup_group, scaleup_policy and cpu_alarm_high. The scaleup_group explains how the instance should be scaled and also defines the environment (OS::Nova::Server::Cirros) that points to the environment yaml file &quot;/etc/heat/templates/cirros.yaml&quot;. The scaleup_policy defines how to handle a scale-up event. Finally we have a threshold, the cpu_alarm_high resource is used to trigger a scale-up event. Here we define the threshold and actions provided by Ceilometer. #vi /root/example.yaml [code language=&quot;java&quot;] heat_template_version: 2014-10-16 description: Example auto scale group, policy and alarm resources:   scaleup_group:     type: OS::Heat::AutoScalingGroup     properties:       cooldown: 60       desired_capacity: 1       max_size: 3       min_size: 1       resource:         type: OS::Nova::Server::Cirros   scaleup_policy:     type: OS::Heat::ScalingPolicy     properties:       adjustment_type: change_in_capacity       auto_scaling_group_id: { get_resource: scaleup_group }       cooldown: 60       scaling_adjustment: 1   scaledown_policy:     type: OS::Heat::ScalingPolicy     properties:       adjustment_type: change_in_capacity       auto_scaling_group_id: { get_resource: scaleup_group }       cooldown: 60       scaling_adjustment: -1   cpu_alarm_high:     type: OS::Ceilometer::Alarm     properties:       meter_name: cpu_util       statistic: avg       period: 60       evaluation_periods: 1       threshold: 50       alarm_actions:         - {get_attr: [scaleup_policy, alarm_url]}       comparison_operator: gt   cpu_alarm_low:     type: OS::Ceilometer::Alarm     properties:       meter_name: cpu_util       statistic: avg       period: 60       evaluation_periods: 1       threshold: 10       alarm_actions:         - {get_attr: [scaledown_policy, alarm_url]}       comparison_operator: lt [/code] Update Ceilometer Collection Interval By default Ceilometer will collect CPU data from instances every 10 minutes. For this example we want to change that to 60 seconds. Change the interval to 60 in the pipeline.yaml file and restart OpenStack services. #vi /etc/ceilometer/pipeline.yaml [code language=&quot;java&quot;] - name: cpu_source interval: 60 meters: - &quot;cpu&quot; sinks: - cpu_sink [/code] #openstack-service restart Running Heat Stack At this point we are ready to run our auto scaling Heat stack. The expected results should be that a single Cirros instance is launched. It should have private and floating IPs. #heat stack-create example -f /root/example.yaml -e /root/environment.yaml  +--------------------------------------+------------+--------------------+----------------------+  | id | stack_name | stack_status | creation_time |  +--------------------------------------+------------+--------------------+----------------------+  | 6fca513c-25a1-4849-b7ab-909e37f52eca | example | CREATE_IN_PROGRESS | 2015-08-31T16:18:02Z |  +--------------------------------------+------------+--------------------+----------------------+ Heat will create the stack and launch the one cirros instance. #nova list  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | ID | Name | Status | Task State | Power State | Networks |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ Heat will also create two cpu alarms which are used to trigger scale-up or scale-down events. ceilometer alarm-list +--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+ | Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints | +--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+ | 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None | | ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | ok | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None | +--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+ Automatically Scaling Up Heat will scale instances up based on the cpu_alarm_high threshold. Once CPU utilization is above 50% instances will be scaled up. In order to generate CPU load, log into the instance and run the &quot;dd&quot; command. $ssh -i admin.pem cirros@192.168.122.232 $sudo -i #dd if=/dev/zero of=/dev/null &amp; #dd if=/dev/zero of=/dev/null &amp; #dd if=/dev/zero of=/dev/null &amp; Upon running &quot;dd&quot; commands we should have close to 100% CPU utilization in our cirros instance. After 60 seconds we should see that Heat has scaled and we have two instances. #ceilometer alarm-list +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ | Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints | +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ | 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None | | ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | alarm | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None | +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ #nova list  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | ID | Name | Status | Task State | Power State | Networks |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 |  | 0f69dfbe-4654-474f-9308-1b64de3f5c18 | ex-qeki-qmvor5rkptj7-krq7i66h6n7b-server-b4pk3dzjvbpi | ACTIVE | - | Running | private=10.10.1.157, 192.168.122.235 |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ After additional 60 seconds we should see that Heat has scaled again and we have three instances. Since three is the maximum for this configuration, we will not scale any higher. #nova list  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | ID | Name | Status | Task State | Power State | Networks |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 |  | 0e805e75-aa6f-4375-b057-2c173b68f172 | ex-qeki-gajdwmu2cgm2-vckf4g2gpwis-server-r3smbhtqij76 | ACTIVE | - | Running | private=10.10.1.158, 192.168.122.236 |  | 0f69dfbe-4654-474f-9308-1b64de3f5c18 | ex-qeki-qmvor5rkptj7-krq7i66h6n7b-server-b4pk3dzjvbpi | ACTIVE | - | Running | private=10.10.1.157, 192.168.122.235 |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ Automatically Scaling Down Heat will scale instances down based on the cpu_alarm_low threshold. Once CPU utilization is below 10% instances will be scaled down. We can simply kill the &quot;dd&quot; processes and watch Heat scale instances back down. After stopping &quot;&quot;dd&quot; processes we should see that the cpu_alarm_low event is triggered. This will cause Heat to scale down and remove instance. #ceilometer alarm-list +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ | Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints | +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ | 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None | | ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | alarm | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None | +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ After a few minutes we should be back to a single instance. Summary In this article we talked about how Heat and Ceilometer work together within OpenStack, providing the brains behind your cloud. We looked at a typical cloud use case around auto scaling and how to configure auto scaling through Heat. Hopefully you found this article informative. As always any feedback is greatly appreciated and as we say at Red Hat, sharing is caring. Happy Auto Scaling! (c) 2015 Keith Tenzer">


  <meta name="author" content="Keith Tenzer">
  
  <meta property="article:author" content="Keith Tenzer">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Keith Tenzer's Blog">
<meta property="og:title" content="Auto Scaling Instances with OpenStack">
<meta property="og:url" content="http://localhost:4000/openstack/auto-scaling-instances-with-openstack/">


  <meta property="og:description" content="Overview Intelligently and automatically scaling applications based on resource requirements is at the heart of the OpenStack value proposition. It is one of the key capabilities that differentiate cloud vs traditional infrastructure such as VMware. For those of us who have been in IT a while auto scaling was always a white unicorn, often discussed but never actually seen. In this article we will talk about how to do this in OpenStack using Heat and Ceilometer.  Heat Orchestration and automation within OpenStack is handled by Heat. It is the brains of your cloud. Heat provides a declarative structure for defining IT processes using YAML. You could say the value of OpenStack is implemented by Heat as this is where your business processes exist. Heat will let you automatically provision infrastructure (compute, network and storage)  based on YAML templates. In addition Heat also lets you create policies around running infrastructure. One such policy is around auto scaling. Ceilometer Collecting and persisting utilization measurements within OpenStack is handled by Ceilometer. OpenStack attempts to handle IT infrastructure as a utility and as such metering is a critical aspect. Furthermore, enabling billing systems to provide pay-as-you-go consumption models, requires exact metering. Beyond billing, such metering is also key for auto scaling. Decisions made by Heat on when to scale applications, are based on data collected by Ceilometer. Auto Scaling Heat Templates A lot of the configuration information in this article comes from article written by Christian Berendt. In this auto scaling example, Heat and Ceilometer will be used to scale CPU bound virtual machines. Heat has the concept of a stack which is simply the environment itself. The Heat stack template describes the process or logic around how a Heat stack will be built and managed. This is where you can create an auto scaling group and configure Ceilometer thresholds. The environment template explains how to create the stack itself, what image or volume to use, network configuration, software to install and everything an instance or instances need to properly function. You can put everything into the Heat stack template, but separating the Heat stack template from the environment is much cleaner, at least in more complex configurations such as auto scaling. Environment Template Below we will create an environment template for a cirros image. The instance template will create an instance based on Cirros image, configure a cinder volume, add IP from private network, add floating IP from public network, add security group, private ssh-key and generate 100% CPU load through user-data. Note: you will need to make changes below depending on your OpenStack configuration. The OpenStack installation and configuration used for these examples can be found in this article. #vi /etc/heat/templates/cirros.yaml [code language=&quot;java&quot;] heat_template_version: 2014-10-16 description: A base Cirros 0.3.4 server resources:   server:     type: OS::Nova::Server     properties:       block_device_mapping:         - device_name: vda           delete_on_termination: true           volume_id: { get_resource: volume }       flavor: m1.nano       key_name: admin       networks:         - port: { get_resource: port }   port:     type: OS::Neutron::Port     properties:       network: private       security_groups:         - all   floating_ip:     type: OS::Neutron::FloatingIP     properties:       floating_network: public   floating_ip_assoc:     type: OS::Neutron::FloatingIPAssociation     properties:       floatingip_id: { get_resource: floating_ip }       port_id: { get_resource: port }   volume:     type: OS::Cinder::Volume     properties:       image: &#39;Cirros 0.3.4&#39;       size: 1 [/code] Now that we have an environment template, we need to create a Heat resource type and link it to above file /etc/heat/templates/cirros.yaml. #vi /root/environment.yaml [code language=&quot;java&quot;] resource_registry:     &quot;OS::Nova::Server::Cirros&quot;: &quot;file:///etc/heat/templates/cirros.yaml&quot; [/code] Stack Template Below we will define our Heat stack template. We will create the following resources: scaleup_group, scaleup_policy and cpu_alarm_high. The scaleup_group explains how the instance should be scaled and also defines the environment (OS::Nova::Server::Cirros) that points to the environment yaml file &quot;/etc/heat/templates/cirros.yaml&quot;. The scaleup_policy defines how to handle a scale-up event. Finally we have a threshold, the cpu_alarm_high resource is used to trigger a scale-up event. Here we define the threshold and actions provided by Ceilometer. #vi /root/example.yaml [code language=&quot;java&quot;] heat_template_version: 2014-10-16 description: Example auto scale group, policy and alarm resources:   scaleup_group:     type: OS::Heat::AutoScalingGroup     properties:       cooldown: 60       desired_capacity: 1       max_size: 3       min_size: 1       resource:         type: OS::Nova::Server::Cirros   scaleup_policy:     type: OS::Heat::ScalingPolicy     properties:       adjustment_type: change_in_capacity       auto_scaling_group_id: { get_resource: scaleup_group }       cooldown: 60       scaling_adjustment: 1   scaledown_policy:     type: OS::Heat::ScalingPolicy     properties:       adjustment_type: change_in_capacity       auto_scaling_group_id: { get_resource: scaleup_group }       cooldown: 60       scaling_adjustment: -1   cpu_alarm_high:     type: OS::Ceilometer::Alarm     properties:       meter_name: cpu_util       statistic: avg       period: 60       evaluation_periods: 1       threshold: 50       alarm_actions:         - {get_attr: [scaleup_policy, alarm_url]}       comparison_operator: gt   cpu_alarm_low:     type: OS::Ceilometer::Alarm     properties:       meter_name: cpu_util       statistic: avg       period: 60       evaluation_periods: 1       threshold: 10       alarm_actions:         - {get_attr: [scaledown_policy, alarm_url]}       comparison_operator: lt [/code] Update Ceilometer Collection Interval By default Ceilometer will collect CPU data from instances every 10 minutes. For this example we want to change that to 60 seconds. Change the interval to 60 in the pipeline.yaml file and restart OpenStack services. #vi /etc/ceilometer/pipeline.yaml [code language=&quot;java&quot;] - name: cpu_source interval: 60 meters: - &quot;cpu&quot; sinks: - cpu_sink [/code] #openstack-service restart Running Heat Stack At this point we are ready to run our auto scaling Heat stack. The expected results should be that a single Cirros instance is launched. It should have private and floating IPs. #heat stack-create example -f /root/example.yaml -e /root/environment.yaml  +--------------------------------------+------------+--------------------+----------------------+  | id | stack_name | stack_status | creation_time |  +--------------------------------------+------------+--------------------+----------------------+  | 6fca513c-25a1-4849-b7ab-909e37f52eca | example | CREATE_IN_PROGRESS | 2015-08-31T16:18:02Z |  +--------------------------------------+------------+--------------------+----------------------+ Heat will create the stack and launch the one cirros instance. #nova list  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | ID | Name | Status | Task State | Power State | Networks |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ Heat will also create two cpu alarms which are used to trigger scale-up or scale-down events. ceilometer alarm-list +--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+ | Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints | +--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+ | 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None | | ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | ok | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None | +--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+ Automatically Scaling Up Heat will scale instances up based on the cpu_alarm_high threshold. Once CPU utilization is above 50% instances will be scaled up. In order to generate CPU load, log into the instance and run the &quot;dd&quot; command. $ssh -i admin.pem cirros@192.168.122.232 $sudo -i #dd if=/dev/zero of=/dev/null &amp; #dd if=/dev/zero of=/dev/null &amp; #dd if=/dev/zero of=/dev/null &amp; Upon running &quot;dd&quot; commands we should have close to 100% CPU utilization in our cirros instance. After 60 seconds we should see that Heat has scaled and we have two instances. #ceilometer alarm-list +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ | Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints | +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ | 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None | | ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | alarm | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None | +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ #nova list  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | ID | Name | Status | Task State | Power State | Networks |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 |  | 0f69dfbe-4654-474f-9308-1b64de3f5c18 | ex-qeki-qmvor5rkptj7-krq7i66h6n7b-server-b4pk3dzjvbpi | ACTIVE | - | Running | private=10.10.1.157, 192.168.122.235 |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ After additional 60 seconds we should see that Heat has scaled again and we have three instances. Since three is the maximum for this configuration, we will not scale any higher. #nova list  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | ID | Name | Status | Task State | Power State | Networks |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 |  | 0e805e75-aa6f-4375-b057-2c173b68f172 | ex-qeki-gajdwmu2cgm2-vckf4g2gpwis-server-r3smbhtqij76 | ACTIVE | - | Running | private=10.10.1.158, 192.168.122.236 |  | 0f69dfbe-4654-474f-9308-1b64de3f5c18 | ex-qeki-qmvor5rkptj7-krq7i66h6n7b-server-b4pk3dzjvbpi | ACTIVE | - | Running | private=10.10.1.157, 192.168.122.235 |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ Automatically Scaling Down Heat will scale instances down based on the cpu_alarm_low threshold. Once CPU utilization is below 10% instances will be scaled down. We can simply kill the &quot;dd&quot; processes and watch Heat scale instances back down. After stopping &quot;&quot;dd&quot; processes we should see that the cpu_alarm_low event is triggered. This will cause Heat to scale down and remove instance. #ceilometer alarm-list +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ | Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints | +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ | 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None | | ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | alarm | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None | +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ After a few minutes we should be back to a single instance. Summary In this article we talked about how Heat and Ceilometer work together within OpenStack, providing the brains behind your cloud. We looked at a typical cloud use case around auto scaling and how to configure auto scaling through Heat. Hopefully you found this article informative. As always any feedback is greatly appreciated and as we say at Red Hat, sharing is caring. Happy Auto Scaling! (c) 2015 Keith Tenzer">





  <meta name="twitter:site" content="@keithtenzer">
  <meta name="twitter:title" content="Auto Scaling Instances with OpenStack">
  <meta name="twitter:description" content="Overview Intelligently and automatically scaling applications based on resource requirements is at the heart of the OpenStack value proposition. It is one of the key capabilities that differentiate cloud vs traditional infrastructure such as VMware. For those of us who have been in IT a while auto scaling was always a white unicorn, often discussed but never actually seen. In this article we will talk about how to do this in OpenStack using Heat and Ceilometer.  Heat Orchestration and automation within OpenStack is handled by Heat. It is the brains of your cloud. Heat provides a declarative structure for defining IT processes using YAML. You could say the value of OpenStack is implemented by Heat as this is where your business processes exist. Heat will let you automatically provision infrastructure (compute, network and storage)  based on YAML templates. In addition Heat also lets you create policies around running infrastructure. One such policy is around auto scaling. Ceilometer Collecting and persisting utilization measurements within OpenStack is handled by Ceilometer. OpenStack attempts to handle IT infrastructure as a utility and as such metering is a critical aspect. Furthermore, enabling billing systems to provide pay-as-you-go consumption models, requires exact metering. Beyond billing, such metering is also key for auto scaling. Decisions made by Heat on when to scale applications, are based on data collected by Ceilometer. Auto Scaling Heat Templates A lot of the configuration information in this article comes from article written by Christian Berendt. In this auto scaling example, Heat and Ceilometer will be used to scale CPU bound virtual machines. Heat has the concept of a stack which is simply the environment itself. The Heat stack template describes the process or logic around how a Heat stack will be built and managed. This is where you can create an auto scaling group and configure Ceilometer thresholds. The environment template explains how to create the stack itself, what image or volume to use, network configuration, software to install and everything an instance or instances need to properly function. You can put everything into the Heat stack template, but separating the Heat stack template from the environment is much cleaner, at least in more complex configurations such as auto scaling. Environment Template Below we will create an environment template for a cirros image. The instance template will create an instance based on Cirros image, configure a cinder volume, add IP from private network, add floating IP from public network, add security group, private ssh-key and generate 100% CPU load through user-data. Note: you will need to make changes below depending on your OpenStack configuration. The OpenStack installation and configuration used for these examples can be found in this article. #vi /etc/heat/templates/cirros.yaml [code language=&quot;java&quot;] heat_template_version: 2014-10-16 description: A base Cirros 0.3.4 server resources:   server:     type: OS::Nova::Server     properties:       block_device_mapping:         - device_name: vda           delete_on_termination: true           volume_id: { get_resource: volume }       flavor: m1.nano       key_name: admin       networks:         - port: { get_resource: port }   port:     type: OS::Neutron::Port     properties:       network: private       security_groups:         - all   floating_ip:     type: OS::Neutron::FloatingIP     properties:       floating_network: public   floating_ip_assoc:     type: OS::Neutron::FloatingIPAssociation     properties:       floatingip_id: { get_resource: floating_ip }       port_id: { get_resource: port }   volume:     type: OS::Cinder::Volume     properties:       image: &#39;Cirros 0.3.4&#39;       size: 1 [/code] Now that we have an environment template, we need to create a Heat resource type and link it to above file /etc/heat/templates/cirros.yaml. #vi /root/environment.yaml [code language=&quot;java&quot;] resource_registry:     &quot;OS::Nova::Server::Cirros&quot;: &quot;file:///etc/heat/templates/cirros.yaml&quot; [/code] Stack Template Below we will define our Heat stack template. We will create the following resources: scaleup_group, scaleup_policy and cpu_alarm_high. The scaleup_group explains how the instance should be scaled and also defines the environment (OS::Nova::Server::Cirros) that points to the environment yaml file &quot;/etc/heat/templates/cirros.yaml&quot;. The scaleup_policy defines how to handle a scale-up event. Finally we have a threshold, the cpu_alarm_high resource is used to trigger a scale-up event. Here we define the threshold and actions provided by Ceilometer. #vi /root/example.yaml [code language=&quot;java&quot;] heat_template_version: 2014-10-16 description: Example auto scale group, policy and alarm resources:   scaleup_group:     type: OS::Heat::AutoScalingGroup     properties:       cooldown: 60       desired_capacity: 1       max_size: 3       min_size: 1       resource:         type: OS::Nova::Server::Cirros   scaleup_policy:     type: OS::Heat::ScalingPolicy     properties:       adjustment_type: change_in_capacity       auto_scaling_group_id: { get_resource: scaleup_group }       cooldown: 60       scaling_adjustment: 1   scaledown_policy:     type: OS::Heat::ScalingPolicy     properties:       adjustment_type: change_in_capacity       auto_scaling_group_id: { get_resource: scaleup_group }       cooldown: 60       scaling_adjustment: -1   cpu_alarm_high:     type: OS::Ceilometer::Alarm     properties:       meter_name: cpu_util       statistic: avg       period: 60       evaluation_periods: 1       threshold: 50       alarm_actions:         - {get_attr: [scaleup_policy, alarm_url]}       comparison_operator: gt   cpu_alarm_low:     type: OS::Ceilometer::Alarm     properties:       meter_name: cpu_util       statistic: avg       period: 60       evaluation_periods: 1       threshold: 10       alarm_actions:         - {get_attr: [scaledown_policy, alarm_url]}       comparison_operator: lt [/code] Update Ceilometer Collection Interval By default Ceilometer will collect CPU data from instances every 10 minutes. For this example we want to change that to 60 seconds. Change the interval to 60 in the pipeline.yaml file and restart OpenStack services. #vi /etc/ceilometer/pipeline.yaml [code language=&quot;java&quot;] - name: cpu_source interval: 60 meters: - &quot;cpu&quot; sinks: - cpu_sink [/code] #openstack-service restart Running Heat Stack At this point we are ready to run our auto scaling Heat stack. The expected results should be that a single Cirros instance is launched. It should have private and floating IPs. #heat stack-create example -f /root/example.yaml -e /root/environment.yaml  +--------------------------------------+------------+--------------------+----------------------+  | id | stack_name | stack_status | creation_time |  +--------------------------------------+------------+--------------------+----------------------+  | 6fca513c-25a1-4849-b7ab-909e37f52eca | example | CREATE_IN_PROGRESS | 2015-08-31T16:18:02Z |  +--------------------------------------+------------+--------------------+----------------------+ Heat will create the stack and launch the one cirros instance. #nova list  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | ID | Name | Status | Task State | Power State | Networks |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ Heat will also create two cpu alarms which are used to trigger scale-up or scale-down events. ceilometer alarm-list +--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+ | Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints | +--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+ | 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None | | ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | ok | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None | +--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+ Automatically Scaling Up Heat will scale instances up based on the cpu_alarm_high threshold. Once CPU utilization is above 50% instances will be scaled up. In order to generate CPU load, log into the instance and run the &quot;dd&quot; command. $ssh -i admin.pem cirros@192.168.122.232 $sudo -i #dd if=/dev/zero of=/dev/null &amp; #dd if=/dev/zero of=/dev/null &amp; #dd if=/dev/zero of=/dev/null &amp; Upon running &quot;dd&quot; commands we should have close to 100% CPU utilization in our cirros instance. After 60 seconds we should see that Heat has scaled and we have two instances. #ceilometer alarm-list +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ | Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints | +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ | 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None | | ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | alarm | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None | +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ #nova list  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | ID | Name | Status | Task State | Power State | Networks |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 |  | 0f69dfbe-4654-474f-9308-1b64de3f5c18 | ex-qeki-qmvor5rkptj7-krq7i66h6n7b-server-b4pk3dzjvbpi | ACTIVE | - | Running | private=10.10.1.157, 192.168.122.235 |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ After additional 60 seconds we should see that Heat has scaled again and we have three instances. Since three is the maximum for this configuration, we will not scale any higher. #nova list  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | ID | Name | Status | Task State | Power State | Networks |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+  | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 |  | 0e805e75-aa6f-4375-b057-2c173b68f172 | ex-qeki-gajdwmu2cgm2-vckf4g2gpwis-server-r3smbhtqij76 | ACTIVE | - | Running | private=10.10.1.158, 192.168.122.236 |  | 0f69dfbe-4654-474f-9308-1b64de3f5c18 | ex-qeki-qmvor5rkptj7-krq7i66h6n7b-server-b4pk3dzjvbpi | ACTIVE | - | Running | private=10.10.1.157, 192.168.122.235 |  +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ Automatically Scaling Down Heat will scale instances down based on the cpu_alarm_low threshold. Once CPU utilization is below 10% instances will be scaled down. We can simply kill the &quot;dd&quot; processes and watch Heat scale instances back down. After stopping &quot;&quot;dd&quot; processes we should see that the cpu_alarm_low event is triggered. This will cause Heat to scale down and remove instance. #ceilometer alarm-list +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ | Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints | +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ | 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None | | ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | alarm | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None | +--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+ After a few minutes we should be back to a single instance. Summary In this article we talked about how Heat and Ceilometer work together within OpenStack, providing the brains behind your cloud. We looked at a typical cloud use case around auto scaling and how to configure auto scaling through Heat. Hopefully you found this article informative. As always any feedback is greatly appreciated and as we say at Red Hat, sharing is caring. Happy Auto Scaling! (c) 2015 Keith Tenzer">
  <meta name="twitter:url" content="http://localhost:4000/openstack/auto-scaling-instances-with-openstack/">

  
    <meta name="twitter:card" content="summary">
    
  

  



  <meta property="article:published_time" content="2015-09-02T00:00:00-07:00">





  

  


<link rel="canonical" href="http://localhost:4000/openstack/auto-scaling-instances-with-openstack/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Keith Tenzer",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Keith Tenzer's Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Keith Tenzer's Blog
          <span class="site-subtitle">Cloud Computing and Code</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/about/index.html">About</a>
            </li><li class="masthead__menu-item">
              <a href="/conferences-and-events/index.html">Conferences and Events</a>
            </li><li class="masthead__menu-item">
              <a href="/videos/index.html">Videos</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="http://localhost:4000/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#openstack" itemprop="item"><span itemprop="name">Openstack</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        <li class="current">Auto Scaling Instances with OpenStack</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/main/me.png" alt="Keith Tenzer" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Keith Tenzer</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Principal Solutions Architect at Red Hat</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Los Angeles, CA</span>
        </li>
      

      
        
          
        
          
        
          
            <li><a href="https://twitter.com/keithtenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span></a></li>
          
        
          
        
          
            <li><a href="https://github.com/ktenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Auto Scaling Instances with OpenStack">
    <meta itemprop="description" content="OverviewIntelligently and automatically scaling applications based on resource requirements is at the heart of the OpenStack value proposition. It is one of the key capabilities that differentiate cloud vs traditional infrastructure such as VMware. For those of us who have been in IT a while auto scaling was always a white unicorn, often discussed but never actually seen. In this article we will talk about how to do this in OpenStack using Heat and Ceilometer.HeatOrchestration and automation within OpenStack is handled by Heat. It is the brains of your cloud. Heat provides a declarative structure for defining IT processes using YAML. You could say the value of OpenStack is implemented by Heat as this is where your business processes exist. Heat will let you automatically provision infrastructure (compute, network and storage)  based on YAML templates. In addition Heat also lets you create policies around running infrastructure. One such policy is around auto scaling.CeilometerCollecting and persisting utilization measurements within OpenStack is handled by Ceilometer. OpenStack attempts to handle IT infrastructure as a utility and as such metering is a critical aspect. Furthermore, enabling billing systems to provide pay-as-you-go consumption models, requires exact metering. Beyond billing, such metering is also key for auto scaling. Decisions made by Heat on when to scale applications, are based on data collected by Ceilometer.Auto Scaling Heat TemplatesA lot of the configuration information in this article comes from article written by Christian Berendt. In this auto scaling example, Heat and Ceilometer will be used to scale CPU bound virtual machines. Heat has the concept of a stack which is simply the environment itself. The Heat stack template describes the process or logic around how a Heat stack will be built and managed. This is where you can create an auto scaling group and configure Ceilometer thresholds. The environment template explains how to create the stack itself, what image or volume to use, network configuration, software to install and everything an instance or instances need to properly function. You can put everything into the Heat stack template, but separating the Heat stack template from the environment is much cleaner, at least in more complex configurations such as auto scaling.Environment TemplateBelow we will create an environment template for a cirros image. The instance template will create an instance based on Cirros image, configure a cinder volume, add IP from private network, add floating IP from public network, add security group, private ssh-key and generate 100% CPU load through user-data. Note: you will need to make changes below depending on your OpenStack configuration. The OpenStack installation and configuration used for these examples can be found in this article.#vi /etc/heat/templates/cirros.yaml[code language=&quot;java&quot;]heat_template_version: 2014-10-16description: A base Cirros 0.3.4 serverresources:  server:    type: OS::Nova::Server    properties:      block_device_mapping:        - device_name: vda          delete_on_termination: true          volume_id: { get_resource: volume }      flavor: m1.nano      key_name: admin      networks:        - port: { get_resource: port }  port:    type: OS::Neutron::Port    properties:      network: private      security_groups:        - all  floating_ip:    type: OS::Neutron::FloatingIP    properties:      floating_network: public  floating_ip_assoc:    type: OS::Neutron::FloatingIPAssociation    properties:      floatingip_id: { get_resource: floating_ip }      port_id: { get_resource: port }  volume:    type: OS::Cinder::Volume    properties:      image: &#39;Cirros 0.3.4&#39;      size: 1[/code]Now that we have an environment template, we need to create a Heat resource type and link it to above file /etc/heat/templates/cirros.yaml.#vi /root/environment.yaml[code language=&quot;java&quot;]resource_registry:    &quot;OS::Nova::Server::Cirros&quot;: &quot;file:///etc/heat/templates/cirros.yaml&quot;[/code]Stack TemplateBelow we will define our Heat stack template. We will create the following resources: scaleup_group, scaleup_policy and cpu_alarm_high. The scaleup_group explains how the instance should be scaled and also defines the environment (OS::Nova::Server::Cirros) that points to the environment yaml file &quot;/etc/heat/templates/cirros.yaml&quot;. The scaleup_policy defines how to handle a scale-up event. Finally we have a threshold, the cpu_alarm_high resource is used to trigger a scale-up event. Here we define the threshold and actions provided by Ceilometer.#vi /root/example.yaml[code language=&quot;java&quot;]heat_template_version: 2014-10-16description: Example auto scale group, policy and alarmresources:  scaleup_group:    type: OS::Heat::AutoScalingGroup    properties:      cooldown: 60      desired_capacity: 1      max_size: 3      min_size: 1      resource:        type: OS::Nova::Server::Cirros  scaleup_policy:    type: OS::Heat::ScalingPolicy    properties:      adjustment_type: change_in_capacity      auto_scaling_group_id: { get_resource: scaleup_group }      cooldown: 60      scaling_adjustment: 1  scaledown_policy:    type: OS::Heat::ScalingPolicy    properties:      adjustment_type: change_in_capacity      auto_scaling_group_id: { get_resource: scaleup_group }      cooldown: 60      scaling_adjustment: -1  cpu_alarm_high:    type: OS::Ceilometer::Alarm    properties:      meter_name: cpu_util      statistic: avg      period: 60      evaluation_periods: 1      threshold: 50      alarm_actions:        - {get_attr: [scaleup_policy, alarm_url]}      comparison_operator: gt  cpu_alarm_low:    type: OS::Ceilometer::Alarm    properties:      meter_name: cpu_util      statistic: avg      period: 60      evaluation_periods: 1      threshold: 10      alarm_actions:        - {get_attr: [scaledown_policy, alarm_url]}      comparison_operator: lt[/code]Update Ceilometer Collection IntervalBy default Ceilometer will collect CPU data from instances every 10 minutes. For this example we want to change that to 60 seconds. Change the interval to 60 in the pipeline.yaml file and restart OpenStack services.#vi /etc/ceilometer/pipeline.yaml[code language=&quot;java&quot;]- name: cpu_sourceinterval: 60meters:- &quot;cpu&quot;sinks:- cpu_sink[/code]#openstack-service restartRunning Heat StackAt this point we are ready to run our auto scaling Heat stack. The expected results should be that a single Cirros instance is launched. It should have private and floating IPs.#heat stack-create example -f /root/example.yaml -e /root/environment.yaml +--------------------------------------+------------+--------------------+----------------------+ | id | stack_name | stack_status | creation_time | +--------------------------------------+------------+--------------------+----------------------+ | 6fca513c-25a1-4849-b7ab-909e37f52eca | example | CREATE_IN_PROGRESS | 2015-08-31T16:18:02Z | +--------------------------------------+------------+--------------------+----------------------+Heat will create the stack and launch the one cirros instance.#nova list +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ | ID | Name | Status | Task State | Power State | Networks | +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 | +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+Heat will also create two cpu alarms which are used to trigger scale-up or scale-down events.ceilometer alarm-list+--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+| Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints |+--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+| 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None || ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | ok | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None |+--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+Automatically Scaling UpHeat will scale instances up based on the cpu_alarm_high threshold. Once CPU utilization is above 50% instances will be scaled up. In order to generate CPU load, log into the instance and run the &quot;dd&quot; command.$ssh -i admin.pem cirros@192.168.122.232$sudo -i#dd if=/dev/zero of=/dev/null &amp;#dd if=/dev/zero of=/dev/null &amp;#dd if=/dev/zero of=/dev/null &amp;Upon running &quot;dd&quot; commands we should have close to 100% CPU utilization in our cirros instance. After 60 seconds we should see that Heat has scaled and we have two instances.#ceilometer alarm-list+--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+| Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints |+--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+| 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None || ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | alarm | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None |+--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+#nova list +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ | ID | Name | Status | Task State | Power State | Networks | +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 | | 0f69dfbe-4654-474f-9308-1b64de3f5c18 | ex-qeki-qmvor5rkptj7-krq7i66h6n7b-server-b4pk3dzjvbpi | ACTIVE | - | Running | private=10.10.1.157, 192.168.122.235 | +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+After additional 60 seconds we should see that Heat has scaled again and we have three instances. Since three is the maximum for this configuration, we will not scale any higher.#nova list +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ | ID | Name | Status | Task State | Power State | Networks | +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+ | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 | | 0e805e75-aa6f-4375-b057-2c173b68f172 | ex-qeki-gajdwmu2cgm2-vckf4g2gpwis-server-r3smbhtqij76 | ACTIVE | - | Running | private=10.10.1.158, 192.168.122.236 | | 0f69dfbe-4654-474f-9308-1b64de3f5c18 | ex-qeki-qmvor5rkptj7-krq7i66h6n7b-server-b4pk3dzjvbpi | ACTIVE | - | Running | private=10.10.1.157, 192.168.122.235 | +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+Automatically Scaling DownHeat will scale instances down based on the cpu_alarm_low threshold. Once CPU utilization is below 10% instances will be scaled down. We can simply kill the &quot;dd&quot; processes and watch Heat scale instances back down.After stopping &quot;&quot;dd&quot; processes we should see that the cpu_alarm_low event is triggered. This will cause Heat to scale down and remove instance.#ceilometer alarm-list+--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+| Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints |+--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+| 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None || ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | alarm | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None |+--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+After a few minutes we should be back to a single instance.SummaryIn this article we talked about how Heat and Ceilometer work together within OpenStack, providing the brains behind your cloud. We looked at a typical cloud use case around auto scaling and how to configure auto scaling through Heat. Hopefully you found this article informative. As always any feedback is greatly appreciated and as we say at Red Hat, sharing is caring.Happy Auto Scaling!(c) 2015 Keith Tenzer">
    <meta itemprop="datePublished" content="2015-09-02T00:00:00-07:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Auto Scaling Instances with OpenStack
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2015-09-02T00:00:00-07:00">September 2, 2015</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          14 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
        <h3><a href="https://keithtenzer.files.wordpress.com/2015/09/scale.png"><img class="alignnone size-full wp-image-1222" src="/assets/2015/09/scale.png" alt="scale" width="288" height="175" /></a></h3>
<h3>Overview</h3>
<p>Intelligently and automatically scaling applications based on resource requirements is at the heart of the OpenStack value proposition. It is one of the key capabilities that differentiate cloud vs traditional infrastructure such as VMware. For those of us who have been in IT a while auto scaling was always a white unicorn, often discussed but never actually seen. In this article we will talk about how to do this in OpenStack using Heat and Ceilometer.<br />
<!--more--></p>
<h3>Heat</h3>
<p>Orchestration and automation within OpenStack is handled by Heat. It is the brains of your cloud. Heat provides a declarative structure for defining IT processes using YAML. You could say the value of OpenStack is implemented by Heat as this is where your business processes exist. Heat will let you automatically provision infrastructure (compute, network and storage)  based on YAML templates. In addition Heat also lets you create policies around running infrastructure. One such policy is around auto scaling.</p>
<h3>Ceilometer</h3>
<p>Collecting and persisting utilization measurements within OpenStack is handled by Ceilometer. OpenStack attempts to handle IT infrastructure as a utility and as such metering is a critical aspect. Furthermore, enabling billing systems to provide pay-as-you-go consumption models, requires exact metering. Beyond billing, such metering is also key for auto scaling. Decisions made by Heat on when to scale applications, are based on data collected by Ceilometer.</p>
<h3>Auto Scaling Heat Templates</h3>
<p>A lot of the configuration information in this article comes from article written by <a href="https://blog.berendt.io/simple-auto-scaling-environment-with-heat/https://blog.berendt.io/simple-auto-scaling-environment-with-heat/">Christian Berendt</a>. In this auto scaling example, Heat and Ceilometer will be used to scale CPU bound virtual machines. Heat has the concept of a stack which is simply the environment itself. The Heat stack template describes the process or logic around how a Heat stack will be built and managed. This is where you can create an auto scaling group and configure Ceilometer thresholds. The environment template explains how to create the stack itself, what image or volume to use, network configuration, software to install and everything an instance or instances need to properly function. You can put everything into the Heat stack template, but separating the Heat stack template from the environment is much cleaner, at least in more complex configurations such as auto scaling.</p>
<h4>Environment Template</h4>
<p>Below we will create an environment template for a cirros image. The instance template will create an instance based on Cirros image, configure a cinder volume, add IP from private network, add floating IP from public network, add security group, private ssh-key and generate 100% CPU load through user-data. Note: you will need to make changes below depending on your OpenStack configuration. The OpenStack installation and configuration used for these examples can be found in this <a href="http://keithtenzer.com/2015/09/01/openstack-kilo-lab-installation-and-configuration-guide/">article</a>.</p>
<pre style="padding-left:30px;">#vi /etc/heat/templates/cirros.yaml</pre>
<p>[code language="java"]</p>
<p>heat_template_version: 2014-10-16<br />
description: A base Cirros 0.3.4 server</p>
<p>resources:<br />
  server:<br />
    type: OS::Nova::Server<br />
    properties:<br />
      block_device_mapping:<br />
        - device_name: vda<br />
          delete_on_termination: true<br />
          volume_id: { get_resource: volume }<br />
      flavor: m1.nano<br />
      key_name: admin<br />
      networks:<br />
        - port: { get_resource: port }</p>
<p>  port:<br />
    type: OS::Neutron::Port<br />
    properties:<br />
      network: private<br />
      security_groups:<br />
        - all</p>
<p>  floating_ip:<br />
    type: OS::Neutron::FloatingIP<br />
    properties:<br />
      floating_network: public</p>
<p>  floating_ip_assoc:<br />
    type: OS::Neutron::FloatingIPAssociation<br />
    properties:<br />
      floatingip_id: { get_resource: floating_ip }<br />
      port_id: { get_resource: port }</p>
<p>  volume:<br />
    type: OS::Cinder::Volume<br />
    properties:<br />
      image: 'Cirros 0.3.4'<br />
      size: 1</p>
<p>[/code]</p>
<p>Now that we have an environment template, we need to create a Heat resource type and link it to above file /etc/heat/templates/cirros.yaml.</p>
<pre style="padding-left:30px;">#vi /root/environment.yaml</pre>
<p>[code language="java"]</p>
<p>resource_registry:</p>
<p>    &quot;OS::Nova::Server::Cirros&quot;: &quot;file:///etc/heat/templates/cirros.yaml&quot;</p>
<p>[/code]</p>
<h4>Stack Template</h4>
<p>Below we will define our Heat stack template. We will create the following resources: scaleup_group, scaleup_policy and cpu_alarm_high. The scaleup_group explains how the instance should be scaled and also defines the environment (OS::Nova::Server::Cirros) that points to the environment yaml file "/etc/heat/templates/cirros.yaml". The scaleup_policy defines how to handle a scale-up event. Finally we have a threshold, the cpu_alarm_high resource is used to trigger a scale-up event. Here we define the threshold and actions provided by Ceilometer.</p>
<pre style="padding-left:30px;">#vi /root/example.yaml</pre>
<p>[code language="java"]</p>
<p>heat_template_version: 2014-10-16<br />
description: Example auto scale group, policy and alarm<br />
resources:<br />
  scaleup_group:<br />
    type: OS::Heat::AutoScalingGroup<br />
    properties:<br />
      cooldown: 60<br />
      desired_capacity: 1<br />
      max_size: 3<br />
      min_size: 1<br />
      resource:<br />
        type: OS::Nova::Server::Cirros</p>
<p>  scaleup_policy:<br />
    type: OS::Heat::ScalingPolicy<br />
    properties:<br />
      adjustment_type: change_in_capacity<br />
      auto_scaling_group_id: { get_resource: scaleup_group }<br />
      cooldown: 60<br />
      scaling_adjustment: 1</p>
<p>  scaledown_policy:<br />
    type: OS::Heat::ScalingPolicy<br />
    properties:<br />
      adjustment_type: change_in_capacity<br />
      auto_scaling_group_id: { get_resource: scaleup_group }<br />
      cooldown: 60<br />
      scaling_adjustment: -1</p>
<p>  cpu_alarm_high:<br />
    type: OS::Ceilometer::Alarm<br />
    properties:<br />
      meter_name: cpu_util<br />
      statistic: avg<br />
      period: 60<br />
      evaluation_periods: 1<br />
      threshold: 50<br />
      alarm_actions:<br />
        - {get_attr: [scaleup_policy, alarm_url]}<br />
      comparison_operator: gt</p>
<p>  cpu_alarm_low:<br />
    type: OS::Ceilometer::Alarm<br />
    properties:<br />
      meter_name: cpu_util<br />
      statistic: avg<br />
      period: 60<br />
      evaluation_periods: 1<br />
      threshold: 10<br />
      alarm_actions:<br />
        - {get_attr: [scaledown_policy, alarm_url]}<br />
      comparison_operator: lt<br />
[/code]</p>
<h3>Update Ceilometer Collection Interval</h3>
<p>By default Ceilometer will collect CPU data from instances every 10 minutes. For this example we want to change that to 60 seconds. Change the interval to 60 in the pipeline.yaml file and restart OpenStack services.</p>
<pre style="padding-left:30px;">#vi /etc/ceilometer/pipeline.yaml</pre>
<p>[code language="java"]</p>
<p>- name: cpu_source<br />
interval: 60<br />
meters:<br />
- &quot;cpu&quot;<br />
sinks:<br />
- cpu_sink</p>
<p>[/code]</p>
<pre style="padding-left:30px;">#openstack-service restart</pre>
<h3>Running Heat Stack</h3>
<p>At this point we are ready to run our auto scaling Heat stack. The expected results should be that a single Cirros instance is launched. It should have private and floating IPs.</p>
<pre style="padding-left:30px;">#heat stack-create example -f /root/example.yaml -e /root/environment.yaml
 +--------------------------------------+------------+--------------------+----------------------+
 | id | stack_name | stack_status | creation_time |
 +--------------------------------------+------------+--------------------+----------------------+
 | 6fca513c-25a1-4849-b7ab-909e37f52eca | example | CREATE_IN_PROGRESS | 2015-08-31T16:18:02Z |
 +--------------------------------------+------------+--------------------+----------------------+</pre>
<p>Heat will create the stack and launch the one cirros instance.</p>
<pre style="padding-left:30px;">#nova list
 +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+
 | ID | Name | Status | Task State | Power State | Networks |
 +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+
 | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 |
 +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+</pre>
<p>Heat will also create two cpu alarms which are used to trigger scale-up or scale-down events.</p>
<pre>ceilometer alarm-list
+--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+
| Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints |
+--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+
| 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None |
| ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | ok | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None |
+--------------------------------------+-------------------------------------+-------------------+----------+---------+------------+--------------------------------+------------------+</pre>
<h3>Automatically Scaling Up</h3>
<p>Heat will scale instances up based on the cpu_alarm_high threshold. Once CPU utilization is above 50% instances will be scaled up. In order to generate CPU load, log into the instance and run the "dd" command.</p>
<pre style="padding-left:30px;">$ssh -i admin.pem cirros@192.168.122.232
$sudo -i
#dd if=/dev/zero of=/dev/null &amp;
#dd if=/dev/zero of=/dev/null &amp;
#dd if=/dev/zero of=/dev/null &amp;</pre>
<p>Upon running "dd" commands we should have close to 100% CPU utilization in our cirros instance. After 60 seconds we should see that Heat has scaled and we have two instances.</p>
<pre style="padding-left:30px;">#ceilometer alarm-list
+--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+
| Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints |
+--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+
| 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None |
| ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | alarm | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None |
+--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+</pre>
<pre style="padding-left:30px;">#nova list
 +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+
 | ID | Name | Status | Task State | Power State | Networks |
 +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+
 | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 |
 | 0f69dfbe-4654-474f-9308-1b64de3f5c18 | ex-qeki-qmvor5rkptj7-krq7i66h6n7b-server-b4pk3dzjvbpi | ACTIVE | - | Running | private=10.10.1.157, 192.168.122.235 |
 +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+</pre>
<p>After additional 60 seconds we should see that Heat has scaled again and we have three instances. Since three is the maximum for this configuration, we will not scale any higher.</p>
<pre style="padding-left:30px;">#nova list
 +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+
 | ID | Name | Status | Task State | Power State | Networks |
 +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+
 | 3f627c84-06aa-4782-8c12-29409964cc73 | ex-qeki-3azno6me5gvm-pqmr5zd6kuhm-server-gieck7uoyrwc | ACTIVE | - | Running | private=10.10.1.156, 192.168.122.234 |
 | 0e805e75-aa6f-4375-b057-2c173b68f172 | ex-qeki-gajdwmu2cgm2-vckf4g2gpwis-server-r3smbhtqij76 | ACTIVE | - | Running | private=10.10.1.158, 192.168.122.236 |
 | 0f69dfbe-4654-474f-9308-1b64de3f5c18 | ex-qeki-qmvor5rkptj7-krq7i66h6n7b-server-b4pk3dzjvbpi | ACTIVE | - | Running | private=10.10.1.157, 192.168.122.235 |
 +--------------------------------------+-------------------------------------------------------+--------+------------+-------------+--------------------------------------+</pre>
<h3>Automatically Scaling Down</h3>
<p>Heat will scale instances down based on the cpu_alarm_low threshold. Once CPU utilization is below 10% instances will be scaled down. We can simply kill the "dd" processes and watch Heat scale instances back down.</p>
<p>After stopping ""dd" processes we should see that the cpu_alarm_low event is triggered. This will cause Heat to scale down and remove instance.</p>
<pre>#ceilometer alarm-list
+--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+
| Alarm ID | Name | State | Severity | Enabled | Continuous | Alarm condition | Time constraints |
+--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+
| 04b4f845-f5b6-4c5a-8af0-59e03c22e6fa | example-cpu_alarm_high-rd5kysmlahvx | ok | low | True | True | cpu_util &gt; 50.0 during 1 x 60s | None |
| ac81cd81-20b3-45f9-bea4-e51f00499602 | example-cpu_alarm_low-6t65kswutupz | alarm | low | True | True | cpu_util &lt; 10.0 during 1 x 60s | None |
+--------------------------------------+-------------------------------------+-------+----------+---------+------------+--------------------------------+------------------+</pre>
<p>After a few minutes we should be back to a single instance.</p>
<h3>Summary</h3>
<p>In this article we talked about how Heat and Ceilometer work together within OpenStack, providing the brains behind your cloud. We looked at a typical cloud use case around auto scaling and how to configure auto scaling through Heat. Hopefully you found this article informative. As always any feedback is greatly appreciated and as we say at Red Hat, sharing is caring.</p>
<p>Happy Auto Scaling!</p>
<p>(c) 2015 Keith Tenzer</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#auto-scaling" class="page__taxonomy-item" rel="tag">Auto-Scaling</a><span class="sep">, </span>
    
      <a href="/tags/#ceilometer" class="page__taxonomy-item" rel="tag">Ceilometer</a><span class="sep">, </span>
    
      <a href="/tags/#cloud-automation" class="page__taxonomy-item" rel="tag">cloud automation</a><span class="sep">, </span>
    
      <a href="/tags/#heat" class="page__taxonomy-item" rel="tag">Heat</a><span class="sep">, </span>
    
      <a href="/tags/#linux" class="page__taxonomy-item" rel="tag">Linux</a><span class="sep">, </span>
    
      <a href="/tags/#openstack" class="page__taxonomy-item" rel="tag">OpenStack</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#openstack" class="page__taxonomy-item" rel="tag">OpenStack</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2015-09-02T00:00:00-07:00">September 2, 2015</time></p>


      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=keithtenzer&text=Auto+Scaling+Instances+with+OpenStack%20http%3A%2F%2Flocalhost%3A4000%2Fopenstack%2Fauto-scaling-instances-with-openstack%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fopenstack%2Fauto-scaling-instances-with-openstack%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fopenstack%2Fauto-scaling-instances-with-openstack%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/openstack/openstack-kilo-lab-installation-and-configuration-guide/" class="pagination--pager" title="OpenStack Kilo Lab Installation and Configuration Guide
">Previous</a>
    
    
      <a href="/satellite/cloud-systems-management-satellite-6-1-getting-started-guide/" class="pagination--pager" title="Cloud Systems Management: Satellite 6.1 Getting Started Guide
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/openshift/building-ansible-operators-1-2-3/" rel="permalink">Building Ansible Operators 1-2-3
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-12-03T00:00:00-08:00">December 3, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          9 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Overview
In this article we will go step by step in build a Kubernetes Operator using Ansible and the Operator Framework. Operators provide ability to not on...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/openshift/openshift-service-mesh-getting-started-guide/" rel="permalink">OpenShift Service Mesh Getting Started Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-04-27T00:00:00-07:00">April 27, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          11 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">






Overview
In this article we will explore the OpenShift Service Mesh and deploy a demo application to better understand the various concepts. First you...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/openshift/openshift-4-aws-ipi-installation-getting-started-guide/" rel="permalink">OpenShift 4 AWS IPI Installation Getting Started Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-01-18T00:00:00-08:00">January 18, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          8 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">


Happy new year as this will be the first post of 2021! 2020 was obviously a challenging year, my hope is I will have more time to devote to blogging in 20...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ansible/windows-automation-with-ansible-getting-started-guide/" rel="permalink">Windows Automation with Ansible: Getting Started Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2020-05-19T00:00:00-07:00">May 19, 2020</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          14 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
Overview
In this article we will focus on how to get started with automation of windows using Ansible. Specifically we will look at installing 3rd party sof...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://twitter.com/keithtenzer"" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
      
        
          <li><a href="https://github.com/ktenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 Keith Tenzer. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
