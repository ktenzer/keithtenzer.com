<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
<link rel="icon" href="/assets/main/me.png">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Application Containers: A Practical HowTo Guide - Keith Tenzer’s Blog</title>
<meta name="description" content="Overview We have by now all heard plenty about Linux containers and for good reason. Containers change the way applications are operated and allow us to deploy applications at unprecedented speeds. Containers pick up where Virtual Machines left off, at the application layer. In this article we will focus on the journey to a container driven world and explore the phases along the way.  Container Rules Before beginning our journey it is important to understand basic container rules:  A container should run one and only one application process Containers are immutable, if something needs to be changed the container is thrown away and re-created Containers are insulated from one another but not isolated in same way as VIrtual Machines Containers share same Linux Kernel  Application Discovery The first phase inolves indentifying applications. Not all applications are ideal to run in containers. Similar to cloud infrastructure such as OpenStack, containers require a certain application design. An application should exhibit the following behavior:  Application functionality should be broken into components  components should be standalone services and have no dependencies on any other components all services should communicate with one another using external RESTful APIs   Application state change should be handled by using message buses or a distributed key/value store Application must scale horizontally not vertically Heavy components like databases should be operated on bare-metal or in Virtual Machines that can scale vertically  For the purpose of this article I chose to containerize an application that displays these characteristics. Integra is an integration, automation and orchestration platform. It exposes application capabilities through providers that provide standalone micro-services with a RESTful frontend. The Integra reactor is the brain and allows automation architects to build workflows from capabilities exposed by providers. There are providers for applicaitons, databases, hypervisors, storage systems and much more. The idea behind Integra is automate everything with no compromises. Integra sees no difference between backup, provisioning or other common tasks. Everything is a workflow that can be automated using a standard toolset.  Since Integra is composed of many services it is important to place each service in its own container. This means the reactor and every provider, even the CLI get its own container. The container will need to provide all dependencies in order to run the application including exposing ports. Each service or component of an application should use a different unique port. For Docker alone it doesn&#39;t matter as much but once we get into Kubernetes and pods this becomes very important since containers within a pod share same IP address. Running Application in Container Running applications in containers is not that much different than outside of a container. A container can run one command so typically we would create a small start script to lauch the application. Below is the start script run-integra.sh I am using for the Integra reactor: #!/bin/sh  pgrep -f &quot;rest-1.0.2-uber.jar&quot; | awk &#39;{system(&quot;kill &quot; $1)}&#39;  exec /usr/bin/java -jar /integra/rest-1.0.2-uber.jar Before building our application container it is important to test and ensure things are working. Below are the commands I used to test the Integra reactor. # docker pull debian # docker run -i -t debian /bin/bash At this point we are inside the container running debian as the base OS. root@b4a37b0d8040:/# apt-get update root@b4a37b0d8040:/# apt-get install -y openjdk-7-jre We have now installed the application dependencies and can test the Integra reactor inside the container. Next we need to copy the application JAR to the container using the container id (long format). # docker ps CONTAINER     ID IMAGE         COMMAND       CREATED         STATUS b4a37b0d8040  debian:latest    &quot;/bin/bash&quot;   5 minutes ago   Up 5 minutes # docker inspect -f b4a37b0d8040 b4a37b0d8040a0d624b7edc264425693a7e0e50444f72d09a54209ff6461b377 cp rest-1.0.2-uber.jar /var/lib/docker/devicemapper/mnt/b4a37b0d8040a0d624b7edc264425693a7e0e50444f72d09a54209ff6461b377/rootfs Now that we have copied the JAR file from our host OS to the container we can run the Integra reactor and ensure it works. root@b4a37b0d8040:/# java -jar rest-1.0.2-uber.jar Finally we are ready to build our Docker application container! Building Docker Image Docker provides a standard for packaging containers. While container technology has been around for a long time in both Unix and Linux the tooling and portability that Docker provides is certainly game-changing. Docker uses a Dockerfile to define the container image. A docker image is a grouping of layers. In our example we have essentially three layers: the base OS (Debian), required dependencies (Java) and our application (JAR). Besides providing software layering a Dockerfile also enables us to expose application ports, run-time environment parameters and a tooling for executing standard OS commands. Below is the Dockerfile used to build the Integra Reactor. # vi Dockerfile # Integra Reactor # VERSION 0.0.1 FROM debian MAINTAINER Keith Tenzer &lt;maintainer@domain.com&gt;">


  <meta name="author" content="Keith Tenzer">
  
  <meta property="article:author" content="Keith Tenzer">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Keith Tenzer's Blog">
<meta property="og:title" content="Application Containers: A Practical HowTo Guide">
<meta property="og:url" content="http://localhost:4000/containers/application-containers-a-practical-howto-guide/">


  <meta property="og:description" content="Overview We have by now all heard plenty about Linux containers and for good reason. Containers change the way applications are operated and allow us to deploy applications at unprecedented speeds. Containers pick up where Virtual Machines left off, at the application layer. In this article we will focus on the journey to a container driven world and explore the phases along the way.  Container Rules Before beginning our journey it is important to understand basic container rules:  A container should run one and only one application process Containers are immutable, if something needs to be changed the container is thrown away and re-created Containers are insulated from one another but not isolated in same way as VIrtual Machines Containers share same Linux Kernel  Application Discovery The first phase inolves indentifying applications. Not all applications are ideal to run in containers. Similar to cloud infrastructure such as OpenStack, containers require a certain application design. An application should exhibit the following behavior:  Application functionality should be broken into components  components should be standalone services and have no dependencies on any other components all services should communicate with one another using external RESTful APIs   Application state change should be handled by using message buses or a distributed key/value store Application must scale horizontally not vertically Heavy components like databases should be operated on bare-metal or in Virtual Machines that can scale vertically  For the purpose of this article I chose to containerize an application that displays these characteristics. Integra is an integration, automation and orchestration platform. It exposes application capabilities through providers that provide standalone micro-services with a RESTful frontend. The Integra reactor is the brain and allows automation architects to build workflows from capabilities exposed by providers. There are providers for applicaitons, databases, hypervisors, storage systems and much more. The idea behind Integra is automate everything with no compromises. Integra sees no difference between backup, provisioning or other common tasks. Everything is a workflow that can be automated using a standard toolset.  Since Integra is composed of many services it is important to place each service in its own container. This means the reactor and every provider, even the CLI get its own container. The container will need to provide all dependencies in order to run the application including exposing ports. Each service or component of an application should use a different unique port. For Docker alone it doesn&#39;t matter as much but once we get into Kubernetes and pods this becomes very important since containers within a pod share same IP address. Running Application in Container Running applications in containers is not that much different than outside of a container. A container can run one command so typically we would create a small start script to lauch the application. Below is the start script run-integra.sh I am using for the Integra reactor: #!/bin/sh  pgrep -f &quot;rest-1.0.2-uber.jar&quot; | awk &#39;{system(&quot;kill &quot; $1)}&#39;  exec /usr/bin/java -jar /integra/rest-1.0.2-uber.jar Before building our application container it is important to test and ensure things are working. Below are the commands I used to test the Integra reactor. # docker pull debian # docker run -i -t debian /bin/bash At this point we are inside the container running debian as the base OS. root@b4a37b0d8040:/# apt-get update root@b4a37b0d8040:/# apt-get install -y openjdk-7-jre We have now installed the application dependencies and can test the Integra reactor inside the container. Next we need to copy the application JAR to the container using the container id (long format). # docker ps CONTAINER     ID IMAGE         COMMAND       CREATED         STATUS b4a37b0d8040  debian:latest    &quot;/bin/bash&quot;   5 minutes ago   Up 5 minutes # docker inspect -f b4a37b0d8040 b4a37b0d8040a0d624b7edc264425693a7e0e50444f72d09a54209ff6461b377 cp rest-1.0.2-uber.jar /var/lib/docker/devicemapper/mnt/b4a37b0d8040a0d624b7edc264425693a7e0e50444f72d09a54209ff6461b377/rootfs Now that we have copied the JAR file from our host OS to the container we can run the Integra reactor and ensure it works. root@b4a37b0d8040:/# java -jar rest-1.0.2-uber.jar Finally we are ready to build our Docker application container! Building Docker Image Docker provides a standard for packaging containers. While container technology has been around for a long time in both Unix and Linux the tooling and portability that Docker provides is certainly game-changing. Docker uses a Dockerfile to define the container image. A docker image is a grouping of layers. In our example we have essentially three layers: the base OS (Debian), required dependencies (Java) and our application (JAR). Besides providing software layering a Dockerfile also enables us to expose application ports, run-time environment parameters and a tooling for executing standard OS commands. Below is the Dockerfile used to build the Integra Reactor. # vi Dockerfile # Integra Reactor # VERSION 0.0.1 FROM debian MAINTAINER Keith Tenzer &lt;maintainer@domain.com&gt;">





  <meta name="twitter:site" content="@keithtenzer">
  <meta name="twitter:title" content="Application Containers: A Practical HowTo Guide">
  <meta name="twitter:description" content="Overview We have by now all heard plenty about Linux containers and for good reason. Containers change the way applications are operated and allow us to deploy applications at unprecedented speeds. Containers pick up where Virtual Machines left off, at the application layer. In this article we will focus on the journey to a container driven world and explore the phases along the way.  Container Rules Before beginning our journey it is important to understand basic container rules:  A container should run one and only one application process Containers are immutable, if something needs to be changed the container is thrown away and re-created Containers are insulated from one another but not isolated in same way as VIrtual Machines Containers share same Linux Kernel  Application Discovery The first phase inolves indentifying applications. Not all applications are ideal to run in containers. Similar to cloud infrastructure such as OpenStack, containers require a certain application design. An application should exhibit the following behavior:  Application functionality should be broken into components  components should be standalone services and have no dependencies on any other components all services should communicate with one another using external RESTful APIs   Application state change should be handled by using message buses or a distributed key/value store Application must scale horizontally not vertically Heavy components like databases should be operated on bare-metal or in Virtual Machines that can scale vertically  For the purpose of this article I chose to containerize an application that displays these characteristics. Integra is an integration, automation and orchestration platform. It exposes application capabilities through providers that provide standalone micro-services with a RESTful frontend. The Integra reactor is the brain and allows automation architects to build workflows from capabilities exposed by providers. There are providers for applicaitons, databases, hypervisors, storage systems and much more. The idea behind Integra is automate everything with no compromises. Integra sees no difference between backup, provisioning or other common tasks. Everything is a workflow that can be automated using a standard toolset.  Since Integra is composed of many services it is important to place each service in its own container. This means the reactor and every provider, even the CLI get its own container. The container will need to provide all dependencies in order to run the application including exposing ports. Each service or component of an application should use a different unique port. For Docker alone it doesn&#39;t matter as much but once we get into Kubernetes and pods this becomes very important since containers within a pod share same IP address. Running Application in Container Running applications in containers is not that much different than outside of a container. A container can run one command so typically we would create a small start script to lauch the application. Below is the start script run-integra.sh I am using for the Integra reactor: #!/bin/sh  pgrep -f &quot;rest-1.0.2-uber.jar&quot; | awk &#39;{system(&quot;kill &quot; $1)}&#39;  exec /usr/bin/java -jar /integra/rest-1.0.2-uber.jar Before building our application container it is important to test and ensure things are working. Below are the commands I used to test the Integra reactor. # docker pull debian # docker run -i -t debian /bin/bash At this point we are inside the container running debian as the base OS. root@b4a37b0d8040:/# apt-get update root@b4a37b0d8040:/# apt-get install -y openjdk-7-jre We have now installed the application dependencies and can test the Integra reactor inside the container. Next we need to copy the application JAR to the container using the container id (long format). # docker ps CONTAINER     ID IMAGE         COMMAND       CREATED         STATUS b4a37b0d8040  debian:latest    &quot;/bin/bash&quot;   5 minutes ago   Up 5 minutes # docker inspect -f b4a37b0d8040 b4a37b0d8040a0d624b7edc264425693a7e0e50444f72d09a54209ff6461b377 cp rest-1.0.2-uber.jar /var/lib/docker/devicemapper/mnt/b4a37b0d8040a0d624b7edc264425693a7e0e50444f72d09a54209ff6461b377/rootfs Now that we have copied the JAR file from our host OS to the container we can run the Integra reactor and ensure it works. root@b4a37b0d8040:/# java -jar rest-1.0.2-uber.jar Finally we are ready to build our Docker application container! Building Docker Image Docker provides a standard for packaging containers. While container technology has been around for a long time in both Unix and Linux the tooling and portability that Docker provides is certainly game-changing. Docker uses a Dockerfile to define the container image. A docker image is a grouping of layers. In our example we have essentially three layers: the base OS (Debian), required dependencies (Java) and our application (JAR). Besides providing software layering a Dockerfile also enables us to expose application ports, run-time environment parameters and a tooling for executing standard OS commands. Below is the Dockerfile used to build the Integra Reactor. # vi Dockerfile # Integra Reactor # VERSION 0.0.1 FROM debian MAINTAINER Keith Tenzer &lt;maintainer@domain.com&gt;">
  <meta name="twitter:url" content="http://localhost:4000/containers/application-containers-a-practical-howto-guide/">

  
    <meta name="twitter:card" content="summary">
    
  

  



  <meta property="article:published_time" content="2015-05-11T00:00:00-07:00">





  

  


<link rel="canonical" href="http://localhost:4000/containers/application-containers-a-practical-howto-guide/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Keith Tenzer",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Keith Tenzer's Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Keith Tenzer's Blog
          <span class="site-subtitle">Cloud Computing and Code</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/about/index.html">About</a>
            </li><li class="masthead__menu-item">
              <a href="/conferences-and-events/index.html">Conferences and Events</a>
            </li><li class="masthead__menu-item">
              <a href="/videos/index.html">Videos</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="http://localhost:4000/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#containers" itemprop="item"><span itemprop="name">Containers</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        <li class="current">Application Containers: A Practical HowTo Guide</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/main/me.png" alt="Keith Tenzer" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Keith Tenzer</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Principal Solutions Architect at Red Hat</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Los Angeles, CA</span>
        </li>
      

      
        
          
        
          
        
          
            <li><a href="https://twitter.com/keithtenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span></a></li>
          
        
          
        
          
            <li><a href="https://github.com/ktenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Application Containers: A Practical HowTo Guide">
    <meta itemprop="description" content="OverviewWe have by now all heard plenty about Linux containers and for good reason. Containers change the way applications are operated and allow us to deploy applications at unprecedented speeds. Containers pick up where Virtual Machines left off, at the application layer. In this article we will focus on the journey to a container driven world and explore the phases along the way. Container RulesBefore beginning our journey it is important to understand basic container rules:A container should run one and only one application processContainers are immutable, if something needs to be changed the container is thrown away and re-createdContainers are insulated from one another but not isolated in same way as VIrtual MachinesContainers share same Linux KernelApplication DiscoveryThe first phase inolves indentifying applications. Not all applications are ideal to run in containers. Similar to cloud infrastructure such as OpenStack, containers require a certain application design. An application should exhibit the following behavior:Application functionality should be broken into componentscomponents should be standalone services and have no dependencies on any other componentsall services should communicate with one another using external RESTful APIsApplication state change should be handled by using message buses or a distributed key/value storeApplication must scale horizontally not verticallyHeavy components like databases should be operated on bare-metal or in Virtual Machines that can scale verticallyFor the purpose of this article I chose to containerize an application that displays these characteristics. Integra is an integration, automation and orchestration platform. It exposes application capabilities through providers that provide standalone micro-services with a RESTful frontend. The Integra reactor is the brain and allows automation architects to build workflows from capabilities exposed by providers. There are providers for applicaitons, databases, hypervisors, storage systems and much more. The idea behind Integra is automate everything with no compromises. Integra sees no difference between backup, provisioning or other common tasks. Everything is a workflow that can be automated using a standard toolset.Since Integra is composed of many services it is important to place each service in its own container. This means the reactor and every provider, even the CLI get its own container. The container will need to provide all dependencies in order to run the application including exposing ports. Each service or component of an application should use a different unique port. For Docker alone it doesn&#39;t matter as much but once we get into Kubernetes and pods this becomes very important since containers within a pod share same IP address.Running Application in ContainerRunning applications in containers is not that much different than outside of a container. A container can run one command so typically we would create a small start script to lauch the application. Below is the start script run-integra.sh I am using for the Integra reactor:#!/bin/sh pgrep -f &quot;rest-1.0.2-uber.jar&quot; | awk &#39;{system(&quot;kill &quot; $1)}&#39; exec /usr/bin/java -jar /integra/rest-1.0.2-uber.jarBefore building our application container it is important to test and ensure things are working. Below are the commands I used to test the Integra reactor.# docker pull debian# docker run -i -t debian /bin/bashAt this point we are inside the container running debian as the base OS.root@b4a37b0d8040:/# apt-get updateroot@b4a37b0d8040:/# apt-get install -y openjdk-7-jreWe have now installed the application dependencies and can test the Integra reactor inside the container. Next we need to copy the application JAR to the container using the container id (long format).# docker psCONTAINER     ID IMAGE         COMMAND       CREATED         STATUSb4a37b0d8040  debian:latest    &quot;/bin/bash&quot;   5 minutes ago   Up 5 minutes# docker inspect -f b4a37b0d8040b4a37b0d8040a0d624b7edc264425693a7e0e50444f72d09a54209ff6461b377cp rest-1.0.2-uber.jar /var/lib/docker/devicemapper/mnt/b4a37b0d8040a0d624b7edc264425693a7e0e50444f72d09a54209ff6461b377/rootfsNow that we have copied the JAR file from our host OS to the container we can run the Integra reactor and ensure it works.root@b4a37b0d8040:/# java -jar rest-1.0.2-uber.jarFinally we are ready to build our Docker application container!Building Docker ImageDocker provides a standard for packaging containers. While container technology has been around for a long time in both Unix and Linux the tooling and portability that Docker provides is certainly game-changing. Docker uses a Dockerfile to define the container image. A docker image is a grouping of layers. In our example we have essentially three layers: the base OS (Debian), required dependencies (Java) and our application (JAR). Besides providing software layering a Dockerfile also enables us to expose application ports, run-time environment parameters and a tooling for executing standard OS commands. Below is the Dockerfile used to build the Integra Reactor.# vi Dockerfile# Integra Reactor# VERSION 0.0.1FROM debian MAINTAINER Keith Tenzer &lt;maintainer@domain.com&gt;">
    <meta itemprop="datePublished" content="2015-05-11T00:00:00-07:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Application Containers: A Practical HowTo Guide
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2015-05-11T00:00:00-07:00">May 11, 2015</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          17 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
        <h3>Overview</h3>
<p>We have by now all heard plenty about Linux containers and for good reason. Containers change the way applications are operated and allow us to deploy applications at unprecedented speeds. Containers pick up where Virtual Machines left off, at the application layer. In this article we will focus on the journey to a container driven world and explore the phases along the way. <!--more--></p>
<h3>Container Rules</h3>
<p>Before beginning our journey it is important to understand basic container rules:</p>
<ul>
<li>A container should run one and only one application process</li>
<li>Containers are immutable, if something needs to be changed the container is thrown away and re-created</li>
<li>Containers are insulated from one another but not isolated in same way as VIrtual Machines</li>
<li>Containers share same Linux Kernel</li>
</ul>
<h3>Application Discovery</h3>
<p>The first phase inolves indentifying applications. Not all applications are ideal to run in containers. Similar to cloud infrastructure such as OpenStack, containers require a certain application design. An application should exhibit the following behavior:</p>
<ul>
<li style="text-align:left;">Application functionality should be broken into components
<ul>
<li style="text-align:left;">components should be standalone services and have no dependencies on any other components</li>
<li style="text-align:left;">all services should communicate with one another using external RESTful APIs</li>
</ul>
</li>
<li style="text-align:left;">Application state change should be handled by using message buses or a distributed key/value store</li>
<li style="text-align:left;">Application must scale horizontally not vertically</li>
<li style="text-align:left;">Heavy components like databases should be operated on bare-metal or in Virtual Machines that can scale vertically</li>
</ul>
<p>For the purpose of this article I chose to containerize an application that displays these characteristics. <a href="http://integra.emitrom.com/">Integra</a> is an integration, automation and orchestration platform. It exposes application capabilities through providers that provide standalone micro-services with a RESTful frontend. The Integra reactor is the brain and allows automation architects to build workflows from capabilities exposed by providers. There are providers for applicaitons, databases, hypervisors, storage systems and much more. The idea behind Integra is automate everything with no compromises. Integra sees no difference between backup, provisioning or other common tasks. Everything is a workflow that can be automated using a standard toolset.</p>
<p><a href="https://keithtenzer.files.wordpress.com/2015/05/integra_architecture.jpg"><img class="  wp-image-894 aligncenter" src="/assets/2015/05/integra_architecture.jpg?w=280" alt="Integra_Architecture" width="968" height="1037" /></a></p>
<p>Since Integra is composed of many services it is important to place each service in its own container. This means the reactor and every provider, even the CLI get its own container. The container will need to provide all dependencies in order to run the application including exposing ports. Each service or component of an application should use a different unique port. For Docker alone it doesn't matter as much but once we get into Kubernetes and pods this becomes very important since containers within a pod share same IP address.</p>
<h3>Running Application in Container</h3>
<p>Running applications in containers is not that much different than outside of a container. A container can run one command so typically we would create a small start script to lauch the application. Below is the start script run-integra.sh I am using for the Integra reactor:</p>
<pre style="padding-left:30px;">#!/bin/sh
 pgrep -f "rest-1.0.2-uber.jar" | awk '{system("kill " $1)}'
 exec /usr/bin/java -jar /integra/rest-1.0.2-uber.jar</pre>
<p>Before building our application container it is important to test and ensure things are working. Below are the commands I used to test the Integra reactor.</p>
<pre style="padding-left:30px;"># docker pull debian</pre>
<pre style="padding-left:30px;"># docker run -i -t debian /bin/bash</pre>
<p>At this point we are inside the container running debian as the base OS.</p>
<pre style="padding-left:30px;">root@b4a37b0d8040:/# apt-get update</pre>
<pre style="padding-left:30px;">root@b4a37b0d8040:/# apt-get install -y openjdk-7-jre</pre>
<p>We have now installed the application dependencies and can test the Integra reactor inside the container. Next we need to copy the application JAR to the container using the container id (long format).</p>
<pre style="padding-left:30px;"># docker ps
CONTAINER     ID IMAGE         COMMAND       CREATED         STATUS
b4a37b0d8040  debian:latest    "/bin/bash"   5 minutes ago   Up 5 minutes</pre>
<pre class="lang-sh prettyprint prettyprinted" style="padding-left:30px;"><code><span class="pln"># docker inspect -f b4a37b0d8040
b4a37b0d8040a0d624b7edc264425693a7e0e50444f72d09a54209ff6461b377</span></code></pre>
<pre class="lang-sh prettyprint prettyprinted" style="padding-left:30px;"><code><span class="pln">cp </span></code>rest-1.0.2-uber.jar /var/lib/docker/devicemapper/mnt/b4a37b0d8040a0d624b7edc264425693a7e0e50444f72d09a54209ff6461b377/rootfs</pre>
<p>Now that we have copied the JAR file from our host OS to the container we can run the Integra reactor and ensure it works.</p>
<pre style="padding-left:30px;">root@b4a37b0d8040:/# java -jar rest-1.0.2-uber.jar</pre>
<p>Finally we are ready to build our Docker application container!</p>
<h3>Building Docker Image</h3>
<p>Docker provides a standard for packaging containers. While container technology has been around for a long time in both Unix and Linux the tooling and portability that Docker provides is certainly game-changing. Docker uses a Dockerfile to define the container image. A docker image is a grouping of layers. In our example we have essentially three layers: the base OS (Debian), required dependencies (Java) and our application (JAR). Besides providing software layering a Dockerfile also enables us to expose application ports, run-time environment parameters and a tooling for executing standard OS commands. Below is the Dockerfile used to build the Integra Reactor.</p>
<pre style="padding-left:30px;"># vi Dockerfile
# Integra Reactor
# VERSION 0.0.1
FROM debian MAINTAINER Keith Tenzer &lt;maintainer@domain.com&gt;

LABEL Description="This image is used to start the Integra Rest Server" Vendor="Emitrom" Version="1.02" RUN apt-get update &amp;&amp; apt-get install -y openjdk-7-jre

RUN mkdir /integra 
COPY rest/* /integra/ 
COPY run-integra.sh / 
RUN chmod -R 755 /integra 
RUN chmod 755 /run-integra.sh

ENV JAVA_OPTS="-Xms512m -Xmx1152m -XX:MaxPermSize=256m -XX:MaxNewSize=256m"

EXPOSE 8080 8443

CMD ["/run-integra.sh"]</pre>
<p>Once we are ready we can build our docker image. The docker build command will create the image and make it available in our local docker repository.</p>
<pre style="padding-left:30px;"># docker build -t integra/reactor:v1.0.2 .</pre>
<pre style="padding-left:30px;"># docker images
REPOSITORY          TAG       IMAGE ID        CREATED         VIRTUAL SIZE
integra/reactor     v1.0.2    233be1b0b05f    16 hours ago    523.4 MB</pre>
<h3>Sharing Docker Images</h3>
<p>Docker provides a public registry called <a href="http://hub.docker.com">Docker Hub</a> and in addition allows us to run our own private registry in order to share trusted images internally. Once the docker image is created it can be shared with a registry using the the docker push command. In order to allow Docker to communicate with an insecure private registry the docker daemon must be started with the --insecure-registry option as follows:</p>
<pre style="padding-left:30px;">docker -d --insecure-registry kubernetes.lab.com:5000 &amp;</pre>
<p>Tags are used to allow for versioning of Docker images. A special tag called latest is used as default whenever a tag is not specified. For example above we issued the command 'docker run -i -t debian /bin/bash'. Since a tag was not specified docker run used latest. The most current version of a Docker image should also be taged with 'latest'.</p>
<pre style="padding-left:30px;">docker tag emitrom/server:v1.02 kubernetes.lab.com:5000/emitrom/integra-server:v1.02</pre>
<pre style="padding-left:30px;">docker tag emitrom/integra-server:v1.02 kubernetes.lab.com:5000/emitrom/integra-server:latest</pre>
<h4>Pusing Docker Image to Private Registry</h4>
<pre style="padding-left:30px;">docker push kubernetes.lab.com:5000/integra/reactor</pre>
<h4>Pusing Docker Image to Docker Hub</h4>
<pre style="padding-left:30px;"># docker push integra/reactor</pre>
<pre style="padding-left:30px;">Please login prior to push:
Username: integra
Password: *******
Email: maintainer@domain.com</pre>
<p>To see all images for the user integra we can go directly to Docker Hub or run a command.</p>
<p><a href="https://keithtenzer.files.wordpress.com/2015/05/docker_hub_integra.jpg"><img class="  wp-image-905 aligncenter" src="/assets/2015/05/docker_hub_integra.jpg?w=300" alt="Docker_Hub_Integra" width="1171" height="816" /></a></p>
<pre style="padding-left:30px;"># docker search integra |grep "^integra/"</pre>
<h3>Running Docker Images</h3>
<p>We have built our Docker image for the Integra reactor and shared it in Docker Hub or a private registry. At this point anyone can run the application on any system running Docker using two simple commands.</p>
<pre style="padding-left:30px;"># docker pull integra/reactor</pre>
<pre style="padding-left:30px;"># docker run -i -t -d integra/reactor</pre>
<p>This is the power of containers and portability of Docker. Think of how you would normally deploy such an application without containers? Think of the portability, your app can run on any system running Docker, anywhere.</p>
<h3>Running Docker Images in Kubernetes</h3>
<p>Running vanilla Docker is great for development or test environments but assuming we want to run this application in a production environment there are a few things missing. First we don't have any mechanism to orchestrate or handle deploying our application on multiple hosts. Next the target application contains many services, each being it's own container and connecting them together is quite a bit of work. There is no abstraction around services, a container may be temporary but an application service is certainly not. Finally we have no management around reliability or horizontal scaling. These are the gaps that Google's Kubernetes fills. For more information on setting up Kubernetes read this <a href="http://keithtenzer.com/2015/04/15/containers-at-scale-with-kubernetes-on-openstack/">article</a>. Kubernetes creates an abstraction around containers called a pod. A pod contains one or more tightly coupled containers. In this case if we want a holistic deployment of Integra and all its providers, reactor and CLI we can encapsulate the entire application in a Kubernetes pod. Once we have a pod independent services and replication policies can be created, Kubernetes handles all this automatically. Below is an example of a multiple container pod configuration.</p>
<pre style="padding-left:30px;"># vi integra-all.json</pre>
<p>[code language="java"]<br />
{<br />
   &quot;apiVersion&quot;: &quot;v1beta1&quot;,<br />
   &quot;desiredState&quot;: {<br />
      &quot;manifest&quot;: {<br />
      &quot;containers&quot;: [<br />
      {<br />
         &quot;image&quot;: &quot;integra/reactor&quot;,<br />
         &quot;name&quot;: &quot;integra-reactor&quot;,<br />
         &quot;ports&quot;: [<br />
         {<br />
            &quot;containerPort&quot;: 8080,<br />
            &quot;hostPort&quot;: 8080,<br />
            &quot;protocol&quot;: &quot;TCP&quot;<br />
         }<br />
         ]<br />
      },<br />
      {<br />
         &quot;image&quot;: &quot;integra/aws-provider&quot;,<br />
         &quot;name&quot;: &quot;integra-aws&quot;,<br />
         &quot;ports&quot;: [<br />
         {<br />
            &quot;containerPort&quot;: 9771,<br />
            &quot;hostPort&quot;: 9771,<br />
            &quot;protocol&quot;: &quot;TCP&quot;<br />
         }<br />
         ]<br />
      },<br />
      {<br />
         &quot;image&quot;: &quot;integra/azure-provider&quot;,<br />
         &quot;name&quot;: &quot;integra-azure&quot;,<br />
         &quot;ports&quot;: [<br />
         {<br />
            &quot;containerPort&quot;: 9772,<br />
            &quot;hostPort&quot;: 9772,<br />
            &quot;protocol&quot;: &quot;TCP&quot;<br />
         }<br />
         ]<br />
      }<br />
      ],<br />
      &quot;id&quot;: &quot;integra-all&quot;,<br />
      &quot;restartPolicy&quot;: {<br />
      &quot;always&quot;: {}<br />
   },<br />
   &quot;version&quot;: &quot;v1beta1&quot;,<br />
   &quot;volumes&quot;: null<br />
   }<br />
 },<br />
 &quot;id&quot;: &quot;integra-all&quot;,<br />
 &quot;kind&quot;: &quot;Pod&quot;,<br />
 &quot;labels&quot;: {<br />
 &quot;name&quot;: &quot;integra-all&quot;<br />
 },<br />
 &quot;namespace&quot;: &quot;default&quot;<br />
}<br />
[/code]</p>
<p>We can issue the following command in Kubernetes to deploy our pod:</p>
<pre style="padding-left:30px;">kubectl create -f integra-reactor-svc.json</pre>
<pre style="padding-left:30px;"># kubectl get pods
POD            IP             CONTAINER(S)      IMAGE(S)                         HOST                 LABELS             STATUS
integra-all    10.100.77.3    integra-reactor   integra/reactor:latest           atomic01.lab.com/    name=integra-all   Running
                              integra-aws       integra/aws-provider:latest
                              integra-azure     integra/azure-provider:latest</pre>
<p>Next we need to expose the Integra reactor running on port 8080 as a service. The nice thing about pods is that all containers within pod communicate using the same IP address. This makes it much simpler to configure communication between related application services.</p>
<pre style="padding-left:30px;"># vi integra-all-svc.json</pre>
<p>[code language="java"]</p>
<p>{<br />
   &quot;apiVersion&quot;: &quot;v1beta1&quot;,<br />
   &quot;containerPort&quot;: 8080,<br />
   &quot;id&quot;: &quot;integra-reactor-svc&quot;,<br />
   &quot;kind&quot;: &quot;Service&quot;,<br />
   &quot;labels&quot;: {<br />
      &quot;name&quot;: &quot;integra-reactor-svc&quot;<br />
   },<br />
   &quot;port&quot;: 8080,<br />
   &quot;publicIPs&quot;: [<br />
      &quot;10.10.1.114&quot;,&quot;10.10.1.115&quot;,&quot;10.10.1.116&quot;<br />
   ],<br />
   &quot;selector&quot;: {<br />
      &quot;name&quot;: &quot;integra-all&quot;<br />
   }<br />
 }</p>
<p>[/code]</p>
<p>We can create the service and we are done!</p>
<pre style="padding-left:30px;"> kubectl create -f integra-reactor-svc.json</pre>
<p>Finally in order to test we can make a simple HTTP request to the Integra reactor.</p>
<pre style="padding-left:30px;">curl -u admin:integra http://10.10.1.114:8080/rest</pre>
<div class="line">
<p>[code language="java"]<br />
&lt;appInfo&gt;<br />
   &lt;name&gt;Integra&lt;/name&gt;<br />
   &lt;version&gt;1.0.2&lt;/version&gt;<br />
   &lt;buildTimestamp&gt;20150420-2208&lt;/buildTimestamp&gt;<br />
&lt;/appInfo&gt;<br />
[/code]</p>
</div>
<h3 class="line">Summary</h3>
<div class="line">In this article we explored how to approach and prepare applications running inside containers using the Docker platform. We have seen how to build docker images and use a docker registry to share images. Finally we have observed how to run containers inside Docker and Kubernetes. It doesn't stop there though, the story gets even better. In a future article I will discuss the need for PaaS and how PaaS can leverage these underlying technologies to provider even more value. In today's world IT is all about speed and innovation, if you don't have speed you cannot innovate, if you cannot innovate you will perish.</div>
<div class="line"></div>
<div class="line">Happy Containerizing!</div>
<div class="line">
<p>(c) 2015 Keith Tenzer</p>
</div>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#docker" class="page__taxonomy-item" rel="tag">Docker</a><span class="sep">, </span>
    
      <a href="/tags/#kubernetes" class="page__taxonomy-item" rel="tag">Kubernetes</a><span class="sep">, </span>
    
      <a href="/tags/#linux" class="page__taxonomy-item" rel="tag">Linux</a><span class="sep">, </span>
    
      <a href="/tags/#lxc" class="page__taxonomy-item" rel="tag">LXC</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#containers" class="page__taxonomy-item" rel="tag">Containers</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2015-05-11T00:00:00-07:00">May 11, 2015</time></p>


      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=keithtenzer&text=Application+Containers%3A+A+Practical+HowTo+Guide%20http%3A%2F%2Flocalhost%3A4000%2Fcontainers%2Fapplication-containers-a-practical-howto-guide%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fcontainers%2Fapplication-containers-a-practical-howto-guide%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fcontainers%2Fapplication-containers-a-practical-howto-guide%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/containers/kubernetes-container-orchestration-through-java-apis/" class="pagination--pager" title="Kubernetes Container Orchestration through Java APIs
">Previous</a>
    
    
      <a href="/containers/application-containers-kubernetes-and-docker-from-scratch/" class="pagination--pager" title="Application Containers: Kubernetes and Docker from Scratch
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/linux/blog-with-gitops-practices-and-github/" rel="permalink">Blog with Gitops Practices and GitHub
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2022-02-10T00:00:00-08:00">February 10, 2022</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          13 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Overview
Want to build your brand while living the gitops revolution and not paying anything for it? That is exactly what this article will walk you through....</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/linux/The-Fedora-Workstation-Experience/" rel="permalink">The Fedora Workstation Experience
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2022-01-10T00:00:00-08:00">January 10, 2022</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          10 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
Overview
A lot of people always ask me what is the best way to contribute to opensource? Of course contributing code, documentation, spreading the gospel or...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/openshift/building-ansible-operators-1-2-3/" rel="permalink">Building Ansible Operators 1-2-3
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-12-03T00:00:00-08:00">December 3, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          10 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Overview
In this article we will go step by step to build a Kubernetes Operator using Ansible and the Operator Framework. Operators provide the ability to no...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/openshift/openshift-service-mesh-getting-started-guide/" rel="permalink">OpenShift Service Mesh Getting Started Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-04-27T00:00:00-07:00">April 27, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          11 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">






Overview
In this article we will explore the OpenShift Service Mesh and deploy a demo application to better understand the various concepts. First you...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://twitter.com/keithtenzer"" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
      
        
          <li><a href="https://github.com/ktenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2022 Keith Tenzer. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
