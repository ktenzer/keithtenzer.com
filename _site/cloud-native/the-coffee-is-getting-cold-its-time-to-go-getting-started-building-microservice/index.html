<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
<link rel="icon" href="/assets/main/me.png">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>The Coffee is Getting Cold, It’s Time to GO - Getting Started Building Microservices - Keith Tenzer’s Blog</title>
<meta name="description" content="Overview Java has been around a really, really long time. Certainly it continues to evolve and has evolved. Java has always been a &quot;can do anything&quot; programming language. It has more frameworks and middleware than there are stars in the sky. It is portable anywhere and of course probably 8 out of 10 developers today know Java to some degree. Given all of this though is Java the path forward? Looking forward I think the clear trend is microservices and beyond. Therefore the question is a lot simpler, is Java the best path forward for microservices?  How Java Became #1 Java was released in 1996. At that time the biggest issue was compiling code and porting. At this time there were many Unix, Linux, Windows flavors and many other variants. Open systems was the key initiative. Java came along and essentially offered instant portability. It created the JVM and runtime environment that would guarantee execution of code, regardless of platform, as long as there was a JRE. In one swoop, Java took away the problem of portability from developers, yay! Another thing Java did was create a language that was much more readable, easier to learn and way more modular than anything that existed previously. It was not an accident Java became the #1 and has been for so long. However Java Got Fat... Just like with anything, if you are #1 you might get complacent and sit on the couch. As Java grew over the years, it got bigger and bigger and bigger. More framework, framework to manage framework, tools to manage tools, don&#39;t get me started with Gradle and Maven. It grew and grew into the can do anything language for everything. Often frameworks were used as a crutch, code as a result became sloppy, technical debt grew, scalability was not by design and then came cloud. Things started breaking, surprise. Java has since, been trying to lose some weight, springboot and other so-called lightweight frameworks came along. By lightweight we still mean overweight and slow from microservice perspective, just maybe not fat. Microservices did indeed change the game and possibly, could be the trigger that ends Java&#39;s reign. Microservices Change the Rules With the introduction of not only microservices, but also container platforms to run microservices, the rules have changed, just like in the 90s when Java was born, under the open systems initiative.  Containers means compiling code and portability is no longer an issue. The value of a JVM is much less than it once was. Startup times and time to load code is critical in microservices. If your code is slow to load it really hampers your options and presents a lot of challenges. Microservices are mostly REST APIs that exchange data, asynchronous operations are key. Microservices require scalability and scalability generally requires concurrency. Languages that are compact, script-like, easy to write and read are preferred. Languages with simple dependency management are ideal.  At the time when Java was created none of these rules applied, it was developed to meet a totally different set of goals and challenges. Yet many Java developers go along on their merry way, trying to port their monoliths to microservices, using the same mentality that got them there? This just isn&#39;t logical. If the rules changed then clearly something else would be a wiser choice that adapts to the new game better? Thankfully there are some interesting choices. One is Golang and the other could be Quarkus. Both attempt to adhere to the new rules. Quarkus is native statically compiled Java and uses an ultra-fast JVM called Graal. It also has built-in frameworks for building microservices that help scale your code such as vertx. In this aspect it is similar to Golang. It is very lightweight and fast. I haven&#39;t seen comparison to Golang but it should be similar in this regard. Where things start to look different though is when we get into concurrency. Doing concurrency and scalability in Java is really hard and Java allows you to write bad code, there is a lot of it. Quarkus has a much tighter opinion and narrow set of tooling so that should help steer developers better than its predecessor. Asynchronous programming is also not that easy in Java, again depends on frameworks but it isn&#39;t baked-in by any means. In Golang concurrency is a feature, it is built-in and that alone should get your attention. In addition Golang is a super modern language, easy to write, easy to read, no fluff and dependency management is not stabbing your eyes out with an ice pick. Good old Java of course can still provide value and does in microservices, I am just saying it is likely not the best choice if you are starting from scratch. If I could sum it up I would say, look into Quarkus if the goal is porting Java app to microservice or building Java microservices and otherwise Golang. Of course there are many other languages as well, but none of them in my opinion apply to the challenges of today as well as Golang or Quarkus. Getting Started with Golang All the code examples are available in the following Github repository: https://github.com/ktenzer/go-hello-world. Setup your environment $ vi ~/.bashrc">


  <meta name="author" content="Keith Tenzer">
  
  <meta property="article:author" content="Keith Tenzer">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Keith Tenzer's Blog">
<meta property="og:title" content="The Coffee is Getting Cold, It’s Time to GO - Getting Started Building Microservices">
<meta property="og:url" content="https://keithtenzer.com/cloud-native/the-coffee-is-getting-cold-its-time-to-go-getting-started-building-microservice/">


  <meta property="og:description" content="Overview Java has been around a really, really long time. Certainly it continues to evolve and has evolved. Java has always been a &quot;can do anything&quot; programming language. It has more frameworks and middleware than there are stars in the sky. It is portable anywhere and of course probably 8 out of 10 developers today know Java to some degree. Given all of this though is Java the path forward? Looking forward I think the clear trend is microservices and beyond. Therefore the question is a lot simpler, is Java the best path forward for microservices?  How Java Became #1 Java was released in 1996. At that time the biggest issue was compiling code and porting. At this time there were many Unix, Linux, Windows flavors and many other variants. Open systems was the key initiative. Java came along and essentially offered instant portability. It created the JVM and runtime environment that would guarantee execution of code, regardless of platform, as long as there was a JRE. In one swoop, Java took away the problem of portability from developers, yay! Another thing Java did was create a language that was much more readable, easier to learn and way more modular than anything that existed previously. It was not an accident Java became the #1 and has been for so long. However Java Got Fat... Just like with anything, if you are #1 you might get complacent and sit on the couch. As Java grew over the years, it got bigger and bigger and bigger. More framework, framework to manage framework, tools to manage tools, don&#39;t get me started with Gradle and Maven. It grew and grew into the can do anything language for everything. Often frameworks were used as a crutch, code as a result became sloppy, technical debt grew, scalability was not by design and then came cloud. Things started breaking, surprise. Java has since, been trying to lose some weight, springboot and other so-called lightweight frameworks came along. By lightweight we still mean overweight and slow from microservice perspective, just maybe not fat. Microservices did indeed change the game and possibly, could be the trigger that ends Java&#39;s reign. Microservices Change the Rules With the introduction of not only microservices, but also container platforms to run microservices, the rules have changed, just like in the 90s when Java was born, under the open systems initiative.  Containers means compiling code and portability is no longer an issue. The value of a JVM is much less than it once was. Startup times and time to load code is critical in microservices. If your code is slow to load it really hampers your options and presents a lot of challenges. Microservices are mostly REST APIs that exchange data, asynchronous operations are key. Microservices require scalability and scalability generally requires concurrency. Languages that are compact, script-like, easy to write and read are preferred. Languages with simple dependency management are ideal.  At the time when Java was created none of these rules applied, it was developed to meet a totally different set of goals and challenges. Yet many Java developers go along on their merry way, trying to port their monoliths to microservices, using the same mentality that got them there? This just isn&#39;t logical. If the rules changed then clearly something else would be a wiser choice that adapts to the new game better? Thankfully there are some interesting choices. One is Golang and the other could be Quarkus. Both attempt to adhere to the new rules. Quarkus is native statically compiled Java and uses an ultra-fast JVM called Graal. It also has built-in frameworks for building microservices that help scale your code such as vertx. In this aspect it is similar to Golang. It is very lightweight and fast. I haven&#39;t seen comparison to Golang but it should be similar in this regard. Where things start to look different though is when we get into concurrency. Doing concurrency and scalability in Java is really hard and Java allows you to write bad code, there is a lot of it. Quarkus has a much tighter opinion and narrow set of tooling so that should help steer developers better than its predecessor. Asynchronous programming is also not that easy in Java, again depends on frameworks but it isn&#39;t baked-in by any means. In Golang concurrency is a feature, it is built-in and that alone should get your attention. In addition Golang is a super modern language, easy to write, easy to read, no fluff and dependency management is not stabbing your eyes out with an ice pick. Good old Java of course can still provide value and does in microservices, I am just saying it is likely not the best choice if you are starting from scratch. If I could sum it up I would say, look into Quarkus if the goal is porting Java app to microservice or building Java microservices and otherwise Golang. Of course there are many other languages as well, but none of them in my opinion apply to the challenges of today as well as Golang or Quarkus. Getting Started with Golang All the code examples are available in the following Github repository: https://github.com/ktenzer/go-hello-world. Setup your environment $ vi ~/.bashrc">





  <meta name="twitter:site" content="@keithtenzer">
  <meta name="twitter:title" content="The Coffee is Getting Cold, It’s Time to GO - Getting Started Building Microservices">
  <meta name="twitter:description" content="Overview Java has been around a really, really long time. Certainly it continues to evolve and has evolved. Java has always been a &quot;can do anything&quot; programming language. It has more frameworks and middleware than there are stars in the sky. It is portable anywhere and of course probably 8 out of 10 developers today know Java to some degree. Given all of this though is Java the path forward? Looking forward I think the clear trend is microservices and beyond. Therefore the question is a lot simpler, is Java the best path forward for microservices?  How Java Became #1 Java was released in 1996. At that time the biggest issue was compiling code and porting. At this time there were many Unix, Linux, Windows flavors and many other variants. Open systems was the key initiative. Java came along and essentially offered instant portability. It created the JVM and runtime environment that would guarantee execution of code, regardless of platform, as long as there was a JRE. In one swoop, Java took away the problem of portability from developers, yay! Another thing Java did was create a language that was much more readable, easier to learn and way more modular than anything that existed previously. It was not an accident Java became the #1 and has been for so long. However Java Got Fat... Just like with anything, if you are #1 you might get complacent and sit on the couch. As Java grew over the years, it got bigger and bigger and bigger. More framework, framework to manage framework, tools to manage tools, don&#39;t get me started with Gradle and Maven. It grew and grew into the can do anything language for everything. Often frameworks were used as a crutch, code as a result became sloppy, technical debt grew, scalability was not by design and then came cloud. Things started breaking, surprise. Java has since, been trying to lose some weight, springboot and other so-called lightweight frameworks came along. By lightweight we still mean overweight and slow from microservice perspective, just maybe not fat. Microservices did indeed change the game and possibly, could be the trigger that ends Java&#39;s reign. Microservices Change the Rules With the introduction of not only microservices, but also container platforms to run microservices, the rules have changed, just like in the 90s when Java was born, under the open systems initiative.  Containers means compiling code and portability is no longer an issue. The value of a JVM is much less than it once was. Startup times and time to load code is critical in microservices. If your code is slow to load it really hampers your options and presents a lot of challenges. Microservices are mostly REST APIs that exchange data, asynchronous operations are key. Microservices require scalability and scalability generally requires concurrency. Languages that are compact, script-like, easy to write and read are preferred. Languages with simple dependency management are ideal.  At the time when Java was created none of these rules applied, it was developed to meet a totally different set of goals and challenges. Yet many Java developers go along on their merry way, trying to port their monoliths to microservices, using the same mentality that got them there? This just isn&#39;t logical. If the rules changed then clearly something else would be a wiser choice that adapts to the new game better? Thankfully there are some interesting choices. One is Golang and the other could be Quarkus. Both attempt to adhere to the new rules. Quarkus is native statically compiled Java and uses an ultra-fast JVM called Graal. It also has built-in frameworks for building microservices that help scale your code such as vertx. In this aspect it is similar to Golang. It is very lightweight and fast. I haven&#39;t seen comparison to Golang but it should be similar in this regard. Where things start to look different though is when we get into concurrency. Doing concurrency and scalability in Java is really hard and Java allows you to write bad code, there is a lot of it. Quarkus has a much tighter opinion and narrow set of tooling so that should help steer developers better than its predecessor. Asynchronous programming is also not that easy in Java, again depends on frameworks but it isn&#39;t baked-in by any means. In Golang concurrency is a feature, it is built-in and that alone should get your attention. In addition Golang is a super modern language, easy to write, easy to read, no fluff and dependency management is not stabbing your eyes out with an ice pick. Good old Java of course can still provide value and does in microservices, I am just saying it is likely not the best choice if you are starting from scratch. If I could sum it up I would say, look into Quarkus if the goal is porting Java app to microservice or building Java microservices and otherwise Golang. Of course there are many other languages as well, but none of them in my opinion apply to the challenges of today as well as Golang or Quarkus. Getting Started with Golang All the code examples are available in the following Github repository: https://github.com/ktenzer/go-hello-world. Setup your environment $ vi ~/.bashrc">
  <meta name="twitter:url" content="https://keithtenzer.com/cloud-native/the-coffee-is-getting-cold-its-time-to-go-getting-started-building-microservice/">

  
    <meta name="twitter:card" content="summary">
    
  

  



  <meta property="article:published_time" content="2019-06-13T00:00:00-07:00">





  

  


<link rel="canonical" href="https://keithtenzer.com/cloud-native/the-coffee-is-getting-cold-its-time-to-go-getting-started-building-microservice/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Keith Tenzer",
      "url": "https://keithtenzer.com/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Keith Tenzer's Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Keith Tenzer's Blog
          <span class="site-subtitle">Cloud Computing and Code</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/about/index.html">About</a>
            </li><li class="masthead__menu-item">
              <a href="/conferences-and-events/index.html">Conferences and Events</a>
            </li><li class="masthead__menu-item">
              <a href="/videos/index.html">Videos</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="https://keithtenzer.com/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#cloud-native" itemprop="item"><span itemprop="name">Cloud native</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        <li class="current">The Coffee is Getting Cold, It's Time to GO - Getting Started Building Microservices</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/main/me.png" alt="Keith Tenzer" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Keith Tenzer</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Principal Solutions Architect at Red Hat</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Los Angeles, CA</span>
        </li>
      

      
        
          
        
          
        
          
            <li><a href="https://twitter.com/keithtenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span></a></li>
          
        
          
        
          
            <li><a href="https://github.com/ktenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="The Coffee is Getting Cold, It’s Time to GO - Getting Started Building Microservices">
    <meta itemprop="description" content="OverviewJava has been around a really, really long time. Certainly it continues to evolve and has evolved. Java has always been a &quot;can do anything&quot; programming language. It has more frameworks and middleware than there are stars in the sky. It is portable anywhere and of course probably 8 out of 10 developers today know Java to some degree. Given all of this though is Java the path forward?Looking forward I think the clear trend is microservices and beyond. Therefore the question is a lot simpler, is Java the best path forward for microservices?How Java Became #1Java was released in 1996. At that time the biggest issue was compiling code and porting. At this time there were many Unix, Linux, Windows flavors and many other variants. Open systems was the key initiative. Java came along and essentially offered instant portability. It created the JVM and runtime environment that would guarantee execution of code, regardless of platform, as long as there was a JRE. In one swoop, Java took away the problem of portability from developers, yay!Another thing Java did was create a language that was much more readable, easier to learn and way more modular than anything that existed previously. It was not an accident Java became the #1 and has been for so long.However Java Got Fat...Just like with anything, if you are #1 you might get complacent and sit on the couch. As Java grew over the years, it got bigger and bigger and bigger. More framework, framework to manage framework, tools to manage tools, don&#39;t get me started with Gradle and Maven. It grew and grew into the can do anything language for everything. Often frameworks were used as a crutch, code as a result became sloppy, technical debt grew, scalability was not by design and then came cloud. Things started breaking, surprise.Java has since, been trying to lose some weight, springboot and other so-called lightweight frameworks came along. By lightweight we still mean overweight and slow from microservice perspective, just maybe not fat. Microservices did indeed change the game and possibly, could be the trigger that ends Java&#39;s reign.Microservices Change the RulesWith the introduction of not only microservices, but also container platforms to run microservices, the rules have changed, just like in the 90s when Java was born, under the open systems initiative.Containers means compiling code and portability is no longer an issue. The value of a JVM is much less than it once was.Startup times and time to load code is critical in microservices. If your code is slow to load it really hampers your options and presents a lot of challenges.Microservices are mostly REST APIs that exchange data, asynchronous operations are key.Microservices require scalability and scalability generally requires concurrency.Languages that are compact, script-like, easy to write and read are preferred.Languages with simple dependency management are ideal.At the time when Java was created none of these rules applied, it was developed to meet a totally different set of goals and challenges. Yet many Java developers go along on their merry way, trying to port their monoliths to microservices, using the same mentality that got them there? This just isn&#39;t logical. If the rules changed then clearly something else would be a wiser choice that adapts to the new game better?Thankfully there are some interesting choices. One is Golang and the other could be Quarkus. Both attempt to adhere to the new rules. Quarkus is native statically compiled Java and uses an ultra-fast JVM called Graal. It also has built-in frameworks for building microservices that help scale your code such as vertx. In this aspect it is similar to Golang. It is very lightweight and fast. I haven&#39;t seen comparison to Golang but it should be similar in this regard. Where things start to look different though is when we get into concurrency.Doing concurrency and scalability in Java is really hard and Java allows you to write bad code, there is a lot of it. Quarkus has a much tighter opinion and narrow set of tooling so that should help steer developers better than its predecessor. Asynchronous programming is also not that easy in Java, again depends on frameworks but it isn&#39;t baked-in by any means. In Golang concurrency is a feature, it is built-in and that alone should get your attention. In addition Golang is a super modern language, easy to write, easy to read, no fluff and dependency management is not stabbing your eyes out with an ice pick.Good old Java of course can still provide value and does in microservices, I am just saying it is likely not the best choice if you are starting from scratch. If I could sum it up I would say, look into Quarkus if the goal is porting Java app to microservice or building Java microservices and otherwise Golang. Of course there are many other languages as well, but none of them in my opinion apply to the challenges of today as well as Golang or Quarkus.Getting Started with GolangAll the code examples are available in the following Github repository: https://github.com/ktenzer/go-hello-world.Setup your environment$ vi ~/.bashrc">
    <meta itemprop="datePublished" content="2019-06-13T00:00:00-07:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">The Coffee is Getting Cold, It’s Time to GO - Getting Started Building Microservices
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2019-06-13T00:00:00-07:00">June 13, 2019</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          16 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
        <h2><img class="alignnone  wp-image-13605" src="/assets/2019/06/golang.png" alt="golang" width="195" height="195" /><img class="alignnone  wp-image-13608" src="/assets/2019/06/verticle.png" alt="verticle" width="155" height="157" /><img class="alignnone  wp-image-13609" src="/assets/2019/06/java-1.png" alt="java" width="119" height="225" /></h2>
<h2>Overview</h2>
<p>Java has been around a really, really long time. Certainly it continues to evolve and has evolved. Java has always been a "can do anything" programming language. It has more frameworks and middleware than there are stars in the sky. It is portable anywhere and of course probably 8 out of 10 developers today know Java to some degree. Given all of this though is Java the path forward?</p>
<p>Looking forward I think the clear trend is microservices and beyond. Therefore the question is a lot simpler, is Java the best path forward for microservices?</p>
<p><!--more--></p>
<h2>How Java Became #1</h2>
<p>Java was released in 1996. At that time the biggest issue was compiling code and porting. At this time there were many Unix, Linux, Windows flavors and many other variants. Open systems was the key initiative. Java came along and essentially offered instant portability. It created the JVM and runtime environment that would guarantee execution of code, regardless of platform, as long as there was a JRE. In one swoop, Java took away the problem of portability from developers, yay!</p>
<p>Another thing Java did was create a language that was much more readable, easier to learn and way more modular than anything that existed previously. It was not an accident Java became the #1 and has been for so long.</p>
<h2>However Java Got Fat...</h2>
<p>Just like with anything, if you are #1 you might get complacent and sit on the couch. As Java grew over the years, it got bigger and bigger and bigger. More framework, framework to manage framework, tools to manage tools, don't get me started with Gradle and Maven. It grew and grew into the can do anything language for everything. Often frameworks were used as a crutch, code as a result became sloppy, technical debt grew, scalability was not by design and then came cloud. Things started breaking, surprise.</p>
<p>Java has since, been trying to lose some weight, <a href="https://spring.io/projects/spring-boot">springboot </a>and other so-called lightweight frameworks came along. By lightweight we still mean overweight and slow from microservice perspective, just maybe not fat. Microservices did indeed change the game and possibly, could be the trigger that ends Java's reign.</p>
<h2>Microservices Change the Rules</h2>
<p>With the introduction of not only microservices, but also container platforms to run microservices, the rules have changed, just like in the 90s when Java was born, under the open systems initiative.</p>
<ul>
<li>Containers means compiling code and portability is no longer an issue. The value of a JVM is much less than it once was.</li>
<li>Startup times and time to load code is critical in microservices. If your code is slow to load it really hampers your options and presents a lot of challenges.</li>
<li>Microservices are mostly REST APIs that exchange data, asynchronous operations are key.</li>
<li>Microservices require scalability and scalability generally requires concurrency.</li>
<li>Languages that are compact, script-like, easy to write and read are preferred.</li>
<li>Languages with simple dependency management are ideal.</li>
</ul>
<p>At the time when Java was created none of these rules applied, it was developed to meet a totally different set of goals and challenges. Yet many Java developers go along on their merry way, trying to port their monoliths to microservices, using the same mentality that got them there? This just isn't logical. If the rules changed then clearly something else would be a wiser choice that adapts to the new game better?</p>
<p>Thankfully there are some interesting choices. One is <a href="https://golang.org">Golang </a>and the other could be <a href="https://quarkus.io/">Quarkus</a>. Both attempt to adhere to the new rules. Quarkus is native statically compiled Java and uses an ultra-fast JVM called Graal. It also has built-in frameworks for building microservices that help scale your code such as vertx. In this aspect it is similar to Golang. It is very lightweight and fast. I haven't seen comparison to Golang but it should be similar in this regard. Where things start to look different though is when we get into concurrency.</p>
<p>Doing concurrency and scalability in Java is really hard and Java allows you to write bad code, there is a lot of it. Quarkus has a much tighter opinion and narrow set of tooling so that should help steer developers better than its predecessor. Asynchronous programming is also not that easy in Java, again depends on frameworks but it isn't baked-in by any means. In Golang concurrency is a feature, it is built-in and that alone should get your attention. In addition Golang is a super modern language, easy to write, easy to read, no fluff and dependency management is not stabbing your eyes out with an ice pick.</p>
<p>Good old Java of course can still provide value and does in microservices, I am just saying it is likely not the best choice if you are starting from scratch. If I could sum it up I would say, look into Quarkus if the goal is porting Java app to microservice or building Java microservices and otherwise Golang. Of course there are many other languages as well, but none of them in my opinion apply to the challenges of today as well as Golang or Quarkus.</p>
<h2>Getting Started with Golang</h2>
<p>All the code examples are available in the following Github repository: <a href="https://github.com/ktenzer/go-hello-world">https://github.com/ktenzer/go-hello-world</a>.</p>
<h4>Setup your environment</h4>
<pre>$ vi ~/.bashrc

# User specific aliases and functions
export GOPATH=/home/ktenzer/go
export GOBIN=/home/ktenzer
PATH=$PATH:$GOBIN</pre>
<h4>Create go directory</h4>
<pre>$ mkdir -p /home/ktenzer/go/src</pre>
<h4>Install Go</h4>
<pre>$ sudo dnfs install -y go</pre>
<p>Optionally you can install manually as well <a href="https://golang.org/doc/install">https://golang.org/doc/install</a></p>
<h4>Clone Git Repo</h4>
<pre>$ git clone &lt;repo url&gt; /home/ktenzer/go/src</pre>
<h4>Create src and vendor directories in repo</h4>
<pre>$ mkdir -p /home/ktenzer/go/src/&lt;repo&gt;/src
$ mkdir -p /home/ktenzer/go/src/&lt;repo&gt;/vendor</pre>
<h4>Install Dependency Management Tool</h4>
<p>You will want to use other frameworks and tools. The dependency management tool I would recommend is called <a href="https://github.com/golang/dep">dep</a>.</p>
<pre>$ curl https://raw.githubusercontent.com/golang/dep/master/install.sh <span class="pl-k">|</span> sh</pre>
<h4>Initialize Dep</h4>
<pre>$ cd /home/ktenzer/go/src/&lt;repo&gt;
$ dep init</pre>
<h4>Add dependencies</h4>
<pre>$ dep ensure --add <span style="color:var(--color-text);">github.com/gorilla/mux</span></pre>
<p>This will add the dependency and version to Gopkg.toml file automatically.</p>
<pre>[[constraint]]
name = "github.com/gorilla/mux"
version = "1.7.2"</pre>
<h2>Creating First Microservice</h2>
<p>As mentioned concurrency is built-in, one of the great advantages of Golang for microservices. As such the net/http module already has concurrency, no extra code needed. The only thing that needs to be deciding upon is what to you for URL routing? There are several Frameworks: Gorilla, Gin, Chi, etc. There are of course lots of pros and cons. Some route URLs faster while others have more capabilities. Personally I like Gorilla, it isn't the fastest but I like it's utility.</p>
<p>In this microservice we will run a concurrent http service that responds to a status API route with a message and a version. We will output JSON.</p>
<h4>Main.go</h4>
<p>In the main.go we will simply intantiate a new URL router and configure http service to listen on port 8000 and implement our router.</p>
<div>
<pre>package main


import (

    "log"

    "net/http"
)

func main() {

    router := NewRouter()

    log.Fatal(http.ListenAndServe(":8000", router))
}</pre>
</div>
<h4>Routes.go</h4>
<p>In the routes we obviously configure API endpoints and routing. Here we have a single endpoint "/status". Calls sent to the /status endpoint will be handled or routed to our GetStatusEndpoint function.</p>
<p>In addition we create a new router object with our configuration. Each route incoming route is processed, checked if it exists and if so the route is logged and a handler function is called.</p>
<pre>package main

import (
    "github.com/gorilla/mux"
    "net/http"
)

type Route struct {
    Name string
    Method string
    Pattern string
    HandlerFunc http.HandlerFunc

}

type Routes []Route
func NewRouter() *mux.Router {
    router := mux.NewRouter().StrictSlash(true)
    for _, route := range routes {
        var handler http.Handler
        handler = route.HandlerFunc
        handler = LogApi(handler, route.Name)
        router.
            Methods(route.Method).
            Path(route.Pattern).
            Name(route.Name).
            Handler(handler)
    }

    return router

}

var routes = Routes{
    Route{
        "GetStatusEndpoint",
        "GET",
        "/status",
        GetStatusEndpoint,
    },
}</pre>
<h4>Handlers.go</h4>
<p>The handers are where we want to implement our API. In this case we just set our status struct and return it as json using the json encoder.</p>
<div>
<pre>package main

import (
    "encoding/json"
    "net/http"
)

func GetStatusEndpoint(w http.ResponseWriter, r *http.Request) {
    var status Status
    status.Msg = "Hello World"
    status.Version = "1.0.0"
    json.NewEncoder(w).Encode(status)
}</pre>
</div>
<h4>Logger.go</h4>
<p>Each incoming URL is logged, this is called in the routes.go, this is just the implementation for that function.</p>
<pre>package main
import (
    "log"
    "net/http"
    "time"
)

func LogApi(handler http.Handler, apiRoute string) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        startTime := time.Now()
        handler.ServeHTTP(w, r)
        log.Printf(
            "%s\t%s\t%s\t%s",
            r.Method,
            r.RequestURI,
            apiRoute,
            time.Since(startTime),
        )
    })
}</pre>
<h4>Status.go</h4>
<p>A struct to store status of service, nothing more to say.</p>
<div>
<pre>package main

type Status struct {
    Msg string `json:"msg"`
    Version string `json:"version"`
}</pre>
</div>
<h4>Compiling the code</h4>
<p>Compiling code in Golang is really easy, just run go.</p>
<pre>$ go install go-hello-world/src/hello</pre>
<p>The binary will be called hello and exist in the $GOBIN directory, in this case /home/ktenzer.</p>
<h4>Running the code</h4>
<p>Since Golang produces a binary you simply execute it.</p>
<pre>$ /home/ktenzer/hello</pre>
<p>Using curl we can hit our /status API endpoint.</p>
<pre>$ curl http://localhost:8080/status
{"msg":"Hello World","version":"1.0.0"}</pre>
<h4>Check hello service</h4>
<p>Since we log API requests you should see a message printed to stdout.</p>
<pre>$ /home/ktenzer/hello
2019/06/13 13:13:11 GET /status GetStatusEndpoint 58.842µs</pre>
<p>Also very interesting is the time the API took to process, in this case 58.842 micro-seconds. As mentioned Gorilla isn't one of the faster URL routers either.</p>
<h2>Summary</h2>
<p>In this article we have discussed some of the history of Java. We talked about how the rules are changing for microservices, why Golang or Quarkus may be a better choice than standard Java for concurrent, asynchronous microservices and both could very likely become languages of choice in the microservice space. Finally we went through a hello-world implementation of a microservice written in Golang. This should give you a good idea of how to get started using Golang. Feedback is always welcome.</p>
<p>(c) 2019 Keith Tenzer</p>
<p>&nbsp;</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#code" class="page__taxonomy-item" rel="tag">code</a><span class="sep">, </span>
    
      <a href="/tags/#concurrency" class="page__taxonomy-item" rel="tag">concurrency</a><span class="sep">, </span>
    
      <a href="/tags/#containers" class="page__taxonomy-item" rel="tag">Containers</a><span class="sep">, </span>
    
      <a href="/tags/#golang" class="page__taxonomy-item" rel="tag">Golang</a><span class="sep">, </span>
    
      <a href="/tags/#kubernetes" class="page__taxonomy-item" rel="tag">Kubernetes</a><span class="sep">, </span>
    
      <a href="/tags/#microservice" class="page__taxonomy-item" rel="tag">microservice</a><span class="sep">, </span>
    
      <a href="/tags/#openshift" class="page__taxonomy-item" rel="tag">OpenShift</a><span class="sep">, </span>
    
      <a href="/tags/#quarkus" class="page__taxonomy-item" rel="tag">Quarkus</a><span class="sep">, </span>
    
      <a href="/tags/#scalability" class="page__taxonomy-item" rel="tag">scalability</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#cloud-native" class="page__taxonomy-item" rel="tag">cloud-native</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2019-06-13T00:00:00-07:00">June 13, 2019</time></p>


      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=keithtenzer&text=The+Coffee+is+Getting+Cold%2C+It%27s+Time+to+GO+-+Getting+Started+Building+Microservices%20https%3A%2F%2Fkeithtenzer.com%2Fcloud-native%2Fthe-coffee-is-getting-cold-its-time-to-go-getting-started-building-microservice%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fkeithtenzer.com%2Fcloud-native%2Fthe-coffee-is-getting-cold-its-time-to-go-getting-started-building-microservice%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fkeithtenzer.com%2Fcloud-native%2Fthe-coffee-is-getting-cold-its-time-to-go-getting-started-building-microservice%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/openshift/container-native-virtualization-kubevirt-the-future-for-virtual-machines-is-here/" class="pagination--pager" title="Container Native Virtualization (Kubevirt): The Future for Virtual Machines is Here!
">Previous</a>
    
    
      <a href="/code/powerful-but-simple-ci-cd-with-azure-devops-and-go/" class="pagination--pager" title="Powerful but Simple CI/CD with Azure DevOps and Go
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/openshift/building-ansible-operators-1-2-3/" rel="permalink">Building Ansible Operators 1-2-3
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-12-03T00:00:00-08:00">December 3, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          9 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Overview
In this article we will go step by step in build a Kubernetes Operator using Ansible and the Operator Framework. Operators provide ability to not on...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/openshift/openshift-service-mesh-getting-started-guide/" rel="permalink">OpenShift Service Mesh Getting Started Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-04-27T00:00:00-07:00">April 27, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          11 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">






Overview
In this article we will explore the OpenShift Service Mesh and deploy a demo application to better understand the various concepts. First you...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/openshift/openshift-4-aws-ipi-installation-getting-started-guide/" rel="permalink">OpenShift 4 AWS IPI Installation Getting Started Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-01-18T00:00:00-08:00">January 18, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          8 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">


Happy new year as this will be the first post of 2021! 2020 was obviously a challenging year, my hope is I will have more time to devote to blogging in 20...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ansible/windows-automation-with-ansible-getting-started-guide/" rel="permalink">Windows Automation with Ansible: Getting Started Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2020-05-19T00:00:00-07:00">May 19, 2020</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          14 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
Overview
In this article we will focus on how to get started with automation of windows using Ansible. Specifically we will look at installing 3rd party sof...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://twitter.com/keithtenzer"" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
      
        
          <li><a href="https://github.com/ktenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 Keith Tenzer. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
