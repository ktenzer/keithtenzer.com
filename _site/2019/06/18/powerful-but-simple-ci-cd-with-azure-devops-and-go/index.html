<h2><img class="alignnone  wp-image-13703" src="/assets/2019/06/azuredevops-2x.png" alt="azuredevops-2x" width="506" height="92" /></h2>
<h2>Overview</h2>
<p>Microsoft has wasted little time getting value out of their GitHub acquisition. They have now fully integrated GitHub and authentication into an already powerful DevOps platform called "Azure DevOps". I have until this moment had zero enjoyment, setting up and maintaining CI/CD tooling usually involving some form of our dear butler, Jenkins. Nothing wrong with our old Jenkins but let's face it, he is just overhead at this point, better to just put him to rest, he has earned it.</p>
<p>Azure DevOps has the following value:</p>
<ul>
<li>It's in the cloud, consumed as-a-service</li>
<li>Completely Integrated with GitHub</li>
<li>It is free</li>
<li>Authentication using GitHub user</li>
<li>Don't need to use it with Azure</li>
<li>Supports basically every language, I am doing CI/CD with Go</li>
<li>Simple yaml to configure no Groovy/DML Jenkins horror</li>
<li>Yaml pipeline files auto-generated for your language (just needs minor tweaks)</li>
<li>Your code is built, unit tests are run, you can do acceptance tests and it is setup in a few minutes</li>
</ul>
<p><!--more--></p>
<h2>Getting Started with Go</h2>
<h4>Sign-up</h4>
<p>I simply used my GitHub account: <a href="https://azure.microsoft.com/en-in/services/devops/">https://azure.microsoft.com/en-in/services/devops/</a></p>
<h4>Create Project</h4>
<p>You can create a private or public project.</p>
<p><img class="alignnone  wp-image-13687" src="/assets/2019/06/azure-devops-1.png" alt="azure-devops-1" width="763" height="648" /></p>
<h4>Select Source Control Management</h4>
<p>I am using GitHub.</p>
<p><img class="alignnone  wp-image-13688" src="/assets/2019/06/azure-devops-2.png" alt="azure-devops-2" width="762" height="546" /></p>
<h4>Select Repository</h4>
<p>In this case I am using ktenzer/go-hello-world</p>
<p><img class="alignnone  wp-image-13689" src="/assets/2019/06/azure-devops-3.png" alt="azure-devops-3" width="746" height="430" /></p>
<h4>Configure Pipeline</h4>
<p>Azure DevOps generates a base pipeline so it is really easy to tweak things. In the case of Go, hopefully you are using dep for dependency management. Due to your source tree structure and using dep or other tools you may need to tweak a few things. You can view my source tree at <a href="https://github.com/ktenzer/go-hello-world">https://github.com/ktenzer/go-hello-world.</a></p>
<pre># Go
# Build your Go project.
# Add steps that test, save build artifacts, deploy, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/go

trigger:
- master
- feature/*

pr:
- master

pool:
  vmImage: 'ubuntu-latest'

variables:  
  GOPATH: '$(system.defaultWorkingDirectory)/gopath' # Go workspace path
  GOBIN:  '$(GOPATH)/bin' # Go binaries path
  PLUGIN_DIR: '$(GOBIN)'
  modulePath: '$(GOPATH)/src/hello' # Path to the module's code

steps:
- script: |
    echo "GOBIN $(GOBIN)"
    echo "GOPATH $(GOPATH)"
    echo "REPO PATH $(GOPATH)/src/github.com/$(build.repository.name)"

    mkdir -p '$(GOPATH)'
    mkdir -p '$(GOBIN)'
    mkdir -p '$(GOPATH)/pkg'
    mkdir -p '$(modulePath)'
    echo "Moving $(system.defaultWorkingDirectory)/* To $(modulePath)"
    mv $(system.defaultWorkingDirectory)/* $(modulePath)
    shopt -s extglob
    shopt -s dotglob
    echo '##vso[task.prependpath]$(GOBIN)'
    echo '##vso[task.prependpath]$(GOROOT)/bin'
  displayName: 'Set up the Go workspace'

- script: |
    go version
    if [ -f Gopkg.toml ]; then
        curl https://raw.githubusercontent.com/golang/dep/master/install.sh | sh
        dep ensure
    else
      echo "ERROR no Gopkg.toml found!"
      exit 1
    fi
    go install hello/src/hello
  workingDirectory: '$(GOPATH)/src/hello'
  displayName: 'Get dependencies, then build'

- script: |
    $(GOBIN)/hello &amp;
    PS=`ps -ef |grep hello |grep -v grep |awk '{print $2}'`
    echo "hello $PS"
    curl http://localhost:8000/status
    kill -9 $PS
</pre>
<p>The trigger will always run pipeline for every new commit. The pr will force all pull requests (in this case in feature branch) to go through pipeline and validation. This allows someone else to review the changes before merging into master.</p>
<p>In addition to building the code using dep I am providing and example of a simple acceptance test for this service using curl to send API response.</p>
<p>Since you essentially have a bash interface through the "script" module you can really do anything and do so very easily.</p>
<h4>Save Pipeline</h4>
<p>The pipeline yaml file is stored directly in the Github repository.</p>
<p><img class="alignnone  wp-image-13692" src="/assets/2019/06/azure-devops-5.png" alt="azure-devops-5" width="567" height="554" /></p>
<p>Once pipeline is committed it is started. From now on any code change or update to the Repository will cause the pipeline to run.</p>
<p><img class="alignnone  wp-image-13691" src="/assets/2019/06/azure-devops-4.png" alt="azure-devops-4" width="873" height="696" /></p>
<p>Each pipeline step is shown and you can drill in to see details. Makes it really easy to troubleshoot especially since you can use bash commands like echo to see variables or paths.</p>
<p>Drilling into the Cmdline step we see our acceptance test execute.</p>
<p><img class="alignnone  wp-image-13695" src="/assets/2019/06/azure-devops-6-2.png" alt="azure-devops-6" width="967" height="391" /></p>
<h4>CI/CD Demo</h4>
<p>Now that we can successfully build our code using Azure DevOps it is time to see it in action. I recommend doing all work in a feature branch and then a pull request from that. In this case we will commit bad code that breaks the build and fix it. A common CI/CD lifecycle without of course jeopardizing the master branch.</p>
<p>First we commit broken code via a pull request. We can see the pipeline is running.</p>
<p><img class="alignnone  wp-image-13717" src="/assets/2019/06/pull2.png" alt="pull2" width="2842" height="372" /></p>
<p>The pipeline failed and updated the commit request in the feature branch.</p>
<p><img class="alignnone  wp-image-13722" src="/assets/2019/06/pull3.png" alt="pull3" width="3710" height="502" /></p>
<p>More details on the failed commit.</p>
<p><img class="alignnone  wp-image-13723" src="/assets/2019/06/pull4.png" alt="pull4" width="1439" height="493" /></p>
<p>Next we will fix the broken code. Again pipeline runs but this time it is successful.</p>
<p><img class="alignnone  wp-image-13724" src="/assets/2019/06/pull5.png" alt="pull5" width="2391" height="320" /></p>
<p>Finally the code can be merged to the master branch.</p>
<p><img class="alignnone  wp-image-13725" src="/assets/2019/06/pull6.png" alt="pull6" width="2057" height="614" /></p>
<p>Looking at Azure DevOps we can also see both of the pipeline runs and notice the icon for a branch.</p>
<p><img class="alignnone  wp-image-13726" src="/assets/2019/06/pull1.png" alt="pull1" width="2872" height="397" /></p>
<p>That is how easy CI/CD can be!</p>
<h2>Summary</h2>
<p>In this article we discussed Azure DevOps and it's value for offloading CI/CD to the cloud. We also saw a hands-on tutorial to get Azure Devops up and running with Go.  Many organizations already use GitHub private and public, in my view, this is just the next logical step. Why maintain CI/CD infrastructure and deal with the complexities on-premise? I must say I was very surprised at the quality and ease of Azure DevOps. It took a friend of mine quite some time to convince me to try it but I finally did and am not looking back.</p>
<p>Happy CI/CD'ing!</p>
<p>(c) 2019 Keith Tenzer</p>
