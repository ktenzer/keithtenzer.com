<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
<link rel="icon" href="/assets/main/me.png">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Container Native Virtualization (Kubevirt): The Future for Virtual Machines is Here! - Keith Tenzer’s Blog</title>
<meta name="description" content="Overview Immediately after Solomon Hykes first showed Docker to the public at PyCon in 2013, in his now famous &quot;docker run demo&quot;, IT folk started asking, what does this mean for virtualization? We only spent the previous 10-15 years virtualizing, seemingly everything, so understandably people were slightly apprehensive. Industries had been built and careers established, clearly virtualization would be an important part of the future and not simply replaced, right? In this article we will aim to understand the value of virtualization in a container-driven world, explore the current virtualization capabilities in Kubernetes and get started with Container Native Virtualization (Kubevirt) using Red Hat&#39;s Kubernetes enterprise distribution, OpenShift.  The Value of Virtualization in a Container-Driven World If we think about the real value of virtualization as a game changer, it is the ability to abstract hardware from the operating system. Everything else such as isolation, manageability, efficiency, etc are all features. Basically a virtualization platform is a hardware agnostic scheduler for operating systems. Looking at the value containers provide, it is as an abstraction between applications and operating system. Everything else such as multi-cloud, portability, speed, agility, deployment strategies, etc are all features. In the end both Virtualization and Containerization are doing basically one thing and that is providing an abstraction layer. The only difference is where the abstraction occurs. For Virtualization it is the operating system, while for containers it is the application. Clearly without a doubt we need both. That is not the question. The question is do we need both in separate platforms, or can it all be collapsed and if so what are the advantages? I think ultimately a single platform will emerge that provides both virtualization as well as containers and that platform already exists today, Kubernetes. There is a huge amount of overlap with what a virtualization platform is doings vs that of a container platform like Kubernetes. Scheduling, monitoring, quotas, RBAC, integration with compute, network, storage, HA and so on. In addition you need separate teams and operations processes to run various platforms so there is a lot of running costs that can be avoided. It makes zero sense to continue down the path of multiple platforms. Bringing Virtualization to Kubernetes The upstream project working on bringing virtualization to Kubernetes is called Kubevirt. Kubernetes is a perfect platform for virtual machines. Kubernetes already has a lot more intelligence that any virtualization platform ever had or will. It has built-in a framework called the Operator Framework. An operator is essentially a way to package, manage and most importantly operate Kubernetes native applications. The operate part is what allows us to build intelligence into how processes or even events should be automatically handled for a specific application. Taking a step back, what is an application? Basically a program that runs on the operating system. Virtualization is by definition an application. The operator framework is used to provide an operator for running virtualization on Kubernetes because in fact, a virtual machine is just an application. Today you are already able to run virtual machines on Kubernetes and it is even technology preview in Red Hat&#39;s enterprise Kubernetes platform, OpenShift. Kubevirt works essentially by running libvirt (KVM) in a container. Libvirt is the process running virtual machines and supports the qcow2 image format. The only real difference is now, Libvirt runs in a container and can be controlled, scheduled as well as managed via Kubernetes. This truly brings both worlds together.  Kubevirt has come a long way in a relatively short period of time. Still some gaps do exists and there is more work to be done in area of HA, live migration and dynamic resource sharing. Kubernetes and specifically cloud-native, where Kubernetes started has a different view on HA. Getting the virtualization primitives complete will take some time but it is happening and the operator framework is a key piece. Getting Started with Kubevirt In this example I am using OpenShift but this will work the same on Kubernetes. OpenShift is enterprise-grade Kubernetes plus a lot of additional things. Instead of &quot;oc&quot; cli command you would substitute that with the &quot;kubectl&quot; command. Keep in mind that for OpenShift Kubevirt is still technology preview. Setup permissions The Virtualization control plane needs additional permissions in it&#39;s namespace. By default OpenShift is very restrictive and SELinux prevents such access rights. $ oc adm policy add-scc-to-user privileged -n kube-system \ -z kubevirt-privileged $ oc adm policy add-scc-to-user privileged -n kube-system \ -z kubevirt-controller $ oc adm policy add-scc-to-user privileged -n kube-system \ -z kubevirt-apiserver Deploy Kubevirt components These components are part of the control plane and facilitate communications to virtual machines as well as enable their primitives. $ RELEASE=v0.11.0 $ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yam $ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yam $ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yaml $ curl -O -L https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/virtctl-${RELEASE}-linux-amd64 Install Virtctl Client Virtctl provides a CLI utility to interact with virtualk machines. $ sudo mv virtctl-${RELEASE}-linux-amd64 /usr/local/bin/virtctl $ sudo chmod +x /usr/local/bin/virtctl Configure Container Data Importer The cdi services allows for importing virtual machines. This is also optional. $ oc adm policy add-scc-to-user privileged -z cdi-sa $ VERSION=v1.4.1 $ oc create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml $ oc apply create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml $ oc create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml Verify Kubevirt Deployment The Kubevirt pods are marked in bold. $ oc get pods -n kube-system NAME READY STATUS RESTARTS AGE cdi-api-5c69fdb6db-6bknl 1/1 Running 0 6d cdi-api-5c69fdb6db-dl95k 0/1 Evicted 0 6d cdi-api-5c69fdb6db-gp5mv 0/1 Evicted 0 16d cdi-api-5c69fdb6db-mwwxs 0/1 Evicted 0 6d cdi-deployment-5fddc58c4d-mxpsn 1/1 Running 9 28d cdi-uploadproxy-85b8ff4884-x4kp2 1/1 Running 2 28d master-api-master0 1/1 Running 241 36d master-api-master1 1/1 Running 237 36d master-api-master2 1/1 Running 243 36d master-controllers-master0 1/1 Running 233 36d master-controllers-master1 1/1 Running 231 36d master-controllers-master2 1/1 Running 221 36d master-etcd-master0 1/1 Running 2495 36d master-etcd-master1 1/1 Running 2482 36d master-etcd-master2 1/1 Running 2489 36d virt-api-5cf4576cc8-br65d 1/1 Running 0 2h virt-api-5cf4576cc8-mpzrl 1/1 Unknown 1 28d virt-api-5cf4576cc8-qq5k6 1/1 Running 0 15d virt-api-5cf4576cc8-w7wk6 0/1 Evicted 0 26d virt-controller-5cdd99564c-9x2mr 1/1 Running 25 28d virt-controller-5cdd99564c-hsp6k 1/1 Running 0 26d virt-handler-67xjk 1/1 NodeLost 1 28d virt-handler-hhd2s 1/1 Running 1 28d virt-handler-rhvpp 1/1 Running 2 28d Check Services, Kubevirt services are marked in bold. $ oc get service -n kube-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE cdi-api ClusterIP 172.30.219.181 &lt;none&gt; 443/TCP 28d cdi-uploadproxy ClusterIP 172.30.136.133 &lt;none&gt; 443/TCP 28d kube-controllers ClusterIP None &lt;none&gt; 8444/TCP 36d kubelet ClusterIP None &lt;none&gt; 10250/TCP 36d kubevirt-prometheus-metrics ClusterIP 172.30.69.165 &lt;none&gt; 443/TCP 28d virt-api ClusterIP 172.30.76.176 &lt;none&gt; 443/TCP 28d Configure Kubevirt UI This is optional but I personally find the UI very nice from user experience point-of-view. $ oc new-project kubevirt-web-ui $ git clone https://github.com/kubevirt/web-ui-operator.git $ cd web-ui-operator/ $ oc apply -f deploy/service_account.yaml $ oc adm policy add-scc-to-user anyuid -z kubevirt-web-ui-operator $ oc apply -f deploy/service_account.yaml -n kubevirt-web-ui $ oc adm policy add-scc-to-user anyuid -z kubevirt-web-ui-operator $ oc apply -f deploy/role.yaml $ oc apply -f deploy/role_extra_for_console.yaml $ oc apply -f deploy/role_binding.yaml $ oc apply -f deploy/role_binding_extra_for_console.yaml $ oc apply -f deploy/crds/kubevirt_v1alpha1_kwebui_crd.yaml $ oc apply -f deploy/operator.yaml $ oc apply -f deploy/crds/kubevirt_v1alpha1_kwebui_cr.yaml Verify Kubevirt UI Deployment Verify pods. $ oc get pods -n kubevirt-web-ui NAME READY STATUS RESTARTS AGE console-6b66b66dd7-9gdvn 1/1 Unknown 1 28d console-6b66b66dd7-wwxm8 1/1 Running 0 15d kubevirt-web-ui-operator-6dd9547864-f5t49 0/1 Running 0 15d kubevirt-web-ui-operator-6dd9547864-n8fxd 1/1 Unknown 1 26d Verify services. $ oc get services -n kubevirt-web-ui NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE console ClusterIP 172.30.124.253 &lt;none&gt; 443/TCP 28d Verify routes. $ oc get routes -n kubevirt-web-ui NAME HOST/PORT PATH SERVICES PORT TERMINATION WILDCARD console kubevirt-web-ui.apps.46.4.207.246.xip.io console https reencrypt/Redirect None Connect to Kubevirt UI Using web browser enter the route, in this case https://kubevirt-web-ui.apps.46.4.207.246.xip.io. You will be prompted to login using OpenShift credentials. Deploying a Virtual Machine In this example we will be using a template to deploy a virtual machine. Create Project (namespace) for Virtual Machines  Using CLI to create new project $ oc create project vms Deploy Virtual Machine Template First login to the Kubevirt UI. You can either list routes as we did above for the project or look in OpenShift UI as is shown below.  The Kubevirt UI also shows overall status of the cluster. This is to provide an admin single-pane-of-glass regardless of containers or virtual machines.  Select virtual machines and create virtual machine from template.  Enter the yaml which is available in github.  Select create to deploy virtual machine template. Using CLI to deploy virtual machine template. $ oc create -f https://raw.githubusercontent.com/kubevirt/demo/master/manifests/vm.yaml Note: this template will deploy virtual machine in default project. You can change that by setting &quot;namespace&quot; to something else in the metadata section of template. Start Virtual Machine Once template is deployed you should be able to start the virtual machine.  That is it, pretty easy and amazing how well virtual machines are already integrated into Kubernetes and OpenShift. The best is yet to come! Summary In this article we discussed the value of virtualization and containers, together is better and clearly the way forward. We examined the value of collapsing platforms to have a single platform to drive both container and virtual machine workloads. We looked at where Container Native Virtualization (Kubevirt) is at today and explained some of the gaps versus traditional virtualization. Finally we walked through a hands-on guide to get Container Native Virtualization (Kubevirt) up and running on Kubernetes or OpenShift. Happy Containers and Virtual Machines Existing Together! (c) 2018 Keith Tenzer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;">


  <meta name="author" content="Keith Tenzer">
  
  <meta property="article:author" content="Keith Tenzer">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Keith Tenzer's Blog">
<meta property="og:title" content="Container Native Virtualization (Kubevirt): The Future for Virtual Machines is Here!">
<meta property="og:url" content="https://keithtenzer.com/openshift/container-native-virtualization-kubevirt-the-future-for-virtual-machines-is-here/">


  <meta property="og:description" content="Overview Immediately after Solomon Hykes first showed Docker to the public at PyCon in 2013, in his now famous &quot;docker run demo&quot;, IT folk started asking, what does this mean for virtualization? We only spent the previous 10-15 years virtualizing, seemingly everything, so understandably people were slightly apprehensive. Industries had been built and careers established, clearly virtualization would be an important part of the future and not simply replaced, right? In this article we will aim to understand the value of virtualization in a container-driven world, explore the current virtualization capabilities in Kubernetes and get started with Container Native Virtualization (Kubevirt) using Red Hat&#39;s Kubernetes enterprise distribution, OpenShift.  The Value of Virtualization in a Container-Driven World If we think about the real value of virtualization as a game changer, it is the ability to abstract hardware from the operating system. Everything else such as isolation, manageability, efficiency, etc are all features. Basically a virtualization platform is a hardware agnostic scheduler for operating systems. Looking at the value containers provide, it is as an abstraction between applications and operating system. Everything else such as multi-cloud, portability, speed, agility, deployment strategies, etc are all features. In the end both Virtualization and Containerization are doing basically one thing and that is providing an abstraction layer. The only difference is where the abstraction occurs. For Virtualization it is the operating system, while for containers it is the application. Clearly without a doubt we need both. That is not the question. The question is do we need both in separate platforms, or can it all be collapsed and if so what are the advantages? I think ultimately a single platform will emerge that provides both virtualization as well as containers and that platform already exists today, Kubernetes. There is a huge amount of overlap with what a virtualization platform is doings vs that of a container platform like Kubernetes. Scheduling, monitoring, quotas, RBAC, integration with compute, network, storage, HA and so on. In addition you need separate teams and operations processes to run various platforms so there is a lot of running costs that can be avoided. It makes zero sense to continue down the path of multiple platforms. Bringing Virtualization to Kubernetes The upstream project working on bringing virtualization to Kubernetes is called Kubevirt. Kubernetes is a perfect platform for virtual machines. Kubernetes already has a lot more intelligence that any virtualization platform ever had or will. It has built-in a framework called the Operator Framework. An operator is essentially a way to package, manage and most importantly operate Kubernetes native applications. The operate part is what allows us to build intelligence into how processes or even events should be automatically handled for a specific application. Taking a step back, what is an application? Basically a program that runs on the operating system. Virtualization is by definition an application. The operator framework is used to provide an operator for running virtualization on Kubernetes because in fact, a virtual machine is just an application. Today you are already able to run virtual machines on Kubernetes and it is even technology preview in Red Hat&#39;s enterprise Kubernetes platform, OpenShift. Kubevirt works essentially by running libvirt (KVM) in a container. Libvirt is the process running virtual machines and supports the qcow2 image format. The only real difference is now, Libvirt runs in a container and can be controlled, scheduled as well as managed via Kubernetes. This truly brings both worlds together.  Kubevirt has come a long way in a relatively short period of time. Still some gaps do exists and there is more work to be done in area of HA, live migration and dynamic resource sharing. Kubernetes and specifically cloud-native, where Kubernetes started has a different view on HA. Getting the virtualization primitives complete will take some time but it is happening and the operator framework is a key piece. Getting Started with Kubevirt In this example I am using OpenShift but this will work the same on Kubernetes. OpenShift is enterprise-grade Kubernetes plus a lot of additional things. Instead of &quot;oc&quot; cli command you would substitute that with the &quot;kubectl&quot; command. Keep in mind that for OpenShift Kubevirt is still technology preview. Setup permissions The Virtualization control plane needs additional permissions in it&#39;s namespace. By default OpenShift is very restrictive and SELinux prevents such access rights. $ oc adm policy add-scc-to-user privileged -n kube-system \ -z kubevirt-privileged $ oc adm policy add-scc-to-user privileged -n kube-system \ -z kubevirt-controller $ oc adm policy add-scc-to-user privileged -n kube-system \ -z kubevirt-apiserver Deploy Kubevirt components These components are part of the control plane and facilitate communications to virtual machines as well as enable their primitives. $ RELEASE=v0.11.0 $ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yam $ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yam $ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yaml $ curl -O -L https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/virtctl-${RELEASE}-linux-amd64 Install Virtctl Client Virtctl provides a CLI utility to interact with virtualk machines. $ sudo mv virtctl-${RELEASE}-linux-amd64 /usr/local/bin/virtctl $ sudo chmod +x /usr/local/bin/virtctl Configure Container Data Importer The cdi services allows for importing virtual machines. This is also optional. $ oc adm policy add-scc-to-user privileged -z cdi-sa $ VERSION=v1.4.1 $ oc create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml $ oc apply create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml $ oc create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml Verify Kubevirt Deployment The Kubevirt pods are marked in bold. $ oc get pods -n kube-system NAME READY STATUS RESTARTS AGE cdi-api-5c69fdb6db-6bknl 1/1 Running 0 6d cdi-api-5c69fdb6db-dl95k 0/1 Evicted 0 6d cdi-api-5c69fdb6db-gp5mv 0/1 Evicted 0 16d cdi-api-5c69fdb6db-mwwxs 0/1 Evicted 0 6d cdi-deployment-5fddc58c4d-mxpsn 1/1 Running 9 28d cdi-uploadproxy-85b8ff4884-x4kp2 1/1 Running 2 28d master-api-master0 1/1 Running 241 36d master-api-master1 1/1 Running 237 36d master-api-master2 1/1 Running 243 36d master-controllers-master0 1/1 Running 233 36d master-controllers-master1 1/1 Running 231 36d master-controllers-master2 1/1 Running 221 36d master-etcd-master0 1/1 Running 2495 36d master-etcd-master1 1/1 Running 2482 36d master-etcd-master2 1/1 Running 2489 36d virt-api-5cf4576cc8-br65d 1/1 Running 0 2h virt-api-5cf4576cc8-mpzrl 1/1 Unknown 1 28d virt-api-5cf4576cc8-qq5k6 1/1 Running 0 15d virt-api-5cf4576cc8-w7wk6 0/1 Evicted 0 26d virt-controller-5cdd99564c-9x2mr 1/1 Running 25 28d virt-controller-5cdd99564c-hsp6k 1/1 Running 0 26d virt-handler-67xjk 1/1 NodeLost 1 28d virt-handler-hhd2s 1/1 Running 1 28d virt-handler-rhvpp 1/1 Running 2 28d Check Services, Kubevirt services are marked in bold. $ oc get service -n kube-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE cdi-api ClusterIP 172.30.219.181 &lt;none&gt; 443/TCP 28d cdi-uploadproxy ClusterIP 172.30.136.133 &lt;none&gt; 443/TCP 28d kube-controllers ClusterIP None &lt;none&gt; 8444/TCP 36d kubelet ClusterIP None &lt;none&gt; 10250/TCP 36d kubevirt-prometheus-metrics ClusterIP 172.30.69.165 &lt;none&gt; 443/TCP 28d virt-api ClusterIP 172.30.76.176 &lt;none&gt; 443/TCP 28d Configure Kubevirt UI This is optional but I personally find the UI very nice from user experience point-of-view. $ oc new-project kubevirt-web-ui $ git clone https://github.com/kubevirt/web-ui-operator.git $ cd web-ui-operator/ $ oc apply -f deploy/service_account.yaml $ oc adm policy add-scc-to-user anyuid -z kubevirt-web-ui-operator $ oc apply -f deploy/service_account.yaml -n kubevirt-web-ui $ oc adm policy add-scc-to-user anyuid -z kubevirt-web-ui-operator $ oc apply -f deploy/role.yaml $ oc apply -f deploy/role_extra_for_console.yaml $ oc apply -f deploy/role_binding.yaml $ oc apply -f deploy/role_binding_extra_for_console.yaml $ oc apply -f deploy/crds/kubevirt_v1alpha1_kwebui_crd.yaml $ oc apply -f deploy/operator.yaml $ oc apply -f deploy/crds/kubevirt_v1alpha1_kwebui_cr.yaml Verify Kubevirt UI Deployment Verify pods. $ oc get pods -n kubevirt-web-ui NAME READY STATUS RESTARTS AGE console-6b66b66dd7-9gdvn 1/1 Unknown 1 28d console-6b66b66dd7-wwxm8 1/1 Running 0 15d kubevirt-web-ui-operator-6dd9547864-f5t49 0/1 Running 0 15d kubevirt-web-ui-operator-6dd9547864-n8fxd 1/1 Unknown 1 26d Verify services. $ oc get services -n kubevirt-web-ui NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE console ClusterIP 172.30.124.253 &lt;none&gt; 443/TCP 28d Verify routes. $ oc get routes -n kubevirt-web-ui NAME HOST/PORT PATH SERVICES PORT TERMINATION WILDCARD console kubevirt-web-ui.apps.46.4.207.246.xip.io console https reencrypt/Redirect None Connect to Kubevirt UI Using web browser enter the route, in this case https://kubevirt-web-ui.apps.46.4.207.246.xip.io. You will be prompted to login using OpenShift credentials. Deploying a Virtual Machine In this example we will be using a template to deploy a virtual machine. Create Project (namespace) for Virtual Machines  Using CLI to create new project $ oc create project vms Deploy Virtual Machine Template First login to the Kubevirt UI. You can either list routes as we did above for the project or look in OpenShift UI as is shown below.  The Kubevirt UI also shows overall status of the cluster. This is to provide an admin single-pane-of-glass regardless of containers or virtual machines.  Select virtual machines and create virtual machine from template.  Enter the yaml which is available in github.  Select create to deploy virtual machine template. Using CLI to deploy virtual machine template. $ oc create -f https://raw.githubusercontent.com/kubevirt/demo/master/manifests/vm.yaml Note: this template will deploy virtual machine in default project. You can change that by setting &quot;namespace&quot; to something else in the metadata section of template. Start Virtual Machine Once template is deployed you should be able to start the virtual machine.  That is it, pretty easy and amazing how well virtual machines are already integrated into Kubernetes and OpenShift. The best is yet to come! Summary In this article we discussed the value of virtualization and containers, together is better and clearly the way forward. We examined the value of collapsing platforms to have a single platform to drive both container and virtual machine workloads. We looked at where Container Native Virtualization (Kubevirt) is at today and explained some of the gaps versus traditional virtualization. Finally we walked through a hands-on guide to get Container Native Virtualization (Kubevirt) up and running on Kubernetes or OpenShift. Happy Containers and Virtual Machines Existing Together! (c) 2018 Keith Tenzer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;">





  <meta name="twitter:site" content="@keithtenzer">
  <meta name="twitter:title" content="Container Native Virtualization (Kubevirt): The Future for Virtual Machines is Here!">
  <meta name="twitter:description" content="Overview Immediately after Solomon Hykes first showed Docker to the public at PyCon in 2013, in his now famous &quot;docker run demo&quot;, IT folk started asking, what does this mean for virtualization? We only spent the previous 10-15 years virtualizing, seemingly everything, so understandably people were slightly apprehensive. Industries had been built and careers established, clearly virtualization would be an important part of the future and not simply replaced, right? In this article we will aim to understand the value of virtualization in a container-driven world, explore the current virtualization capabilities in Kubernetes and get started with Container Native Virtualization (Kubevirt) using Red Hat&#39;s Kubernetes enterprise distribution, OpenShift.  The Value of Virtualization in a Container-Driven World If we think about the real value of virtualization as a game changer, it is the ability to abstract hardware from the operating system. Everything else such as isolation, manageability, efficiency, etc are all features. Basically a virtualization platform is a hardware agnostic scheduler for operating systems. Looking at the value containers provide, it is as an abstraction between applications and operating system. Everything else such as multi-cloud, portability, speed, agility, deployment strategies, etc are all features. In the end both Virtualization and Containerization are doing basically one thing and that is providing an abstraction layer. The only difference is where the abstraction occurs. For Virtualization it is the operating system, while for containers it is the application. Clearly without a doubt we need both. That is not the question. The question is do we need both in separate platforms, or can it all be collapsed and if so what are the advantages? I think ultimately a single platform will emerge that provides both virtualization as well as containers and that platform already exists today, Kubernetes. There is a huge amount of overlap with what a virtualization platform is doings vs that of a container platform like Kubernetes. Scheduling, monitoring, quotas, RBAC, integration with compute, network, storage, HA and so on. In addition you need separate teams and operations processes to run various platforms so there is a lot of running costs that can be avoided. It makes zero sense to continue down the path of multiple platforms. Bringing Virtualization to Kubernetes The upstream project working on bringing virtualization to Kubernetes is called Kubevirt. Kubernetes is a perfect platform for virtual machines. Kubernetes already has a lot more intelligence that any virtualization platform ever had or will. It has built-in a framework called the Operator Framework. An operator is essentially a way to package, manage and most importantly operate Kubernetes native applications. The operate part is what allows us to build intelligence into how processes or even events should be automatically handled for a specific application. Taking a step back, what is an application? Basically a program that runs on the operating system. Virtualization is by definition an application. The operator framework is used to provide an operator for running virtualization on Kubernetes because in fact, a virtual machine is just an application. Today you are already able to run virtual machines on Kubernetes and it is even technology preview in Red Hat&#39;s enterprise Kubernetes platform, OpenShift. Kubevirt works essentially by running libvirt (KVM) in a container. Libvirt is the process running virtual machines and supports the qcow2 image format. The only real difference is now, Libvirt runs in a container and can be controlled, scheduled as well as managed via Kubernetes. This truly brings both worlds together.  Kubevirt has come a long way in a relatively short period of time. Still some gaps do exists and there is more work to be done in area of HA, live migration and dynamic resource sharing. Kubernetes and specifically cloud-native, where Kubernetes started has a different view on HA. Getting the virtualization primitives complete will take some time but it is happening and the operator framework is a key piece. Getting Started with Kubevirt In this example I am using OpenShift but this will work the same on Kubernetes. OpenShift is enterprise-grade Kubernetes plus a lot of additional things. Instead of &quot;oc&quot; cli command you would substitute that with the &quot;kubectl&quot; command. Keep in mind that for OpenShift Kubevirt is still technology preview. Setup permissions The Virtualization control plane needs additional permissions in it&#39;s namespace. By default OpenShift is very restrictive and SELinux prevents such access rights. $ oc adm policy add-scc-to-user privileged -n kube-system \ -z kubevirt-privileged $ oc adm policy add-scc-to-user privileged -n kube-system \ -z kubevirt-controller $ oc adm policy add-scc-to-user privileged -n kube-system \ -z kubevirt-apiserver Deploy Kubevirt components These components are part of the control plane and facilitate communications to virtual machines as well as enable their primitives. $ RELEASE=v0.11.0 $ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yam $ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yam $ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yaml $ curl -O -L https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/virtctl-${RELEASE}-linux-amd64 Install Virtctl Client Virtctl provides a CLI utility to interact with virtualk machines. $ sudo mv virtctl-${RELEASE}-linux-amd64 /usr/local/bin/virtctl $ sudo chmod +x /usr/local/bin/virtctl Configure Container Data Importer The cdi services allows for importing virtual machines. This is also optional. $ oc adm policy add-scc-to-user privileged -z cdi-sa $ VERSION=v1.4.1 $ oc create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml $ oc apply create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml $ oc create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml Verify Kubevirt Deployment The Kubevirt pods are marked in bold. $ oc get pods -n kube-system NAME READY STATUS RESTARTS AGE cdi-api-5c69fdb6db-6bknl 1/1 Running 0 6d cdi-api-5c69fdb6db-dl95k 0/1 Evicted 0 6d cdi-api-5c69fdb6db-gp5mv 0/1 Evicted 0 16d cdi-api-5c69fdb6db-mwwxs 0/1 Evicted 0 6d cdi-deployment-5fddc58c4d-mxpsn 1/1 Running 9 28d cdi-uploadproxy-85b8ff4884-x4kp2 1/1 Running 2 28d master-api-master0 1/1 Running 241 36d master-api-master1 1/1 Running 237 36d master-api-master2 1/1 Running 243 36d master-controllers-master0 1/1 Running 233 36d master-controllers-master1 1/1 Running 231 36d master-controllers-master2 1/1 Running 221 36d master-etcd-master0 1/1 Running 2495 36d master-etcd-master1 1/1 Running 2482 36d master-etcd-master2 1/1 Running 2489 36d virt-api-5cf4576cc8-br65d 1/1 Running 0 2h virt-api-5cf4576cc8-mpzrl 1/1 Unknown 1 28d virt-api-5cf4576cc8-qq5k6 1/1 Running 0 15d virt-api-5cf4576cc8-w7wk6 0/1 Evicted 0 26d virt-controller-5cdd99564c-9x2mr 1/1 Running 25 28d virt-controller-5cdd99564c-hsp6k 1/1 Running 0 26d virt-handler-67xjk 1/1 NodeLost 1 28d virt-handler-hhd2s 1/1 Running 1 28d virt-handler-rhvpp 1/1 Running 2 28d Check Services, Kubevirt services are marked in bold. $ oc get service -n kube-system NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE cdi-api ClusterIP 172.30.219.181 &lt;none&gt; 443/TCP 28d cdi-uploadproxy ClusterIP 172.30.136.133 &lt;none&gt; 443/TCP 28d kube-controllers ClusterIP None &lt;none&gt; 8444/TCP 36d kubelet ClusterIP None &lt;none&gt; 10250/TCP 36d kubevirt-prometheus-metrics ClusterIP 172.30.69.165 &lt;none&gt; 443/TCP 28d virt-api ClusterIP 172.30.76.176 &lt;none&gt; 443/TCP 28d Configure Kubevirt UI This is optional but I personally find the UI very nice from user experience point-of-view. $ oc new-project kubevirt-web-ui $ git clone https://github.com/kubevirt/web-ui-operator.git $ cd web-ui-operator/ $ oc apply -f deploy/service_account.yaml $ oc adm policy add-scc-to-user anyuid -z kubevirt-web-ui-operator $ oc apply -f deploy/service_account.yaml -n kubevirt-web-ui $ oc adm policy add-scc-to-user anyuid -z kubevirt-web-ui-operator $ oc apply -f deploy/role.yaml $ oc apply -f deploy/role_extra_for_console.yaml $ oc apply -f deploy/role_binding.yaml $ oc apply -f deploy/role_binding_extra_for_console.yaml $ oc apply -f deploy/crds/kubevirt_v1alpha1_kwebui_crd.yaml $ oc apply -f deploy/operator.yaml $ oc apply -f deploy/crds/kubevirt_v1alpha1_kwebui_cr.yaml Verify Kubevirt UI Deployment Verify pods. $ oc get pods -n kubevirt-web-ui NAME READY STATUS RESTARTS AGE console-6b66b66dd7-9gdvn 1/1 Unknown 1 28d console-6b66b66dd7-wwxm8 1/1 Running 0 15d kubevirt-web-ui-operator-6dd9547864-f5t49 0/1 Running 0 15d kubevirt-web-ui-operator-6dd9547864-n8fxd 1/1 Unknown 1 26d Verify services. $ oc get services -n kubevirt-web-ui NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE console ClusterIP 172.30.124.253 &lt;none&gt; 443/TCP 28d Verify routes. $ oc get routes -n kubevirt-web-ui NAME HOST/PORT PATH SERVICES PORT TERMINATION WILDCARD console kubevirt-web-ui.apps.46.4.207.246.xip.io console https reencrypt/Redirect None Connect to Kubevirt UI Using web browser enter the route, in this case https://kubevirt-web-ui.apps.46.4.207.246.xip.io. You will be prompted to login using OpenShift credentials. Deploying a Virtual Machine In this example we will be using a template to deploy a virtual machine. Create Project (namespace) for Virtual Machines  Using CLI to create new project $ oc create project vms Deploy Virtual Machine Template First login to the Kubevirt UI. You can either list routes as we did above for the project or look in OpenShift UI as is shown below.  The Kubevirt UI also shows overall status of the cluster. This is to provide an admin single-pane-of-glass regardless of containers or virtual machines.  Select virtual machines and create virtual machine from template.  Enter the yaml which is available in github.  Select create to deploy virtual machine template. Using CLI to deploy virtual machine template. $ oc create -f https://raw.githubusercontent.com/kubevirt/demo/master/manifests/vm.yaml Note: this template will deploy virtual machine in default project. You can change that by setting &quot;namespace&quot; to something else in the metadata section of template. Start Virtual Machine Once template is deployed you should be able to start the virtual machine.  That is it, pretty easy and amazing how well virtual machines are already integrated into Kubernetes and OpenShift. The best is yet to come! Summary In this article we discussed the value of virtualization and containers, together is better and clearly the way forward. We examined the value of collapsing platforms to have a single platform to drive both container and virtual machine workloads. We looked at where Container Native Virtualization (Kubevirt) is at today and explained some of the gaps versus traditional virtualization. Finally we walked through a hands-on guide to get Container Native Virtualization (Kubevirt) up and running on Kubernetes or OpenShift. Happy Containers and Virtual Machines Existing Together! (c) 2018 Keith Tenzer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;">
  <meta name="twitter:url" content="https://keithtenzer.com/openshift/container-native-virtualization-kubevirt-the-future-for-virtual-machines-is-here/">

  
    <meta name="twitter:card" content="summary">
    
  

  



  <meta property="article:published_time" content="2019-01-30T00:00:00-08:00">





  

  


<link rel="canonical" href="https://keithtenzer.com/openshift/container-native-virtualization-kubevirt-the-future-for-virtual-machines-is-here/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Keith Tenzer",
      "url": "https://keithtenzer.com/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Keith Tenzer's Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Keith Tenzer's Blog
          <span class="site-subtitle">Cloud Computing and Code</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/about/index.html">About</a>
            </li><li class="masthead__menu-item">
              <a href="/conferences-and-events/index.html">Conferences and Events</a>
            </li><li class="masthead__menu-item">
              <a href="/videos/index.html">Videos</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="https://keithtenzer.com/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#openshift" itemprop="item"><span itemprop="name">Openshift</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        <li class="current">Container Native Virtualization (Kubevirt): The Future for Virtual Machines is Here!</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/main/me.png" alt="Keith Tenzer" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Keith Tenzer</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Principal Solutions Architect at Red Hat</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Los Angeles, CA</span>
        </li>
      

      
        
          
        
          
        
          
            <li><a href="https://twitter.com/keithtenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span></a></li>
          
        
          
        
          
            <li><a href="https://github.com/ktenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Container Native Virtualization (Kubevirt): The Future for Virtual Machines is Here!">
    <meta itemprop="description" content="OverviewImmediately after Solomon Hykes first showed Docker to the public at PyCon in 2013, in his now famous &quot;docker run demo&quot;, IT folk started asking, what does this mean for virtualization? We only spent the previous 10-15 years virtualizing, seemingly everything, so understandably people were slightly apprehensive. Industries had been built and careers established, clearly virtualization would be an important part of the future and not simply replaced, right?In this article we will aim to understand the value of virtualization in a container-driven world, explore the current virtualization capabilities in Kubernetes and get started with Container Native Virtualization (Kubevirt) using Red Hat&#39;s Kubernetes enterprise distribution, OpenShift.The Value of Virtualization in a Container-Driven WorldIf we think about the real value of virtualization as a game changer, it is the ability to abstract hardware from the operating system. Everything else such as isolation, manageability, efficiency, etc are all features. Basically a virtualization platform is a hardware agnostic scheduler for operating systems. Looking at the value containers provide, it is as an abstraction between applications and operating system. Everything else such as multi-cloud, portability, speed, agility, deployment strategies, etc are all features.In the end both Virtualization and Containerization are doing basically one thing and that is providing an abstraction layer. The only difference is where the abstraction occurs. For Virtualization it is the operating system, while for containers it is the application. Clearly without a doubt we need both. That is not the question. The question is do we need both in separate platforms, or can it all be collapsed and if so what are the advantages?I think ultimately a single platform will emerge that provides both virtualization as well as containers and that platform already exists today, Kubernetes. There is a huge amount of overlap with what a virtualization platform is doings vs that of a container platform like Kubernetes. Scheduling, monitoring, quotas, RBAC, integration with compute, network, storage, HA and so on. In addition you need separate teams and operations processes to run various platforms so there is a lot of running costs that can be avoided. It makes zero sense to continue down the path of multiple platforms.Bringing Virtualization to KubernetesThe upstream project working on bringing virtualization to Kubernetes is called Kubevirt. Kubernetes is a perfect platform for virtual machines. Kubernetes already has a lot more intelligence that any virtualization platform ever had or will. It has built-in a framework called the Operator Framework. An operator is essentially a way to package, manage and most importantly operate Kubernetes native applications. The operate part is what allows us to build intelligence into how processes or even events should be automatically handled for a specific application. Taking a step back, what is an application? Basically a program that runs on the operating system. Virtualization is by definition an application. The operator framework is used to provide an operator for running virtualization on Kubernetes because in fact, a virtual machine is just an application.Today you are already able to run virtual machines on Kubernetes and it is even technology preview in Red Hat&#39;s enterprise Kubernetes platform, OpenShift. Kubevirt works essentially by running libvirt (KVM) in a container. Libvirt is the process running virtual machines and supports the qcow2 image format. The only real difference is now, Libvirt runs in a container and can be controlled, scheduled as well as managed via Kubernetes. This truly brings both worlds together.Kubevirt has come a long way in a relatively short period of time. Still some gaps do exists and there is more work to be done in area of HA, live migration and dynamic resource sharing. Kubernetes and specifically cloud-native, where Kubernetes started has a different view on HA. Getting the virtualization primitives complete will take some time but it is happening and the operator framework is a key piece.Getting Started with KubevirtIn this example I am using OpenShift but this will work the same on Kubernetes. OpenShift is enterprise-grade Kubernetes plus a lot of additional things. Instead of &quot;oc&quot; cli command you would substitute that with the &quot;kubectl&quot; command. Keep in mind that for OpenShift Kubevirt is still technology preview.Setup permissionsThe Virtualization control plane needs additional permissions in it&#39;s namespace. By default OpenShift is very restrictive and SELinux prevents such access rights.$ oc adm policy add-scc-to-user privileged -n kube-system \-z kubevirt-privileged$ oc adm policy add-scc-to-user privileged -n kube-system \-z kubevirt-controller$ oc adm policy add-scc-to-user privileged -n kube-system \-z kubevirt-apiserverDeploy Kubevirt componentsThese components are part of the control plane and facilitate communications to virtual machines as well as enable their primitives.$ RELEASE=v0.11.0$ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yam$ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yam$ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yaml$ curl -O -L https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/virtctl-${RELEASE}-linux-amd64Install Virtctl ClientVirtctl provides a CLI utility to interact with virtualk machines.$ sudo mv virtctl-${RELEASE}-linux-amd64 /usr/local/bin/virtctl$ sudo chmod +x /usr/local/bin/virtctlConfigure Container Data ImporterThe cdi services allows for importing virtual machines. This is also optional.$ oc adm policy add-scc-to-user privileged -z cdi-sa$ VERSION=v1.4.1$ oc create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml$ oc apply create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml$ oc create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yamlVerify Kubevirt DeploymentThe Kubevirt pods are marked in bold.$ oc get pods -n kube-systemNAME READY STATUS RESTARTS AGEcdi-api-5c69fdb6db-6bknl 1/1 Running 0 6dcdi-api-5c69fdb6db-dl95k 0/1 Evicted 0 6dcdi-api-5c69fdb6db-gp5mv 0/1 Evicted 0 16dcdi-api-5c69fdb6db-mwwxs 0/1 Evicted 0 6dcdi-deployment-5fddc58c4d-mxpsn 1/1 Running 9 28dcdi-uploadproxy-85b8ff4884-x4kp2 1/1 Running 2 28dmaster-api-master0 1/1 Running 241 36dmaster-api-master1 1/1 Running 237 36dmaster-api-master2 1/1 Running 243 36dmaster-controllers-master0 1/1 Running 233 36dmaster-controllers-master1 1/1 Running 231 36dmaster-controllers-master2 1/1 Running 221 36dmaster-etcd-master0 1/1 Running 2495 36dmaster-etcd-master1 1/1 Running 2482 36dmaster-etcd-master2 1/1 Running 2489 36dvirt-api-5cf4576cc8-br65d 1/1 Running 0 2hvirt-api-5cf4576cc8-mpzrl 1/1 Unknown 1 28dvirt-api-5cf4576cc8-qq5k6 1/1 Running 0 15dvirt-api-5cf4576cc8-w7wk6 0/1 Evicted 0 26dvirt-controller-5cdd99564c-9x2mr 1/1 Running 25 28dvirt-controller-5cdd99564c-hsp6k 1/1 Running 0 26dvirt-handler-67xjk 1/1 NodeLost 1 28dvirt-handler-hhd2s 1/1 Running 1 28dvirt-handler-rhvpp 1/1 Running 2 28dCheck Services, Kubevirt services are marked in bold.$ oc get service -n kube-systemNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEcdi-api ClusterIP 172.30.219.181 &lt;none&gt; 443/TCP 28dcdi-uploadproxy ClusterIP 172.30.136.133 &lt;none&gt; 443/TCP 28dkube-controllers ClusterIP None &lt;none&gt; 8444/TCP 36dkubelet ClusterIP None &lt;none&gt; 10250/TCP 36dkubevirt-prometheus-metrics ClusterIP 172.30.69.165 &lt;none&gt; 443/TCP 28dvirt-api ClusterIP 172.30.76.176 &lt;none&gt; 443/TCP 28dConfigure Kubevirt UIThis is optional but I personally find the UI very nice from user experience point-of-view.$ oc new-project kubevirt-web-ui$ git clone https://github.com/kubevirt/web-ui-operator.git$ cd web-ui-operator/$ oc apply -f deploy/service_account.yaml$ oc adm policy add-scc-to-user anyuid -z kubevirt-web-ui-operator$ oc apply -f deploy/service_account.yaml -n kubevirt-web-ui$ oc adm policy add-scc-to-user anyuid -z kubevirt-web-ui-operator$ oc apply -f deploy/role.yaml$ oc apply -f deploy/role_extra_for_console.yaml$ oc apply -f deploy/role_binding.yaml$ oc apply -f deploy/role_binding_extra_for_console.yaml$ oc apply -f deploy/crds/kubevirt_v1alpha1_kwebui_crd.yaml$ oc apply -f deploy/operator.yaml$ oc apply -f deploy/crds/kubevirt_v1alpha1_kwebui_cr.yamlVerify Kubevirt UI DeploymentVerify pods.$ oc get pods -n kubevirt-web-uiNAME READY STATUS RESTARTS AGEconsole-6b66b66dd7-9gdvn 1/1 Unknown 1 28dconsole-6b66b66dd7-wwxm8 1/1 Running 0 15dkubevirt-web-ui-operator-6dd9547864-f5t49 0/1 Running 0 15dkubevirt-web-ui-operator-6dd9547864-n8fxd 1/1 Unknown 1 26dVerify services.$ oc get services -n kubevirt-web-uiNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEconsole ClusterIP 172.30.124.253 &lt;none&gt; 443/TCP 28dVerify routes.$ oc get routes -n kubevirt-web-uiNAME HOST/PORT PATH SERVICES PORT TERMINATION WILDCARDconsole kubevirt-web-ui.apps.46.4.207.246.xip.io console https reencrypt/Redirect NoneConnect to Kubevirt UIUsing web browser enter the route, in this case https://kubevirt-web-ui.apps.46.4.207.246.xip.io. You will be prompted to login using OpenShift credentials.Deploying a Virtual MachineIn this example we will be using a template to deploy a virtual machine.Create Project (namespace) for Virtual MachinesUsing CLI to create new project$ oc create project vmsDeploy Virtual Machine TemplateFirst login to the Kubevirt UI. You can either list routes as we did above for the project or look in OpenShift UI as is shown below.The Kubevirt UI also shows overall status of the cluster. This is to provide an admin single-pane-of-glass regardless of containers or virtual machines.Select virtual machines and create virtual machine from template.Enter the yaml which is available in github.Select create to deploy virtual machine template.Using CLI to deploy virtual machine template.$ oc create -f https://raw.githubusercontent.com/kubevirt/demo/master/manifests/vm.yamlNote: this template will deploy virtual machine in default project. You can change that by setting &quot;namespace&quot; to something else in the metadata section of template.Start Virtual MachineOnce template is deployed you should be able to start the virtual machine.That is it, pretty easy and amazing how well virtual machines are already integrated into Kubernetes and OpenShift. The best is yet to come!SummaryIn this article we discussed the value of virtualization and containers, together is better and clearly the way forward. We examined the value of collapsing platforms to have a single platform to drive both container and virtual machine workloads. We looked at where Container Native Virtualization (Kubevirt) is at today and explained some of the gaps versus traditional virtualization. Finally we walked through a hands-on guide to get Container Native Virtualization (Kubevirt) up and running on Kubernetes or OpenShift.Happy Containers and Virtual Machines Existing Together!(c) 2018 Keith Tenzer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;">
    <meta itemprop="datePublished" content="2019-01-30T00:00:00-08:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Container Native Virtualization (Kubevirt): The Future for Virtual Machines is Here!
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2019-01-30T00:00:00-08:00">January 30, 2019</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          15 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
        <h2><img class="alignnone  wp-image-13188" src="/assets/2019/01/kubevirt_logo.png" alt="kubevirt_logo" width="202" height="202" /></h2>
<h2>Overview</h2>
<p>Immediately after Solomon Hykes first showed Docker to the public at PyCon in 2013, in his now famous <a href="https://www.youtube.com/watch?v=wW9CAH9nSLs">"docker run demo"</a>, IT folk started asking, what does this mean for virtualization? We only spent the previous 10-15 years virtualizing, seemingly everything, so understandably people were slightly apprehensive. Industries had been built and careers established, clearly virtualization would be an important part of the future and not simply replaced, right?</p>
<p>In this article we will aim to understand the value of virtualization in a container-driven world, explore the current virtualization capabilities in Kubernetes and get started with Container Native Virtualization (Kubevirt) using Red Hat's Kubernetes enterprise distribution, OpenShift.</p>
<p><!--more--></p>
<h2>The Value of Virtualization in a Container-Driven World</h2>
<p>If we think about the real value of virtualization as a game changer, it is the ability to abstract hardware from the operating system. Everything else such as isolation, manageability, efficiency, etc are all features. Basically a virtualization platform is a hardware agnostic scheduler for operating systems. Looking at the value containers provide, it is as an abstraction between applications and operating system. Everything else such as multi-cloud, portability, speed, agility, deployment strategies, etc are all features.</p>
<p>In the end both Virtualization and Containerization are doing basically one thing and that is providing an abstraction layer. The only difference is where the abstraction occurs. For Virtualization it is the operating system, while for containers it is the application. Clearly without a doubt we need both. That is not the question. The question is do we need both in separate platforms, or can it all be collapsed and if so what are the advantages?</p>
<p>I think ultimately a single platform will emerge that provides both virtualization as well as containers and that platform already exists today, Kubernetes. There is a huge amount of overlap with what a virtualization platform is doings vs that of a container platform like Kubernetes. Scheduling, monitoring, quotas, RBAC, integration with compute, network, storage, HA and so on. In addition you need separate teams and operations processes to run various platforms so there is a lot of running costs that can be avoided. It makes zero sense to continue down the path of multiple platforms.</p>
<h2>Bringing Virtualization to Kubernetes</h2>
<p>The upstream project working on bringing virtualization to Kubernetes is called <a href="http://kubevirt.io/">Kubevirt</a>. Kubernetes is a perfect platform for virtual machines. Kubernetes already has a lot more intelligence that any virtualization platform ever had or will. It has built-in a framework called the <a href="https://developers.redhat.com/blog/2018/12/18/introduction-to-the-kubernetes-operator-framework/">Operator Framework</a>. An operator is essentially a way to package, manage and most importantly operate Kubernetes native applications. The operate part is what allows us to build intelligence into how processes or even events should be automatically handled for a specific application. Taking a step back, what is an application? Basically a program that runs on the operating system. Virtualization is by definition an application. The operator framework is used to provide an operator for running virtualization on Kubernetes because in fact, a virtual machine is just an application.</p>
<p>Today you are already able to run virtual machines on Kubernetes and it is even technology preview in Red Hat's enterprise Kubernetes platform, OpenShift. Kubevirt works essentially by running libvirt (KVM) in a container. Libvirt is the process running virtual machines and supports the qcow2 image format. The only real difference is now, Libvirt runs in a container and can be controlled, scheduled as well as managed via Kubernetes. This truly brings both worlds together.</p>
<p><img class="alignnone  wp-image-13181" src="/assets/2019/01/kubevirt-components.png" alt="kubevirt-components" width="938" height="549" /></p>
<p>Kubevirt has come a long way in a relatively short period of time. Still some gaps do exists and there is more work to be done in area of HA, live migration and dynamic resource sharing. Kubernetes and specifically cloud-native, where Kubernetes started has a different view on HA. Getting the virtualization primitives complete will take some time but it is happening and the operator framework is a key piece.</p>
<h2>Getting Started with Kubevirt</h2>
<p>In this example I am using OpenShift but this will work the same on Kubernetes. OpenShift is enterprise-grade Kubernetes plus a lot of additional things. Instead of "oc" cli command you would substitute that with the "kubectl" command. Keep in mind that for OpenShift Kubevirt is still technology preview.</p>
<p><strong>Setup permissions</strong></p>
<p>The Virtualization control plane needs additional permissions in it's namespace. By default OpenShift is very restrictive and SELinux prevents such access rights.</p>
<pre>$ oc adm policy add-scc-to-user privileged -n kube-system \
-z kubevirt-privileged
$ oc adm policy add-scc-to-user privileged -n kube-system \
-z kubevirt-controller
$ oc adm policy add-scc-to-user privileged -n kube-system \
-z kubevirt-apiserver</pre>
<p><strong>Deploy Kubevirt components</strong></p>
<p>These components are part of the control plane and facilitate communications to virtual machines as well as enable their primitives.</p>
<pre>$ RELEASE=v0.11.0
$ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yam
$ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yam
$ oc apply -f https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/kubevirt.yaml
$ curl -O -L https://github.com/kubevirt/kubevirt/releases/download/${RELEASE}/virtctl-${RELEASE}-linux-amd64</pre>
<p><strong>Install Virtctl Client</strong></p>
<p>Virtctl provides a CLI utility to interact with virtualk machines.</p>
<pre>$ sudo mv virtctl-${RELEASE}-linux-amd64 /usr/local/bin/virtctl
$ sudo chmod +x /usr/local/bin/virtctl</pre>
<p><strong>Configure Container Data Importer</strong></p>
<p>The cdi services allows for importing virtual machines. This is also optional.</p>
<pre>$ oc adm policy add-scc-to-user privileged -z cdi-sa
$ VERSION=v1.4.1
$ oc create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml
$ oc apply create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml
$ oc create -f https://github.com/kubevirt/containerized-data-importer/releases/download/$VERSION/cdi-controller.yaml</pre>
<p><strong>Verify Kubevirt Deployment</strong></p>
<p>The Kubevirt pods are marked in bold.</p>
<pre>$ oc get pods -n kube-system
NAME READY STATUS RESTARTS AGE
<strong>cdi-api-5c69fdb6db-6bknl 1/1 Running 0 6d</strong>
<strong>cdi-api-5c69fdb6db-dl95k 0/1 Evicted 0 6d</strong>
<strong>cdi-api-5c69fdb6db-gp5mv 0/1 Evicted 0 16d</strong>
<strong>cdi-api-5c69fdb6db-mwwxs 0/1 Evicted 0 6d</strong>
<strong>cdi-deployment-5fddc58c4d-mxpsn 1/1 Running 9 28d</strong>
<strong>cdi-uploadproxy-85b8ff4884-x4kp2 1/1 Running 2 28d</strong>
master-api-master0 1/1 Running 241 36d
master-api-master1 1/1 Running 237 36d
master-api-master2 1/1 Running 243 36d
master-controllers-master0 1/1 Running 233 36d
master-controllers-master1 1/1 Running 231 36d
master-controllers-master2 1/1 Running 221 36d
master-etcd-master0 1/1 Running 2495 36d
master-etcd-master1 1/1 Running 2482 36d
master-etcd-master2 1/1 Running 2489 36d
<strong>virt-api-5cf4576cc8-br65d 1/1 Running 0 2h</strong>
<strong>virt-api-5cf4576cc8-mpzrl 1/1 Unknown 1 28d</strong>
<strong>virt-api-5cf4576cc8-qq5k6 1/1 Running 0 15d</strong>
<strong>virt-api-5cf4576cc8-w7wk6 0/1 Evicted 0 26d</strong>
<strong>virt-controller-5cdd99564c-9x2mr 1/1 Running 25 28d</strong>
<strong>virt-controller-5cdd99564c-hsp6k 1/1 Running 0 26d</strong>
<strong>virt-handler-67xjk 1/1 NodeLost 1 28d</strong>
<strong>virt-handler-hhd2s 1/1 Running 1 28d</strong>
<strong>virt-handler-rhvpp 1/1 Running 2 28d</strong></pre>
<p>Check Services, Kubevirt services are marked in bold.</p>
<pre>$ oc get service -n kube-system
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
<strong>cdi-api ClusterIP 172.30.219.181 &lt;none&gt; 443/TCP 28d</strong>
<strong>cdi-uploadproxy ClusterIP 172.30.136.133 &lt;none&gt; 443/TCP 28d</strong>
kube-controllers ClusterIP None &lt;none&gt; 8444/TCP 36d
kubelet ClusterIP None &lt;none&gt; 10250/TCP 36d
kubevirt-prometheus-metrics ClusterIP 172.30.69.165 &lt;none&gt; 443/TCP 28d
<strong>virt-api ClusterIP 172.30.76.176 &lt;none&gt; 443/TCP 28d</strong></pre>
<p><strong>Configure Kubevirt UI</strong></p>
<p>This is optional but I personally find the UI very nice from user experience point-of-view.</p>
<pre>$ oc new-project kubevirt-web-ui
$ git clone https://github.com/kubevirt/web-ui-operator.git
$ cd web-ui-operator/
$ oc apply -f deploy/service_account.yaml
$ oc adm policy add-scc-to-user anyuid -z kubevirt-web-ui-operator
$ oc apply -f deploy/service_account.yaml -n kubevirt-web-ui
$ oc adm policy add-scc-to-user anyuid -z kubevirt-web-ui-operator
$ oc apply -f deploy/role.yaml
$ oc apply -f deploy/role_extra_for_console.yaml
$ oc apply -f deploy/role_binding.yaml
$ oc apply -f deploy/role_binding_extra_for_console.yaml
$ oc apply -f deploy/crds/kubevirt_v1alpha1_kwebui_crd.yaml
$ oc apply -f deploy/operator.yaml
$ oc apply -f deploy/crds/kubevirt_v1alpha1_kwebui_cr.yaml</pre>
<p><strong>Verify Kubevirt UI Deployment</strong></p>
<p>Verify pods.</p>
<pre>$ oc get pods -n kubevirt-web-ui
NAME READY STATUS RESTARTS AGE
console-6b66b66dd7-9gdvn 1/1 Unknown 1 28d
console-6b66b66dd7-wwxm8 1/1 Running 0 15d
kubevirt-web-ui-operator-6dd9547864-f5t49 0/1 Running 0 15d
kubevirt-web-ui-operator-6dd9547864-n8fxd 1/1 Unknown 1 26d</pre>
<p>Verify services.</p>
<pre>$ oc get services -n kubevirt-web-ui
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
console ClusterIP 172.30.124.253 &lt;none&gt; 443/TCP 28d</pre>
<p>Verify routes.</p>
<pre>$ oc get routes -n kubevirt-web-ui
NAME HOST/PORT PATH SERVICES PORT TERMINATION WILDCARD
console <strong>kubevirt-web-ui.apps.46.4.207.246.xip.io</strong> console https reencrypt/Redirect None</pre>
<p>Connect to Kubevirt UI</p>
<p>Using web browser enter the route, in this case https://kubevirt-web-ui.apps.46.4.207.246.xip.io. You will be prompted to login using OpenShift credentials.</p>
<h2>Deploying a Virtual Machine</h2>
<p>In this example we will be using a template to deploy a virtual machine.</p>
<p><strong>Create Project (namespace) for Virtual Machines</strong></p>
<p><img class="alignnone  wp-image-13182" src="/assets/2019/01/kubevirt_5.png" alt="kubevirt_5" width="1003" height="466" /></p>
<p>Using CLI to create new project</p>
<pre>$ oc create project vms</pre>
<p><strong>Deploy Virtual Machine Template</strong></p>
<p>First login to the Kubevirt UI. You can either list routes as we did above for the project or look in OpenShift UI as is shown below.</p>
<p><img class="alignnone  wp-image-13183" src="/assets/2019/01/kubevirt_6.png" alt="kubevirt_6" width="1027" height="447" /></p>
<p>The Kubevirt UI also shows overall status of the cluster. This is to provide an admin single-pane-of-glass regardless of containers or virtual machines.</p>
<p><img class="alignnone  wp-image-13184" src="/assets/2019/01/kubevirt_1.png" alt="kubevirt_1" width="1033" height="500" /></p>
<p>Select virtual machines and create virtual machine from template.</p>
<p><img class="alignnone  wp-image-13185" src="/assets/2019/01/kubevirt_2.png" alt="kubevirt_2" width="1057" height="426" /></p>
<p>Enter the yaml which is available in <a href="https://raw.githubusercontent.com/kubevirt/demo/master/manifests/vm.yaml">github</a>.</p>
<p><img class="alignnone  wp-image-13186" src="/assets/2019/01/kubevirt_3.png" alt="kubevirt_3" width="972" height="473" /></p>
<p>Select create to deploy virtual machine template.</p>
<p>Using CLI to deploy virtual machine template.</p>
<pre>$ oc create -f https://raw.githubusercontent.com/kubevirt/demo/master/manifests/vm.yaml</pre>
<p>Note: this template will deploy virtual machine in default project. You can change that by setting "namespace" to something else in the metadata section of template.</p>
<p><strong>Start Virtual Machine</strong></p>
<p>Once template is deployed you should be able to start the virtual machine.</p>
<p><img class="alignnone  wp-image-13187" src="/assets/2019/01/kubevirt_4.png" alt="kubevirt_4" width="1258" height="494" /></p>
<p>That is it, pretty easy and amazing how well virtual machines are already integrated into Kubernetes and OpenShift. The best is yet to come!</p>
<h2>Summary</h2>
<p>In this article we discussed the value of virtualization and containers, together is better and clearly the way forward. We examined the value of collapsing platforms to have a single platform to drive both container and virtual machine workloads. We looked at where Container Native Virtualization (Kubevirt) is at today and explained some of the gaps versus traditional virtualization. Finally we walked through a hands-on guide to get Container Native Virtualization (Kubevirt) up and running on Kubernetes or OpenShift.</p>
<p>Happy Containers and Virtual Machines Existing Together!</p>
<p>(c) 2018 Keith Tenzer</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#cnv" class="page__taxonomy-item" rel="tag">cnv</a><span class="sep">, </span>
    
      <a href="/tags/#container-native-virtualization" class="page__taxonomy-item" rel="tag">Container Native Virtualization</a><span class="sep">, </span>
    
      <a href="/tags/#kubernetes" class="page__taxonomy-item" rel="tag">Kubernetes</a><span class="sep">, </span>
    
      <a href="/tags/#kubevirt" class="page__taxonomy-item" rel="tag">Kubevirt</a><span class="sep">, </span>
    
      <a href="/tags/#linux" class="page__taxonomy-item" rel="tag">Linux</a><span class="sep">, </span>
    
      <a href="/tags/#openshift" class="page__taxonomy-item" rel="tag">OpenShift</a><span class="sep">, </span>
    
      <a href="/tags/#opensource" class="page__taxonomy-item" rel="tag">opensource</a><span class="sep">, </span>
    
      <a href="/tags/#virtual-machines" class="page__taxonomy-item" rel="tag">Virtual Machines</a><span class="sep">, </span>
    
      <a href="/tags/#vitualization" class="page__taxonomy-item" rel="tag">Vitualization</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#openshift" class="page__taxonomy-item" rel="tag">OpenShift</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2019-01-30T00:00:00-08:00">January 30, 2019</time></p>


      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=keithtenzer&text=Container+Native+Virtualization+%28Kubevirt%29%3A+The+Future+for+Virtual+Machines+is+Here%21%20https%3A%2F%2Fkeithtenzer.com%2Fopenshift%2Fcontainer-native-virtualization-kubevirt-the-future-for-virtual-machines-is-here%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fkeithtenzer.com%2Fopenshift%2Fcontainer-native-virtualization-kubevirt-the-future-for-virtual-machines-is-here%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fkeithtenzer.com%2Fopenshift%2Fcontainer-native-virtualization-kubevirt-the-future-for-virtual-machines-is-here%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/openshift/its-a-paas-vanilla-kubernetes-vs-openshift-on-openstack-lab-setup-guide/" class="pagination--pager" title="It’s a PaaS: Vanilla Kubernetes vs OpenShift on OpenStack Lab Setup Guide
">Previous</a>
    
    
      <a href="/cloud-native/the-coffee-is-getting-cold-its-time-to-go-getting-started-building-microservice/" class="pagination--pager" title="The Coffee is Getting Cold, It’s Time to GO - Getting Started Building Microservices
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/openshift/openshift-service-mesh-getting-started-guide/" rel="permalink">OpenShift Service Mesh Getting Started Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-04-27T00:00:00-07:00">April 27, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          11 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">






Overview
In this article we will explore the OpenShift Service Mesh and deploy a demo application to better understand the various concepts. First you...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/openshift/openshift-4-aws-ipi-installation-getting-started-guide/" rel="permalink">OpenShift 4 AWS IPI Installation Getting Started Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-01-18T00:00:00-08:00">January 18, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          8 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">


Happy new year as this will be the first post of 2021! 2020 was obviously a challenging year, my hope is I will have more time to devote to blogging in 20...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ansible/windows-automation-with-ansible-getting-started-guide/" rel="permalink">Windows Automation with Ansible: Getting Started Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2020-05-19T00:00:00-07:00">May 19, 2020</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          14 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
Overview
In this article we will focus on how to get started with automation of windows using Ansible. Specifically we will look at installing 3rd party sof...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/general/red-hat-subscription-reporting-guide/" rel="permalink">Red Hat Subscription Reporting Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2020-05-13T00:00:00-07:00">May 13, 2020</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          6 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
source: https://www.cio.com/article/3199910/zuora-blazes-a-new-trail-to-the-subscription-economy-and-a-post-erp-world.html
Overview
This article will look a...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://twitter.com/keithtenzer"" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
      
        
          <li><a href="https://github.com/ktenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 Keith Tenzer. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
