<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
<link rel="icon" href="/assets/main/me.png">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>CI/CD with Ansible Tower and GitHub - Keith Tenzer’s Blog</title>
<meta name="description" content="Overview Over the last few years CI/CD (Continuous Integration/Continuous Deployment) thanks to new technologies has become a lot easier. It should no longer be a major thorn in the side of developers. Many are moving to cloud platforms which has CI/CD built-in (Azure DevOps for example), others are using Kubernetes which clearly reduces a lot of the complexity around CI/CD. Still at many organizations I see Jenkins or other complex and often homegrown tooling. I certainly recognize this tooling was needed but in 2019 there are better, more streamlined options. Now I get it, our butler Jenkins has served us well, for many years, he has become part of our family. But just like the famous Butler, Alfred from Batman, he has gotten old and likely it is time to look into retirement. In this article we will discuss and demonstrate how to use Ansible Tower and GitHub for CI/CD. A video presentation and demonstration is available at following URL: https://youtu.be/lyk-CRVXs8I  Why Ansible Tower for CI/CD? Most organizations are adopting an infrastructure-as-code approach, that is to say everyone, even operations are becoming developers or at least working and thinking like developers. The automation tool of choice or even standard if you will is clearly Ansible. However Ansible is just an automation runtime, it has no API, RBAC, Credentials and does not enable collaboration between teams. This is where Ansible Tower (or AWX the opensource project) shines. Here are some advantages Ansible Tower bring to CI/CD:  Reuse infrastructure and operations playbooks in CI/CD Better collaboration between devops and infrastructure teams Simple CI/CD, just Ansible, no DML, no Groovy, no god knows what Ansible Tower is a enterprise product not a project like Jenkins Streamlined CI/CD instead of every devops team on their own Self organizing and governing because that is what Ansible does best  Now clearly Ansible Tower cannot do everything. It does not have for example a built-in CI/CD approval process and does not specifically focus on CI/CD. Instead Ansible Tower is an automation platform. It views the world through job templates (a playbook) and workflows (group of playbooks). In this case a workflow is a CI/CD pipeline with an API in front of it of course. Once you have your workflows or pipelines and an API in front of them you are 90% done. The rest is just how the process should flow and you might not even need any extra tooling to do that, certainly not complex tooling like Jenkins. Ansible Tower CI/CD Architecture The point of this article is to demonstrate that CI/CD can work very simply and with just Ansible Tower and GitHub. The diagram below illustrates what we will be building. This focuses only really on CI but CD would just be additional workflows.  The main purpose of CI is of course to protect the master branch so it always builds. The only way you do that of course is to check code into another branch (like a feature branch), test that code, review code and only merge to master when you are sure all tests have passed. The above architecture accomplished exactly that and does so with a very simplified approach that leverages Ansible Tower as our CI engine. We won&#39;t be going into the CD details in this article, but that would just be additional workflows to deploy artifacts generated by the CI process into dev-&gt;test-&gt;production. Using this architecture one could use GitHub releases to store artifacts. GitHub has ability to then trigger a webhook when latest release is updated which in turn could trigger an Ansible Tower CD workflow. Ansible Tower Configuration First we will want to configure a workflow in Ansible Tower that will be a CI/CD pipeline. I think it is good practice to have one workflow per pipeline. In this example we have a single workflow which handles CI. Configure Credentials We need machine credentials for Fedora since we will be accessing a fedora host to execute our build. In Ansible Tower credentials allow you to access systems without needing to connect to them directly, like you would with normal Ansible. Users don&#39;t even need to know credentials.  Configure Inventory Inventories in Ansible Tower are generated dynamically. This is important because when we provision a VM we don&#39;t at the time know what it&#39;s IP will be. Of course after we provision we want to access the VM. The solution is to perform an inventory update after provisioning and then parameterize provisioning and execution playbooks so they create/use same hostnames. Here we are using OpenStack but this could be any public or private cloud. For doing CI we created an inventory called development and this is what we will be later using in our job templates.  Configure Projects Projects in Ansible Tower are simply SCM repositories where playbooks reside. In this case of course a GitHub repository. Here notice the developer playbooks to do the build are located with the source code where the provisioning playbooks are in a different repository. This is where we get collaboration between infrastructure operations teams and devops. Something that rarely existed in CI/CD. Links to go-hello-world and paas-and-iaas repositories.  Configure Job Templates For our CI pipeline we will need to run three playbooks. Each playbook is a job template. In Ansible Tower a job template is a playbook, it&#39;s inventory, survey, credentials and various other things that go way beyond plain old Ansible. The three job templates are one to provision a fedora instance (from infrastructure / operations team), a playbook to perform the go build / tests (from devops team) and a playbook to cleanup (from infrastructure / operations team).  Configure Ansible Tower Workflow As mentioned a workflow will bring all the playbooks/job templates together. Here we configure a workflow called GO CI/CD Workflow. Notice the below workflow. We are using our three job templates provision fedora, run go build and remove instance. In addition the second step performs an inventory update for the development inventory. A workflow allows you to perform granular inventory updates wherever needed.  We aren&#39;t quite done, the last step is to add a survey to the Workflow. Each of the playbooks of course accept parameters. These need to be added in form of survey. A survey provides a user friendly interface for parameterizing workflows or job templates in Ansible Tower.  Ansible Tower CI/CD Setup The first thing to do is setup tower-cli. This is a much better tool than curl to trigger Ansible Tower. From the webhook we will use tower-cli to update projects in Ansible Tower and launch workflows. Install tower-cli My fellow Colleague, Andreas Neeb created a role to install tower-cli. https://github.com/andyneeb/ansible-demo-infra/tree/master/roles/tower-cli-setup Simply create playbook that uses role on localhost or host in your inventory where you want to install tower-cli. Fork go-hello-world &nbsp; Configure GitHub Webhook Token In order to update commit status in GitHub we need permissions and a webhook token. In GitHub under your user-&gt;settings go to developer settings.  Select personal access tokens and create a new one.  Add a note and select repo:status. This is the minimum permission in GitHub needed to update a commit status. For CI/CD you need to be able in GitHub update commit status. Configure GitHub Webhook In GitHub go to the go-hello-world project. Under settings create a new webhook.  Make sure content-type is application/json and set a secret, this is a password that will be used to authenticate to the webhook listener we will deploy next. Install Webhook Listener on Ansible Tower The folks at Arctiq created a role and playbook for setting up a webhook listener on Ansible Tower. https://github.com/ArctiqTeam/tower-webhook Simply clone the repository, update the vars.yml  and hosts file according. # vi hosts [webhook] webhookserver ansible_host=46.4.207.248 ansible_ssh_port=22 # vi vars.yml --- projects: - id: 7 name: go-hello-world # export GH_SECRET= # export TOWER_PASSWORD= # ansible-playbook install.yml The playbook will create a systemctl service called webhook so it can easily be started and stopped. The webhook will run on port 9000.  Configure Webhook Listener In order to use webhook for CI/CD some changes need to be made. Update the webhook.conf as follows. # vi /etc/webhook/webhook.conf [   {     &quot;id&quot;: &quot;go-hello-world&quot;,     &quot;execute-command&quot;: &quot;/usr/local/bin/go-hello-world.sh&quot;,     &quot;pass-environment-to-command&quot;:     [       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;head_commit.id&quot;,         &quot;envname&quot;: &quot;COMMIT_ID&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;pusher.name&quot;,         &quot;envname&quot;: &quot;PUSHER_NAME&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;pusher.email&quot;,         &quot;envname&quot;: &quot;PUSHER_EMAIL&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;head_commit.id&quot;,         &quot;envname&quot;: &quot;COMMIT_ID&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;pusher.name&quot;,         &quot;envname&quot;: &quot;PUSHER_NAME&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;ref&quot;,         &quot;envname&quot;: &quot;REF&quot;       }     ],     &quot;trigger-rule&quot;:     {       &quot;match&quot;:       {         &quot;type&quot;: &quot;payload-hash-sha1&quot;,         &quot;secret&quot;: &quot;&lt;password&gt;&quot;,         &quot;parameter&quot;:         {           &quot;source&quot;: &quot;header&quot;,           &quot;name&quot;: &quot;X-Hub-Signature&quot;         }       }     }   } ]  Restart webhook # systemctl restart webhook Next update the shell script go-hello-world.sh. This will be triggered each time a push request is sent to GitHub. It will also receive environment parameters needed for CI from GitHub. # vi /usr/local/bin/go-hello-world.sh #!/bin/sh printenv &gt;/tmp/env.out BRANCH=`echo $REF |sed -e &#39;s/refs\/heads\///g&#39;`">


  <meta name="author" content="Keith Tenzer">
  
  <meta property="article:author" content="Keith Tenzer">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Keith Tenzer's Blog">
<meta property="og:title" content="CI/CD with Ansible Tower and GitHub">
<meta property="og:url" content="http://localhost:4000/code/ci-cd-with-ansible-tower-and-github/">


  <meta property="og:description" content="Overview Over the last few years CI/CD (Continuous Integration/Continuous Deployment) thanks to new technologies has become a lot easier. It should no longer be a major thorn in the side of developers. Many are moving to cloud platforms which has CI/CD built-in (Azure DevOps for example), others are using Kubernetes which clearly reduces a lot of the complexity around CI/CD. Still at many organizations I see Jenkins or other complex and often homegrown tooling. I certainly recognize this tooling was needed but in 2019 there are better, more streamlined options. Now I get it, our butler Jenkins has served us well, for many years, he has become part of our family. But just like the famous Butler, Alfred from Batman, he has gotten old and likely it is time to look into retirement. In this article we will discuss and demonstrate how to use Ansible Tower and GitHub for CI/CD. A video presentation and demonstration is available at following URL: https://youtu.be/lyk-CRVXs8I  Why Ansible Tower for CI/CD? Most organizations are adopting an infrastructure-as-code approach, that is to say everyone, even operations are becoming developers or at least working and thinking like developers. The automation tool of choice or even standard if you will is clearly Ansible. However Ansible is just an automation runtime, it has no API, RBAC, Credentials and does not enable collaboration between teams. This is where Ansible Tower (or AWX the opensource project) shines. Here are some advantages Ansible Tower bring to CI/CD:  Reuse infrastructure and operations playbooks in CI/CD Better collaboration between devops and infrastructure teams Simple CI/CD, just Ansible, no DML, no Groovy, no god knows what Ansible Tower is a enterprise product not a project like Jenkins Streamlined CI/CD instead of every devops team on their own Self organizing and governing because that is what Ansible does best  Now clearly Ansible Tower cannot do everything. It does not have for example a built-in CI/CD approval process and does not specifically focus on CI/CD. Instead Ansible Tower is an automation platform. It views the world through job templates (a playbook) and workflows (group of playbooks). In this case a workflow is a CI/CD pipeline with an API in front of it of course. Once you have your workflows or pipelines and an API in front of them you are 90% done. The rest is just how the process should flow and you might not even need any extra tooling to do that, certainly not complex tooling like Jenkins. Ansible Tower CI/CD Architecture The point of this article is to demonstrate that CI/CD can work very simply and with just Ansible Tower and GitHub. The diagram below illustrates what we will be building. This focuses only really on CI but CD would just be additional workflows.  The main purpose of CI is of course to protect the master branch so it always builds. The only way you do that of course is to check code into another branch (like a feature branch), test that code, review code and only merge to master when you are sure all tests have passed. The above architecture accomplished exactly that and does so with a very simplified approach that leverages Ansible Tower as our CI engine. We won&#39;t be going into the CD details in this article, but that would just be additional workflows to deploy artifacts generated by the CI process into dev-&gt;test-&gt;production. Using this architecture one could use GitHub releases to store artifacts. GitHub has ability to then trigger a webhook when latest release is updated which in turn could trigger an Ansible Tower CD workflow. Ansible Tower Configuration First we will want to configure a workflow in Ansible Tower that will be a CI/CD pipeline. I think it is good practice to have one workflow per pipeline. In this example we have a single workflow which handles CI. Configure Credentials We need machine credentials for Fedora since we will be accessing a fedora host to execute our build. In Ansible Tower credentials allow you to access systems without needing to connect to them directly, like you would with normal Ansible. Users don&#39;t even need to know credentials.  Configure Inventory Inventories in Ansible Tower are generated dynamically. This is important because when we provision a VM we don&#39;t at the time know what it&#39;s IP will be. Of course after we provision we want to access the VM. The solution is to perform an inventory update after provisioning and then parameterize provisioning and execution playbooks so they create/use same hostnames. Here we are using OpenStack but this could be any public or private cloud. For doing CI we created an inventory called development and this is what we will be later using in our job templates.  Configure Projects Projects in Ansible Tower are simply SCM repositories where playbooks reside. In this case of course a GitHub repository. Here notice the developer playbooks to do the build are located with the source code where the provisioning playbooks are in a different repository. This is where we get collaboration between infrastructure operations teams and devops. Something that rarely existed in CI/CD. Links to go-hello-world and paas-and-iaas repositories.  Configure Job Templates For our CI pipeline we will need to run three playbooks. Each playbook is a job template. In Ansible Tower a job template is a playbook, it&#39;s inventory, survey, credentials and various other things that go way beyond plain old Ansible. The three job templates are one to provision a fedora instance (from infrastructure / operations team), a playbook to perform the go build / tests (from devops team) and a playbook to cleanup (from infrastructure / operations team).  Configure Ansible Tower Workflow As mentioned a workflow will bring all the playbooks/job templates together. Here we configure a workflow called GO CI/CD Workflow. Notice the below workflow. We are using our three job templates provision fedora, run go build and remove instance. In addition the second step performs an inventory update for the development inventory. A workflow allows you to perform granular inventory updates wherever needed.  We aren&#39;t quite done, the last step is to add a survey to the Workflow. Each of the playbooks of course accept parameters. These need to be added in form of survey. A survey provides a user friendly interface for parameterizing workflows or job templates in Ansible Tower.  Ansible Tower CI/CD Setup The first thing to do is setup tower-cli. This is a much better tool than curl to trigger Ansible Tower. From the webhook we will use tower-cli to update projects in Ansible Tower and launch workflows. Install tower-cli My fellow Colleague, Andreas Neeb created a role to install tower-cli. https://github.com/andyneeb/ansible-demo-infra/tree/master/roles/tower-cli-setup Simply create playbook that uses role on localhost or host in your inventory where you want to install tower-cli. Fork go-hello-world &nbsp; Configure GitHub Webhook Token In order to update commit status in GitHub we need permissions and a webhook token. In GitHub under your user-&gt;settings go to developer settings.  Select personal access tokens and create a new one.  Add a note and select repo:status. This is the minimum permission in GitHub needed to update a commit status. For CI/CD you need to be able in GitHub update commit status. Configure GitHub Webhook In GitHub go to the go-hello-world project. Under settings create a new webhook.  Make sure content-type is application/json and set a secret, this is a password that will be used to authenticate to the webhook listener we will deploy next. Install Webhook Listener on Ansible Tower The folks at Arctiq created a role and playbook for setting up a webhook listener on Ansible Tower. https://github.com/ArctiqTeam/tower-webhook Simply clone the repository, update the vars.yml  and hosts file according. # vi hosts [webhook] webhookserver ansible_host=46.4.207.248 ansible_ssh_port=22 # vi vars.yml --- projects: - id: 7 name: go-hello-world # export GH_SECRET= # export TOWER_PASSWORD= # ansible-playbook install.yml The playbook will create a systemctl service called webhook so it can easily be started and stopped. The webhook will run on port 9000.  Configure Webhook Listener In order to use webhook for CI/CD some changes need to be made. Update the webhook.conf as follows. # vi /etc/webhook/webhook.conf [   {     &quot;id&quot;: &quot;go-hello-world&quot;,     &quot;execute-command&quot;: &quot;/usr/local/bin/go-hello-world.sh&quot;,     &quot;pass-environment-to-command&quot;:     [       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;head_commit.id&quot;,         &quot;envname&quot;: &quot;COMMIT_ID&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;pusher.name&quot;,         &quot;envname&quot;: &quot;PUSHER_NAME&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;pusher.email&quot;,         &quot;envname&quot;: &quot;PUSHER_EMAIL&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;head_commit.id&quot;,         &quot;envname&quot;: &quot;COMMIT_ID&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;pusher.name&quot;,         &quot;envname&quot;: &quot;PUSHER_NAME&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;ref&quot;,         &quot;envname&quot;: &quot;REF&quot;       }     ],     &quot;trigger-rule&quot;:     {       &quot;match&quot;:       {         &quot;type&quot;: &quot;payload-hash-sha1&quot;,         &quot;secret&quot;: &quot;&lt;password&gt;&quot;,         &quot;parameter&quot;:         {           &quot;source&quot;: &quot;header&quot;,           &quot;name&quot;: &quot;X-Hub-Signature&quot;         }       }     }   } ]  Restart webhook # systemctl restart webhook Next update the shell script go-hello-world.sh. This will be triggered each time a push request is sent to GitHub. It will also receive environment parameters needed for CI from GitHub. # vi /usr/local/bin/go-hello-world.sh #!/bin/sh printenv &gt;/tmp/env.out BRANCH=`echo $REF |sed -e &#39;s/refs\/heads\///g&#39;`">





  <meta name="twitter:site" content="@keithtenzer">
  <meta name="twitter:title" content="CI/CD with Ansible Tower and GitHub">
  <meta name="twitter:description" content="Overview Over the last few years CI/CD (Continuous Integration/Continuous Deployment) thanks to new technologies has become a lot easier. It should no longer be a major thorn in the side of developers. Many are moving to cloud platforms which has CI/CD built-in (Azure DevOps for example), others are using Kubernetes which clearly reduces a lot of the complexity around CI/CD. Still at many organizations I see Jenkins or other complex and often homegrown tooling. I certainly recognize this tooling was needed but in 2019 there are better, more streamlined options. Now I get it, our butler Jenkins has served us well, for many years, he has become part of our family. But just like the famous Butler, Alfred from Batman, he has gotten old and likely it is time to look into retirement. In this article we will discuss and demonstrate how to use Ansible Tower and GitHub for CI/CD. A video presentation and demonstration is available at following URL: https://youtu.be/lyk-CRVXs8I  Why Ansible Tower for CI/CD? Most organizations are adopting an infrastructure-as-code approach, that is to say everyone, even operations are becoming developers or at least working and thinking like developers. The automation tool of choice or even standard if you will is clearly Ansible. However Ansible is just an automation runtime, it has no API, RBAC, Credentials and does not enable collaboration between teams. This is where Ansible Tower (or AWX the opensource project) shines. Here are some advantages Ansible Tower bring to CI/CD:  Reuse infrastructure and operations playbooks in CI/CD Better collaboration between devops and infrastructure teams Simple CI/CD, just Ansible, no DML, no Groovy, no god knows what Ansible Tower is a enterprise product not a project like Jenkins Streamlined CI/CD instead of every devops team on their own Self organizing and governing because that is what Ansible does best  Now clearly Ansible Tower cannot do everything. It does not have for example a built-in CI/CD approval process and does not specifically focus on CI/CD. Instead Ansible Tower is an automation platform. It views the world through job templates (a playbook) and workflows (group of playbooks). In this case a workflow is a CI/CD pipeline with an API in front of it of course. Once you have your workflows or pipelines and an API in front of them you are 90% done. The rest is just how the process should flow and you might not even need any extra tooling to do that, certainly not complex tooling like Jenkins. Ansible Tower CI/CD Architecture The point of this article is to demonstrate that CI/CD can work very simply and with just Ansible Tower and GitHub. The diagram below illustrates what we will be building. This focuses only really on CI but CD would just be additional workflows.  The main purpose of CI is of course to protect the master branch so it always builds. The only way you do that of course is to check code into another branch (like a feature branch), test that code, review code and only merge to master when you are sure all tests have passed. The above architecture accomplished exactly that and does so with a very simplified approach that leverages Ansible Tower as our CI engine. We won&#39;t be going into the CD details in this article, but that would just be additional workflows to deploy artifacts generated by the CI process into dev-&gt;test-&gt;production. Using this architecture one could use GitHub releases to store artifacts. GitHub has ability to then trigger a webhook when latest release is updated which in turn could trigger an Ansible Tower CD workflow. Ansible Tower Configuration First we will want to configure a workflow in Ansible Tower that will be a CI/CD pipeline. I think it is good practice to have one workflow per pipeline. In this example we have a single workflow which handles CI. Configure Credentials We need machine credentials for Fedora since we will be accessing a fedora host to execute our build. In Ansible Tower credentials allow you to access systems without needing to connect to them directly, like you would with normal Ansible. Users don&#39;t even need to know credentials.  Configure Inventory Inventories in Ansible Tower are generated dynamically. This is important because when we provision a VM we don&#39;t at the time know what it&#39;s IP will be. Of course after we provision we want to access the VM. The solution is to perform an inventory update after provisioning and then parameterize provisioning and execution playbooks so they create/use same hostnames. Here we are using OpenStack but this could be any public or private cloud. For doing CI we created an inventory called development and this is what we will be later using in our job templates.  Configure Projects Projects in Ansible Tower are simply SCM repositories where playbooks reside. In this case of course a GitHub repository. Here notice the developer playbooks to do the build are located with the source code where the provisioning playbooks are in a different repository. This is where we get collaboration between infrastructure operations teams and devops. Something that rarely existed in CI/CD. Links to go-hello-world and paas-and-iaas repositories.  Configure Job Templates For our CI pipeline we will need to run three playbooks. Each playbook is a job template. In Ansible Tower a job template is a playbook, it&#39;s inventory, survey, credentials and various other things that go way beyond plain old Ansible. The three job templates are one to provision a fedora instance (from infrastructure / operations team), a playbook to perform the go build / tests (from devops team) and a playbook to cleanup (from infrastructure / operations team).  Configure Ansible Tower Workflow As mentioned a workflow will bring all the playbooks/job templates together. Here we configure a workflow called GO CI/CD Workflow. Notice the below workflow. We are using our three job templates provision fedora, run go build and remove instance. In addition the second step performs an inventory update for the development inventory. A workflow allows you to perform granular inventory updates wherever needed.  We aren&#39;t quite done, the last step is to add a survey to the Workflow. Each of the playbooks of course accept parameters. These need to be added in form of survey. A survey provides a user friendly interface for parameterizing workflows or job templates in Ansible Tower.  Ansible Tower CI/CD Setup The first thing to do is setup tower-cli. This is a much better tool than curl to trigger Ansible Tower. From the webhook we will use tower-cli to update projects in Ansible Tower and launch workflows. Install tower-cli My fellow Colleague, Andreas Neeb created a role to install tower-cli. https://github.com/andyneeb/ansible-demo-infra/tree/master/roles/tower-cli-setup Simply create playbook that uses role on localhost or host in your inventory where you want to install tower-cli. Fork go-hello-world &nbsp; Configure GitHub Webhook Token In order to update commit status in GitHub we need permissions and a webhook token. In GitHub under your user-&gt;settings go to developer settings.  Select personal access tokens and create a new one.  Add a note and select repo:status. This is the minimum permission in GitHub needed to update a commit status. For CI/CD you need to be able in GitHub update commit status. Configure GitHub Webhook In GitHub go to the go-hello-world project. Under settings create a new webhook.  Make sure content-type is application/json and set a secret, this is a password that will be used to authenticate to the webhook listener we will deploy next. Install Webhook Listener on Ansible Tower The folks at Arctiq created a role and playbook for setting up a webhook listener on Ansible Tower. https://github.com/ArctiqTeam/tower-webhook Simply clone the repository, update the vars.yml  and hosts file according. # vi hosts [webhook] webhookserver ansible_host=46.4.207.248 ansible_ssh_port=22 # vi vars.yml --- projects: - id: 7 name: go-hello-world # export GH_SECRET= # export TOWER_PASSWORD= # ansible-playbook install.yml The playbook will create a systemctl service called webhook so it can easily be started and stopped. The webhook will run on port 9000.  Configure Webhook Listener In order to use webhook for CI/CD some changes need to be made. Update the webhook.conf as follows. # vi /etc/webhook/webhook.conf [   {     &quot;id&quot;: &quot;go-hello-world&quot;,     &quot;execute-command&quot;: &quot;/usr/local/bin/go-hello-world.sh&quot;,     &quot;pass-environment-to-command&quot;:     [       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;head_commit.id&quot;,         &quot;envname&quot;: &quot;COMMIT_ID&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;pusher.name&quot;,         &quot;envname&quot;: &quot;PUSHER_NAME&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;pusher.email&quot;,         &quot;envname&quot;: &quot;PUSHER_EMAIL&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;head_commit.id&quot;,         &quot;envname&quot;: &quot;COMMIT_ID&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;pusher.name&quot;,         &quot;envname&quot;: &quot;PUSHER_NAME&quot;       },       {         &quot;source&quot;: &quot;payload&quot;,         &quot;name&quot;: &quot;ref&quot;,         &quot;envname&quot;: &quot;REF&quot;       }     ],     &quot;trigger-rule&quot;:     {       &quot;match&quot;:       {         &quot;type&quot;: &quot;payload-hash-sha1&quot;,         &quot;secret&quot;: &quot;&lt;password&gt;&quot;,         &quot;parameter&quot;:         {           &quot;source&quot;: &quot;header&quot;,           &quot;name&quot;: &quot;X-Hub-Signature&quot;         }       }     }   } ]  Restart webhook # systemctl restart webhook Next update the shell script go-hello-world.sh. This will be triggered each time a push request is sent to GitHub. It will also receive environment parameters needed for CI from GitHub. # vi /usr/local/bin/go-hello-world.sh #!/bin/sh printenv &gt;/tmp/env.out BRANCH=`echo $REF |sed -e &#39;s/refs\/heads\///g&#39;`">
  <meta name="twitter:url" content="http://localhost:4000/code/ci-cd-with-ansible-tower-and-github/">

  
    <meta name="twitter:card" content="summary">
    
  

  



  <meta property="article:published_time" content="2019-06-24T00:00:00-07:00">





  

  


<link rel="canonical" href="http://localhost:4000/code/ci-cd-with-ansible-tower-and-github/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Keith Tenzer",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Keith Tenzer's Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Keith Tenzer's Blog
          <span class="site-subtitle">Cloud Computing and Code</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/about/index.html">About</a>
            </li><li class="masthead__menu-item">
              <a href="/conferences-and-events/index.html">Conferences and Events</a>
            </li><li class="masthead__menu-item">
              <a href="/videos/index.html">Videos</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="http://localhost:4000/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/categories/#code" itemprop="item"><span itemprop="name">Code</span></a>
          <meta itemprop="position" content="2" />
        </li>
        <span class="sep">/</span>
      
    
      
      
        <li class="current">CI/CD with Ansible Tower and GitHub</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/main/me.png" alt="Keith Tenzer" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Keith Tenzer</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Principal Solutions Architect at Red Hat</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Los Angeles, CA</span>
        </li>
      

      
        
          
        
          
        
          
            <li><a href="https://twitter.com/keithtenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i><span class="label">Twitter</span></a></li>
          
        
          
        
          
            <li><a href="https://github.com/ktenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="CI/CD with Ansible Tower and GitHub">
    <meta itemprop="description" content="OverviewOver the last few years CI/CD (Continuous Integration/Continuous Deployment) thanks to new technologies has become a lot easier. It should no longer be a major thorn in the side of developers. Many are moving to cloud platforms which has CI/CD built-in (Azure DevOps for example), others are using Kubernetes which clearly reduces a lot of the complexity around CI/CD. Still at many organizations I see Jenkins or other complex and often homegrown tooling. I certainly recognize this tooling was needed but in 2019 there are better, more streamlined options. Now I get it, our butler Jenkins has served us well, for many years, he has become part of our family. But just like the famous Butler, Alfred from Batman, he has gotten old and likely it is time to look into retirement.In this article we will discuss and demonstrate how to use Ansible Tower and GitHub for CI/CD.A video presentation and demonstration is available at following URL: https://youtu.be/lyk-CRVXs8IWhy Ansible Tower for CI/CD?Most organizations are adopting an infrastructure-as-code approach, that is to say everyone, even operations are becoming developers or at least working and thinking like developers. The automation tool of choice or even standard if you will is clearly Ansible. However Ansible is just an automation runtime, it has no API, RBAC, Credentials and does not enable collaboration between teams. This is where Ansible Tower (or AWX the opensource project) shines. Here are some advantages Ansible Tower bring to CI/CD:Reuse infrastructure and operations playbooks in CI/CDBetter collaboration between devops and infrastructure teamsSimple CI/CD, just Ansible, no DML, no Groovy, no god knows whatAnsible Tower is a enterprise product not a project like JenkinsStreamlined CI/CD instead of every devops team on their ownSelf organizing and governing because that is what Ansible does bestNow clearly Ansible Tower cannot do everything. It does not have for example a built-in CI/CD approval process and does not specifically focus on CI/CD. Instead Ansible Tower is an automation platform. It views the world through job templates (a playbook) and workflows (group of playbooks). In this case a workflow is a CI/CD pipeline with an API in front of it of course. Once you have your workflows or pipelines and an API in front of them you are 90% done. The rest is just how the process should flow and you might not even need any extra tooling to do that, certainly not complex tooling like Jenkins.Ansible Tower CI/CD ArchitectureThe point of this article is to demonstrate that CI/CD can work very simply and with just Ansible Tower and GitHub. The diagram below illustrates what we will be building. This focuses only really on CI but CD would just be additional workflows.The main purpose of CI is of course to protect the master branch so it always builds. The only way you do that of course is to check code into another branch (like a feature branch), test that code, review code and only merge to master when you are sure all tests have passed. The above architecture accomplished exactly that and does so with a very simplified approach that leverages Ansible Tower as our CI engine. We won&#39;t be going into the CD details in this article, but that would just be additional workflows to deploy artifacts generated by the CI process into dev-&gt;test-&gt;production. Using this architecture one could use GitHub releases to store artifacts. GitHub has ability to then trigger a webhook when latest release is updated which in turn could trigger an Ansible Tower CD workflow.Ansible Tower ConfigurationFirst we will want to configure a workflow in Ansible Tower that will be a CI/CD pipeline. I think it is good practice to have one workflow per pipeline. In this example we have a single workflow which handles CI.Configure CredentialsWe need machine credentials for Fedora since we will be accessing a fedora host to execute our build. In Ansible Tower credentials allow you to access systems without needing to connect to them directly, like you would with normal Ansible. Users don&#39;t even need to know credentials.Configure InventoryInventories in Ansible Tower are generated dynamically. This is important because when we provision a VM we don&#39;t at the time know what it&#39;s IP will be. Of course after we provision we want to access the VM. The solution is to perform an inventory update after provisioning and then parameterize provisioning and execution playbooks so they create/use same hostnames.Here we are using OpenStack but this could be any public or private cloud. For doing CI we created an inventory called development and this is what we will be later using in our job templates.Configure ProjectsProjects in Ansible Tower are simply SCM repositories where playbooks reside. In this case of course a GitHub repository. Here notice the developer playbooks to do the build are located with the source code where the provisioning playbooks are in a different repository. This is where we get collaboration between infrastructure operations teams and devops. Something that rarely existed in CI/CD.Links to go-hello-world and paas-and-iaas repositories.Configure Job TemplatesFor our CI pipeline we will need to run three playbooks. Each playbook is a job template. In Ansible Tower a job template is a playbook, it&#39;s inventory, survey, credentials and various other things that go way beyond plain old Ansible. The three job templates are one to provision a fedora instance (from infrastructure / operations team), a playbook to perform the go build / tests (from devops team) and a playbook to cleanup (from infrastructure / operations team).Configure Ansible Tower WorkflowAs mentioned a workflow will bring all the playbooks/job templates together. Here we configure a workflow called GO CI/CD Workflow. Notice the below workflow. We are using our three job templates provision fedora, run go build and remove instance. In addition the second step performs an inventory update for the development inventory. A workflow allows you to perform granular inventory updates wherever needed.We aren&#39;t quite done, the last step is to add a survey to the Workflow. Each of the playbooks of course accept parameters. These need to be added in form of survey. A survey provides a user friendly interface for parameterizing workflows or job templates in Ansible Tower.Ansible Tower CI/CD SetupThe first thing to do is setup tower-cli. This is a much better tool than curl to trigger Ansible Tower. From the webhook we will use tower-cli to update projects in Ansible Tower and launch workflows.Install tower-cliMy fellow Colleague, Andreas Neeb created a role to install tower-cli.https://github.com/andyneeb/ansible-demo-infra/tree/master/roles/tower-cli-setupSimply create playbook that uses role on localhost or host in your inventory where you want to install tower-cli.Fork go-hello-world&nbsp;Configure GitHub Webhook TokenIn order to update commit status in GitHub we need permissions and a webhook token.In GitHub under your user-&gt;settings go to developer settings.Select personal access tokens and create a new one.Add a note and select repo:status. This is the minimum permission in GitHub needed to update a commit status. For CI/CD you need to be able in GitHub update commit status.Configure GitHub WebhookIn GitHub go to the go-hello-world project. Under settings create a new webhook.Make sure content-type is application/json and set a secret, this is a password that will be used to authenticate to the webhook listener we will deploy next.Install Webhook Listener on Ansible TowerThe folks at Arctiq created a role and playbook for setting up a webhook listener on Ansible Tower.https://github.com/ArctiqTeam/tower-webhookSimply clone the repository, update the vars.yml  and hosts file according.# vi hosts[webhook]webhookserver ansible_host=46.4.207.248 ansible_ssh_port=22# vi vars.yml---projects:- id: 7name: go-hello-world# export GH_SECRET=# export TOWER_PASSWORD=# ansible-playbook install.ymlThe playbook will create a systemctl service called webhook so it can easily be started and stopped. The webhook will run on port 9000. Configure Webhook ListenerIn order to use webhook for CI/CD some changes need to be made. Update the webhook.conf as follows.# vi /etc/webhook/webhook.conf[  {    &quot;id&quot;: &quot;go-hello-world&quot;,    &quot;execute-command&quot;: &quot;/usr/local/bin/go-hello-world.sh&quot;,    &quot;pass-environment-to-command&quot;:    [      {        &quot;source&quot;: &quot;payload&quot;,        &quot;name&quot;: &quot;head_commit.id&quot;,        &quot;envname&quot;: &quot;COMMIT_ID&quot;      },      {        &quot;source&quot;: &quot;payload&quot;,        &quot;name&quot;: &quot;pusher.name&quot;,        &quot;envname&quot;: &quot;PUSHER_NAME&quot;      },      {        &quot;source&quot;: &quot;payload&quot;,        &quot;name&quot;: &quot;pusher.email&quot;,        &quot;envname&quot;: &quot;PUSHER_EMAIL&quot;      },      {        &quot;source&quot;: &quot;payload&quot;,        &quot;name&quot;: &quot;head_commit.id&quot;,        &quot;envname&quot;: &quot;COMMIT_ID&quot;      },      {        &quot;source&quot;: &quot;payload&quot;,        &quot;name&quot;: &quot;pusher.name&quot;,        &quot;envname&quot;: &quot;PUSHER_NAME&quot;      },      {        &quot;source&quot;: &quot;payload&quot;,        &quot;name&quot;: &quot;ref&quot;,        &quot;envname&quot;: &quot;REF&quot;      }    ],    &quot;trigger-rule&quot;:    {      &quot;match&quot;:      {        &quot;type&quot;: &quot;payload-hash-sha1&quot;,        &quot;secret&quot;: &quot;&lt;password&gt;&quot;,        &quot;parameter&quot;:        {          &quot;source&quot;: &quot;header&quot;,          &quot;name&quot;: &quot;X-Hub-Signature&quot;        }      }    }  }]Restart webhook# systemctl restart webhookNext update the shell script go-hello-world.sh. This will be triggered each time a push request is sent to GitHub. It will also receive environment parameters needed for CI from GitHub.# vi /usr/local/bin/go-hello-world.sh#!/bin/shprintenv &gt;/tmp/env.outBRANCH=`echo $REF |sed -e &#39;s/refs\/heads\///g&#39;`">
    <meta itemprop="datePublished" content="2019-06-24T00:00:00-07:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">CI/CD with Ansible Tower and GitHub
</h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2019-06-24T00:00:00-07:00">June 24, 2019</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          20 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
        <h2><img class="alignnone  wp-image-13796" src="/assets/2019/06/red-hat-ansible-tower-vector-logo.png" alt="red-hat-ansible-tower-vector-logo" width="250" height="139" /><img class="alignnone size-full wp-image-12472" src="/assets/2019/06/plus_sign.gif" alt="plus_sign" width="161" height="161" /><img class="alignnone  wp-image-13797" src="/assets/2019/06/2cb670b6ddd8922a1c1b2fee4f6f758c.jpg" alt="2cb670b6ddd8922a1c1b2fee4f6f758c" width="213" height="160" /></h2>
<h2>Overview</h2>
<p>Over the last few years CI/CD (Continuous Integration/Continuous Deployment) thanks to new technologies has become a lot easier. It should no longer be a major thorn in the side of developers. Many are moving to cloud platforms which has CI/CD built-in (Azure DevOps for example), others are using Kubernetes which clearly reduces a lot of the complexity around CI/CD. Still at many organizations I see Jenkins or other complex and often homegrown tooling. I certainly recognize this tooling was needed but in 2019 there are better, more streamlined options. Now I get it, our butler Jenkins has served us well, for many years, he has become part of our family. But just like the famous Butler, Alfred from Batman, he has gotten old and likely it is time to look into retirement.</p>
<p>In this article we will discuss and demonstrate how to use Ansible Tower and GitHub for CI/CD.</p>
<p>A video presentation and demonstration is available at following URL: <a href="https://youtu.be/lyk-CRVXs8I">https://youtu.be/lyk-CRVXs8I</a></p>
<p><!--more--></p>
<h2>Why Ansible Tower for CI/CD?</h2>
<p>Most organizations are adopting an infrastructure-as-code approach, that is to say everyone, even operations are becoming developers or at least working and thinking like developers. The automation tool of choice or even standard if you will is clearly Ansible. However Ansible is just an automation runtime, it has no API, RBAC, Credentials and does not enable collaboration between teams. This is where Ansible Tower (or AWX the opensource project) shines. Here are some advantages Ansible Tower bring to CI/CD:</p>
<ul>
<li>Reuse infrastructure and operations playbooks in CI/CD</li>
<li>Better collaboration between devops and infrastructure teams</li>
<li>Simple CI/CD, just Ansible, no DML, no Groovy, no god knows what</li>
<li>Ansible Tower is a enterprise product not a project like Jenkins</li>
<li>Streamlined CI/CD instead of every devops team on their own</li>
<li>Self organizing and governing because that is what Ansible does best</li>
</ul>
<p>Now clearly Ansible Tower cannot do everything. It does not have for example a built-in CI/CD approval process and does not specifically focus on CI/CD. Instead Ansible Tower is an automation platform. It views the world through job templates (a playbook) and workflows (group of playbooks). In this case a workflow is a CI/CD pipeline with an API in front of it of course. Once you have your workflows or pipelines and an API in front of them you are 90% done. The rest is just how the process should flow and you might not even need any extra tooling to do that, certainly not complex tooling like Jenkins.</p>
<h2>Ansible Tower CI/CD Architecture</h2>
<p>The point of this article is to demonstrate that CI/CD can work very simply and with just Ansible Tower and GitHub. The diagram below illustrates what we will be building. This focuses only really on CI but CD would just be additional workflows.</p>
<p><img class="alignnone  wp-image-13779" src="/assets/2019/06/tower_ci_cd_process.png" alt="tower_ci_cd_process" width="1054" height="654" /></p>
<p>The main purpose of CI is of course to protect the master branch so it always builds. The only way you do that of course is to check code into another branch (like a feature branch), test that code, review code and only merge to master when you are sure all tests have passed. The above architecture accomplished exactly that and does so with a very simplified approach that leverages Ansible Tower as our CI engine. We won't be going into the CD details in this article, but that would just be additional workflows to deploy artifacts generated by the CI process into dev-&gt;test-&gt;production. Using this architecture one could use GitHub releases to store artifacts. GitHub has ability to then trigger a webhook when latest release is updated which in turn could trigger an Ansible Tower CD workflow.</p>
<h2>Ansible Tower Configuration</h2>
<p>First we will want to configure a workflow in Ansible Tower that will be a CI/CD pipeline. I think it is good practice to have one workflow per pipeline. In this example we have a single workflow which handles CI.</p>
<h4>Configure Credentials</h4>
<p>We need machine credentials for Fedora since we will be accessing a fedora host to execute our build. In Ansible Tower credentials allow you to access systems without needing to connect to them directly, like you would with normal Ansible. Users don't even need to know credentials.</p>
<p><img class="alignnone  wp-image-13782" src="/assets/2019/06/tower_1-1.png" alt="tower_1" width="812" height="265" /></p>
<h4>Configure Inventory</h4>
<p>Inventories in Ansible Tower are generated dynamically. This is important because when we provision a VM we don't at the time know what it's IP will be. Of course after we provision we want to access the VM. The solution is to perform an inventory update after provisioning and then parameterize provisioning and execution playbooks so they create/use same hostnames.</p>
<p>Here we are using OpenStack but this could be any public or private cloud. For doing CI we created an inventory called development and this is what we will be later using in our job templates.</p>
<p><img class="alignnone  wp-image-13783" src="/assets/2019/06/tower_2.png" alt="tower_2" width="1469" height="458" /></p>
<h4>Configure Projects</h4>
<p>Projects in Ansible Tower are simply SCM repositories where playbooks reside. In this case of course a GitHub repository. Here notice the developer playbooks to do the build are located with the source code where the provisioning playbooks are in a different repository. This is where we get collaboration between infrastructure operations teams and devops. Something that rarely existed in CI/CD.</p>
<p>Links to <a href="https://github.com/ktenzer/go-hello-world">go-hello-world</a> and <a href="https://github.com/ktenzer/openshift-and-openstack-use-cases">paas-and-iaas</a> repositories.</p>
<p><img class="alignnone  wp-image-13784" src="/assets/2019/06/tower_3.png" alt="tower_3" width="854" height="221" /></p>
<h4>Configure Job Templates</h4>
<p>For our CI pipeline we will need to run three playbooks. Each playbook is a job template. In Ansible Tower a job template is a playbook, it's inventory, survey, credentials and various other things that go way beyond plain old Ansible. The three job templates are one to provision a fedora instance (from infrastructure / operations team), a playbook to perform the go build / tests (from devops team) and a playbook to cleanup (from infrastructure / operations team).</p>
<p><img class="alignnone  wp-image-13785" src="/assets/2019/06/twer_4.png" alt="twer_4" width="1183" height="461" /></p>
<h4>Configure Ansible Tower Workflow</h4>
<p>As mentioned a workflow will bring all the playbooks/job templates together. Here we configure a workflow called GO CI/CD Workflow. Notice the below workflow. We are using our three job templates provision fedora, run go build and remove instance. In addition the second step performs an inventory update for the development inventory. A workflow allows you to perform granular inventory updates wherever needed.</p>
<p><img class="alignnone  wp-image-13786" src="/assets/2019/06/tower_5.png" alt="tower_5" width="922" height="419" /></p>
<p>We aren't quite done, the last step is to add a survey to the Workflow. Each of the playbooks of course accept parameters. These need to be added in form of survey. A survey provides a user friendly interface for parameterizing workflows or job templates in Ansible Tower.</p>
<p><img class="alignnone size-full wp-image-13787" src="/assets/2019/06/tower_6.png" alt="tower_6" width="1740" height="874" /></p>
<h2>Ansible Tower CI/CD Setup</h2>
<p>The first thing to do is setup tower-cli. This is a much better tool than curl to trigger Ansible Tower. From the webhook we will use tower-cli to update projects in Ansible Tower and launch workflows.</p>
<h4>Install tower-cli</h4>
<p>My fellow Colleague, Andreas Neeb created a role to install tower-cli.</p>
<p><a href="https://github.com/andyneeb/ansible-demo-infra/tree/master/roles/tower-cli-setup">https://github.com/andyneeb/ansible-demo-infra/tree/master/roles/tower-cli-setup</a></p>
<p>Simply create playbook that uses role on localhost or host in your inventory where you want to install tower-cli.</p>
<h4>Fork go-hello-world</h4>
<p>&nbsp;</p>
<h4>Configure GitHub Webhook Token</h4>
<p>In order to update commit status in GitHub we need permissions and a webhook token.</p>
<p>In GitHub under your user-&gt;settings go to developer settings.</p>
<p><img class="alignnone  wp-image-13777" src="/assets/2019/06/github1.png" alt="github1" width="891" height="131" /></p>
<p>Select personal access tokens and create a new one.</p>
<p><img class="alignnone size-full wp-image-13778" src="/assets/2019/06/github2.png" alt="github2" width="1175" height="498" /></p>
<p>Add a note and select repo:status. This is the minimum permission in GitHub needed to update a commit status. For CI/CD you need to be able in GitHub update commit status.</p>
<h4>Configure GitHub Webhook</h4>
<p>In GitHub go to the go-hello-world project. Under settings create a new webhook.</p>
<p><img class="alignnone size-full wp-image-13780" src="/assets/2019/06/github3.png" alt="github3" width="1487" height="1002" /></p>
<p>Make sure content-type is application/json and set a secret, this is a password that will be used to authenticate to the webhook listener we will deploy next.</p>
<h4>Install Webhook Listener on Ansible Tower</h4>
<p>The folks at Arctiq created a role and playbook for setting up a webhook listener on Ansible Tower.</p>
<p><a href="https://github.com/ArctiqTeam/tower-webhook">https://github.com/ArctiqTeam/tower-webhook</a></p>
<p>Simply clone the repository, update the vars.yml  and hosts file according.</p>
<pre># vi hosts
[webhook]
webhookserver ansible_host=46.4.207.248 ansible_ssh_port=22</pre>
<pre># vi vars.yml
---
projects:
- id: 7
name: go-hello-world</pre>
<pre># export GH_SECRET=
# export TOWER_PASSWORD=
# ansible-playbook install.yml</pre>
<p>The playbook will create a systemctl service called webhook so it can easily be started and stopped. The webhook will run on port 9000.</p>
<h4> Configure Webhook Listener</h4>
<p>In order to use webhook for CI/CD some changes need to be made. Update the webhook.conf as follows.</p>
<pre># vi /etc/webhook/webhook.conf
[
  {
    "id": "go-hello-world",
    "execute-command": "/usr/local/bin/go-hello-world.sh",
    "pass-environment-to-command":
    [
      {
        "source": "payload",
        "name": "head_commit.id",
        "envname": "COMMIT_ID"
      },
      {
        "source": "payload",
        "name": "pusher.name",
        "envname": "PUSHER_NAME"
      },
      {
        "source": "payload",
        "name": "pusher.email",
        "envname": "PUSHER_EMAIL"
      },
      {
        "source": "payload",
        "name": "head_commit.id",
        "envname": "COMMIT_ID"
      },
      {
        "source": "payload",
        "name": "pusher.name",
        "envname": "PUSHER_NAME"
      },
      {
        "source": "payload",
        "name": "ref",
        "envname": "REF"
      }
    ],
    "trigger-rule":
    {
      "match":
      {
        "type": "payload-hash-sha1",
        "secret": "&lt;password&gt;",
        "parameter":
        {
          "source": "header",
          "name": "X-Hub-Signature"
        }
      }
    }
  }
]
</pre>
<h4>Restart webhook</h4>
<pre># systemctl restart webhook</pre>
<p>Next update the shell script go-hello-world.sh. This will be triggered each time a push request is sent to GitHub. It will also receive environment parameters needed for CI from GitHub.</p>
<pre># vi /usr/local/bin/go-hello-world.sh
#!/bin/sh
printenv &gt;/tmp/env.out
BRANCH=`echo $REF |sed -e 's/refs\/heads\///g'`

### Set Github commit to pending CI/CD
curl "https://api.GitHub.com/repos/ktenzer/go-hello-world/statuses/$COMMIT_ID?access_token=79dc2a78c4c009c3c08e6cbc8233559c535fc8dc" -H "Content-Type: application/json" -X POST -d "{\"state\": \"pending\",\"context\": \"continuous-integration/go-hello-world\", \"description\": \"Ansible_Tower\", \"target_url\": \"https://46.4.207.248\"}"

### Update Project in Tower
tower-cli project update 7 -v -h 46.4.207.248 --wait
if [ $? != 0 ]; then
        curl "https://api.GitHub.com/repos/ktenzer/go-hello-world/statuses/$COMMIT_ID?access_token=&lt;token&gt;" -H "Content-Type: application/json" -X POST -d "{\"state\": \"error\",\"context\": \"continuous-integration/go-hello-world\", \"description\": \"Ansible_Tower\", \"target_url\": \"https://46.4.207.248\"}"
        exit 1
fi

### Execute CI/CD Workflow in Tower
tower-cli workflow_job launch --workflow-job-template=18 -v -h 46.4.207.248 -e openstack_user=admin -e openstack_passwd=&lt;password&gt; -e openstack_auth_url=http://85.10.236.4:5000/v3 -e openstack_project=development -e instance_name=gobuilder -e instance_security_group=dev_base -e instance_image=fedora_28 -e instance_ssh_key_name=admin -e ssh_user=fedora -e instance_network=development -e instance_flavor=m1.small -e repo_url=https://github.com/ktenzer/go-hello-world.git -e repo_branch=$BRANCH -e app_path=hello/src -e app_name=hello --wait

### Update Github commit based on success or failure of CI/CD workflow
if [ $? != 0 ]; then
        curl "https://api.GitHub.com/repos/ktenzer/go-hello-world/statuses/$COMMIT_ID?access_token=&lt;token&gt;" -H "Content-Type: application/json" -X POST -d "{\"state\": \"error\",\"context\": \"continuous-integration/go-hello-world\", \"description\": \"Ansible_Tower\", \"target_url\": \"https://46.4.207.248\"}"
        exit 1

else
        curl "https://api.GitHub.com/repos/ktenzer/go-hello-world/statuses/$COMMIT_ID?access_token=&lt;token&gt;" -H "Content-Type: application/json" -X POST -d "{\"state\": \"success\",\"context\": \"continuous-integration/go-hello-world\", \"description\": \"Ansible_Tower\", \"target_url\": \"https://46.4.207.248\"}"
        exit 0
fi
</pre>
<h2>Run CI/CD Pipeline using Ansible Tower</h2>
<h4>Clone go-hello-world repository</h4>
<pre># git clone https://github.com/ktenzer/go-hello-world.git</pre>
<h4>Create feature branch</h4>
<pre># git branch patch-1
# git checkout patch-1</pre>
<h4>Add broken code</h4>
<pre># vi src/hello/main.go
...
func main() {
        &lt;broken&gt;
	router := NewRouter()
...
</pre>
<h4>Commit broken code</h4>
<pre># git commit -a -m "broken code"

# git push origin patch-1</pre>
<h4>Create pull request in GitHub</h4>
<p>Under branches you will now see the patch-1 branch.</p>
<p><img class="alignnone  wp-image-13788" src="/assets/2019/06/github1-1.png" alt="github1.png" width="782" height="354" /></p>
<p>You can now create a pull request in GitHub.</p>
<p><img class="alignnone  wp-image-13789" src="/assets/2019/06/github2-1.png" alt="github2.png" width="1198" height="409" /></p>
<p>Notice that CI/CD is in progress and the source is Ansible Tower. Of course the CI will fail since we broke the code. In Tower you can see looking at the go build job.</p>
<p><img class="alignnone  wp-image-13790" src="/assets/2019/06/tower2.png" alt="tower2.png" width="1588" height="320" /></p>
<p>Looking at our pull request in GitHub it also now shows error.</p>
<p><img class="alignnone size-full wp-image-13791" src="/assets/2019/06/github4.png?w=1026" alt="github4.png" width="1026" height="353" /></p>
<p>Notice the CI/CD process spawned a VM to perform build and run tests.</p>
<p><img class="alignnone size-full wp-image-13795" src="/assets/2019/06/osp1.png?w=1062" alt="osp1.png" width="1062" height="328" /></p>
<p>In this case the instance is not removed since the test failed. The idea is likely the developer would want to fix it and since we are using Ansible, once a fix is committed we will start where we left off, saving potentially a lot of time.</p>
<h4>Fix broken code</h4>
<pre># vi src/hello/main.go
...
func main() {
	router := NewRouter()
...
</pre>
<h4>Commit broken code</h4>
<pre># git commit -a -m "fixed code"

# git push origin patch-1</pre>
<p>This will start the CI/CD process again except this time of course our code builds and CI is successful.</p>
<p>Looking at GitHub we see the pull request has gone through CI and all tests are successful.</p>
<p><img class="alignnone  wp-image-13792" src="/assets/2019/06/github5.png" alt="github5.png" width="1314" height="369" /></p>
<p>In Ansible Tower we also see the jobs completed.</p>
<p><img class="alignnone  wp-image-13793" src="/assets/2019/06/tower3.png" alt="tower3" width="1712" height="443" /></p>
<p>At this point a developer could review the code and merge it. In GitHub we will now merge the pull request.</p>
<p><img class="alignnone  wp-image-13794" src="/assets/2019/06/github6.png" alt="github6.png" width="1032" height="481" /></p>
<p>The CI process is started again this time for the master branch. Once master builds we have a release and can start the CD process. We would as mentioned above, push the release to GitHub releases and that would in turn trigger another workflow or several workflows to deploy the release in various dev, test and production environments. We will not be doing this but I think you get the picture.</p>
<h2>Summary</h2>
<p>In this article we discussed a simpler solution for CI/CD by using just Ansible Tower and GitHub. We saw the advantages of making Ansible reusability the cornerstone of CI/CD, not only in simplicity but bringing infrastructure/operations teams together with development. We went through the configuration and saw a demonstration of how the solution works. If you are interested further or have any questions/feedback please feel free to reach out.</p>
<p>Happy CI/CD’ing!</p>
<p>(c) 2019 Keith Tenzer</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#ansible" class="page__taxonomy-item" rel="tag">Ansible</a><span class="sep">, </span>
    
      <a href="/tags/#ansible-tower" class="page__taxonomy-item" rel="tag">Ansible Tower</a><span class="sep">, </span>
    
      <a href="/tags/#ci-cd" class="page__taxonomy-item" rel="tag">ci/cd</a><span class="sep">, </span>
    
      <a href="/tags/#development" class="page__taxonomy-item" rel="tag">development</a><span class="sep">, </span>
    
      <a href="/tags/#devops" class="page__taxonomy-item" rel="tag">DevOps</a><span class="sep">, </span>
    
      <a href="/tags/#golang" class="page__taxonomy-item" rel="tag">Golang</a><span class="sep">, </span>
    
      <a href="/tags/#opensource" class="page__taxonomy-item" rel="tag">opensource</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#code" class="page__taxonomy-item" rel="tag">code</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2019-06-24T00:00:00-07:00">June 24, 2019</time></p>


      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?via=keithtenzer&text=CI%2FCD+with+Ansible+Tower+and+GitHub%20http%3A%2F%2Flocalhost%3A4000%2Fcode%2Fci-cd-with-ansible-tower-and-github%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fcode%2Fci-cd-with-ansible-tower-and-github%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fcode%2Fci-cd-with-ansible-tower-and-github%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/code/powerful-but-simple-ci-cd-with-azure-devops-and-go/" class="pagination--pager" title="Powerful but Simple CI/CD with Azure DevOps and Go
">Previous</a>
    
    
      <a href="/cloud/how-to-create-a-rhel-8-image-for-hetzner-root-servers/" class="pagination--pager" title="How to Create a RHEL 8 Image for Hetzner Root Servers
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/openshift/building-ansible-operators-1-2-3/" rel="permalink">Building Ansible Operators 1-2-3
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-12-03T00:00:00-08:00">December 3, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          10 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Overview
In this article we will go step by step to build a Kubernetes Operator using Ansible and the Operator Framework. Operators provide the ability to no...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/openshift/openshift-service-mesh-getting-started-guide/" rel="permalink">OpenShift Service Mesh Getting Started Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-04-27T00:00:00-07:00">April 27, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          11 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">






Overview
In this article we will explore the OpenShift Service Mesh and deploy a demo application to better understand the various concepts. First you...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/openshift/openshift-4-aws-ipi-installation-getting-started-guide/" rel="permalink">OpenShift 4 AWS IPI Installation Getting Started Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2021-01-18T00:00:00-08:00">January 18, 2021</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          8 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">


Happy new year as this will be the first post of 2021! 2020 was obviously a challenging year, my hope is I will have more time to devote to blogging in 20...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ansible/windows-automation-with-ansible-getting-started-guide/" rel="permalink">Windows Automation with Ansible: Getting Started Guide
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2020-05-19T00:00:00-07:00">May 19, 2020</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          14 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">
Overview
In this article we will focus on how to get started with automation of windows using Ansible. Specifically we will look at installing 3rd party sof...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://twitter.com/keithtenzer"" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
      
        
          <li><a href="https://github.com/ktenzer" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2022 Keith Tenzer. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
